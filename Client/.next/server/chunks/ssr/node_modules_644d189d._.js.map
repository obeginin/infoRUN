{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@siberiacancode/reactuse/dist/esm/hooks/useRefState/useRefState.mjs","sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40siberiacancode/reactuse/src/hooks/useRefState/useRefState.ts"],"sourcesContent":["import { useState } from 'react';\n\nexport interface StateRef<Value> {\n  (node: Value): void;\n  current: Value;\n  state?: Value;\n}\n\nconst createRefState = <Value>(\n  initialValue: Value | undefined,\n  setState: (value: Value) => void\n) => {\n  let temp = initialValue;\n  function ref(value: Value) {\n    if (temp === value) return;\n    temp = value;\n    setState(temp);\n  }\n\n  Object.defineProperty(ref, 'current', {\n    get() {\n      return temp;\n    },\n    set(value: Value) {\n      if (temp === value) return;\n      temp = value;\n      setState(temp);\n    },\n    configurable: true,\n    enumerable: true\n  });\n\n  return ref as StateRef<Value>;\n};\n\n/**\n * @name useRefState\n * @description - Hook that returns the state reference of the value\n * @category State\n *\n * @template Value The type of the value\n * @param {Value} [initialValue] The initial value\n * @returns {StateRef<Value>} The current value\n *\n * @example\n * const internalRefState = useRefState();\n */\nexport const useRefState = <Value>(initialValue?: Value) => {\n  const [state, setState] = useState<Value | undefined>(initialValue);\n  const [ref] = useState(() => createRefState<Value>(initialValue, setState));\n  ref.state = state;\n  return ref;\n};\n"],"names":["createRefState","initialValue","setState","temp","ref","value","useRefState","state","useState"],"mappings":";;;;;AAQA,MAAMA,IAAiB,CACrBC,GACAC,MACG;IACH,IAAIC,IAAOF;IACX,SAASG,EAAIC,CAAAA,EAAc;QACrBF,MAASE,KAAAA,CACbF,IAAOE,GACPH,EAASC,CAAI,CAAA;IAAA;IAGf,OAAA,OAAO,cAAA,CAAeC,GAAK,WAAW;QACpC,MAAM;YACJ,OAAOD;QAAA;QAET,KAAIE,CAAAA,EAAc;YACZF,MAASE,KAAAA,CACbF,IAAOE,GACPH,EAASC,CAAI,CAAA;QAAA;QAEf,cAAc,CAAA;QACd,YAAY,CAAA;IAAA,CACb,GAEMC;AACT,GAcaE,IAAc,CAAQL,MAAyB;IAC1D,MAAM,CAACM,GAAOL,CAAQ,CAAA,wNAAIM,EAA4BP,CAAY,GAC5D,CAACG,CAAG,CAAA,wNAAII,EAAS,IAAMR,EAAsBC,GAAcC,CAAQ,CAAC;IAC1E,OAAAE,EAAI,KAAA,GAAQG,GACLH;AACT","debugId":null}},
    {"offset": {"line": 35, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@siberiacancode/reactuse/dist/esm/utils/helpers/getElement.mjs","sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40siberiacancode/reactuse/src/utils/helpers/getElement.ts"],"sourcesContent":["import type { RefObject } from 'react';\n\nexport type Target = (() => Element) | string | Document | Element | Window;\nexport type HookTarget =\n  | RefObject<Element | null | undefined>\n  | {\n      value: Target;\n      type: symbol;\n    };\n\nexport const targetSymbol = Symbol('target');\nexport const target = (target: Target) => ({\n  value: target,\n  type: targetSymbol\n});\n\nexport const getElement = (target: HookTarget) => {\n  if ('current' in target) {\n    return target.current;\n  }\n\n  if (typeof target.value === 'function') {\n    return target.value();\n  }\n\n  if (typeof target.value === 'string') {\n    return document.querySelector(target.value);\n  }\n\n  if (target.value instanceof Document) {\n    return target.value;\n  }\n\n  if (target.value instanceof Window) {\n    return target.value;\n  }\n\n  if (target.value instanceof Element) {\n    return target.value;\n  }\n\n  return target.value;\n};\n"],"names":["targetSymbol","target","getElement"],"mappings":";;;;;AAUO,MAAMA,IAAe,OAAO,QAAQ,GAC9BC,IAAS,CAACA,IAAAA,CAAoB;QACzC,OAAOA;QACP,MAAMD;IACR,CAAA,GAEaE,IAAa,CAACD,IACrB,aAAaA,IACRA,EAAO,OAAA,GAGZ,OAAOA,EAAO,KAAA,IAAU,aACnBA,EAAO,KAAA,CAAA,IAGZ,OAAOA,EAAO,KAAA,IAAU,WACnB,SAAS,aAAA,CAAcA,EAAO,KAAK,IAAA,CAGxCA,EAAO,KAAA,YAAiB,YAIxBA,EAAO,KAAA,YAAiB,UAIxBA,EAAO,KAAA,YAAiB,SACnBA,EAAO,KAAA","debugId":null}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@siberiacancode/reactuse/dist/esm/utils/helpers/isTarget.mjs","sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40siberiacancode/reactuse/src/utils/helpers/isTarget.ts"],"sourcesContent":["import type { HookTarget } from './getElement';\n\nimport { targetSymbol } from './getElement';\n\nexport const isTarget = (target: HookTarget) =>\n  typeof target === 'object' && ('current' in target || target.type === targetSymbol);\n"],"names":["isTarget","target","targetSymbol"],"mappings":";;;;;AAIO,MAAMA,IAAW,CAACC,IACvB,OAAOA,KAAW,YAAA,CAAa,aAAaA,KAAUA,EAAO,IAAA,oMAASC,eAAAA","debugId":null}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@siberiacancode/reactuse/dist/esm/hooks/useIntersectionObserver/useIntersectionObserver.mjs","sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40siberiacancode/reactuse/src/hooks/useIntersectionObserver/useIntersectionObserver.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nexport type UseIntersectionObserverCallback = (entry: IntersectionObserverEntry) => void;\n\n/** The intersection observer options type */\nexport interface UseIntersectionObserverOptions extends Omit<IntersectionObserverInit, 'root'> {\n  enabled?: boolean;\n  onChange?: UseIntersectionObserverCallback;\n  root?: HookTarget;\n}\n\n/** The intersection observer return type */\nexport interface UseIntersectionObserverReturn {\n  entry?: IntersectionObserverEntry;\n  inView: boolean;\n}\n\nexport interface UseIntersectionObserver {\n  <Target extends Element>(\n    options?: UseIntersectionObserverOptions,\n    target?: never\n  ): UseIntersectionObserverReturn & { ref: StateRef<Target> };\n\n  (target: HookTarget, options?: UseIntersectionObserverOptions): UseIntersectionObserverReturn;\n\n  <Target extends Element>(\n    callback: UseIntersectionObserverCallback,\n    target?: never\n  ): UseIntersectionObserverReturn & { ref: StateRef<Target> };\n\n  (callback: UseIntersectionObserverCallback, target: HookTarget): UseIntersectionObserverReturn;\n}\n\n/**\n * @name useIntersectionObserver\n * @description - Hook that gives you intersection observer state\n * @category Sensors\n *\n * @browserapi IntersectionObserver https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver\n *\n * @overload\n * @param {HookTarget} target The target element to detect intersection\n * @param {boolean} [options.enabled=true] The IntersectionObserver options\n * @param {((entries: IntersectionObserverEntry[], observer: IntersectionObserver) => void) | undefined} [options.onChange] The callback to execute when intersection is detected\n * @param {HookTarget} [options.root=document] The root element to observe\n * @returns {UseIntersectionObserverReturn} An object containing the state\n *\n * @example\n * const { ref, entry, inView } = useIntersectionObserver();\n *\n * @overload\n * @template Target The target element\n * @param {boolean} [options.enabled=true] The IntersectionObserver options\n * @param {((entries: IntersectionObserverEntry[], observer: IntersectionObserver) => void) | undefined} [options.onChange] The callback to execute when intersection is detected\n * @param {HookTarget} [options.root=document] The root element to observe\n * @returns {UseIntersectionObserverReturn & { ref: StateRef<Target> }} A React ref to attach to the target element\n *\n * @example\n * const { entry, inView } = useIntersectionObserver(ref);\n *\n * @overload\n * @template Target The target element\n * @param {UseIntersectionObserverCallback} callback The callback to execute when intersection is detected\n * @returns {UseIntersectionObserverReturn & { ref: StateRef<Target> }} A React ref to attach to the target element\n *\n * @example\n * const { ref, entry, inView } = useIntersectionObserver(() => console.log('callback'));\n *\n * @overload\n * @param {UseIntersectionObserverCallback} callback The callback to execute when intersection is detected\n * @param {HookTarget} target The target element to detect intersection\n * @returns {UseIntersectionObserverReturn} An object containing the state\n *\n * @example\n * const { entry, inView } = useIntersectionObserver(() => console.log('callback'), ref);\n */\nexport const useIntersectionObserver = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { onChange: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { onChange: params[0] }\n  ) as UseIntersectionObserverOptions | undefined;\n\n  const callback = options?.onChange;\n  const enabled = options?.enabled ?? true;\n\n  const [entry, setEntry] = useState<IntersectionObserverEntry>();\n\n  const internalRef = useRefState<Element>();\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  useEffect(() => {\n    if (!enabled || (!target && !internalRef.state)) return;\n\n    const element = target ? getElement(target) : internalRef.current;\n    if (!element) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setEntry(entry);\n        internalCallbackRef.current?.(entry);\n      },\n      {\n        ...options,\n        root: options?.root ? (getElement(options.root) as Document | Element) : document\n      }\n    );\n\n    observer.observe(element as Element);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [target, internalRef.state, options?.rootMargin, options?.threshold, options?.root, enabled]);\n\n  if (target) return { entry, inView: !!entry?.isIntersecting };\n  return {\n    ref: internalRef,\n    entry,\n    inView: !!entry?.isIntersecting\n  };\n}) as UseIntersectionObserver;\n"],"names":["useIntersectionObserver","params","target","isTarget","options","callback","enabled","entry","setEntry","useState","internalRef","useRefState","internalCallbackRef","useRef","useEffect","element","getElement","observer"],"mappings":";;;;;;;;;;;AAoFO,MAAMA,IAA2B,CAAA,GAAIC,MAAkB;IAC5D,MAAMC,gNAAUC,EAASF,CAAAA,CAAO,CAAC,CAAC,IAAIA,CAAAA,CAAO,CAAC,CAAA,GAAI,KAAA,GAE5CG,IACJF,IACI,OAAOD,CAAAA,CAAO,CAAC,CAAA,IAAM,WACnBA,CAAAA,CAAO,CAAC,CAAA,GACR;QAAE,UAAUA,CAAAA,CAAO,CAAC,CAAA;IAAA,IACtB,OAAOA,CAAAA,CAAO,CAAC,CAAA,IAAM,WACnBA,CAAAA,CAAO,CAAC,CAAA,GACR;QAAE,UAAUA,CAAAA,CAAO,CAAC,CAAA;IAAA,GAGtBI,IAAWD,GAAS,UACpBE,IAAUF,GAAS,WAAW,CAAA,GAE9B,CAACG,GAAOC,CAAQ,CAAA,wNAAIC,CAAA,IAEpBC,0NAAcC,CAAA,IACdC,IAAsBC,mNAAAA,EAAOR,CAAQ;IA2B3C,OA1BAO,EAAoB,OAAA,GAAUP,yNAE9BS,EAAU,MAAM;QACd,IAAI,CAACR,KAAY,CAACJ,KAAU,CAACQ,EAAY,KAAA,CAAQ,CAAA;QAEjD,MAAMK,IAAUb,oNAASc,EAAWd,CAAM,IAAIQ,EAAY,OAAA;QAC1D,IAAI,CAACK,EAAS,CAAA;QAEd,MAAME,IAAW,IAAI,qBACnB,CAAC,CAACV,CAAK,CAAA,KAAM;YACXC,EAASD,CAAK,GACdK,EAAoB,OAAA,GAAUL,CAAK;QAAA,GAErC;YACE,GAAGH,CAAAA;YACH,MAAMA,GAAS,uNAAQY,EAAWZ,EAAQ,IAAI,IAA2B;QAAA;QAI7E,OAAAa,EAAS,OAAA,CAAQF,CAAkB,GAE5B,MAAM;YACXE,EAAS,UAAA,CAAA;QAAW;IACtB,GACC;QAACf;QAAQQ,EAAY,KAAA;QAAON,GAAS;QAAYA,GAAS;QAAWA,GAAS;QAAME,CAAO;KAAC,GAE3FJ,IAAe;QAAE,OAAAK;QAAO,QAAQ,CAAC,CAACA,GAAO;IAAA,IACtC;QACL,KAAKG;QACL,OAAAH;QACA,QAAQ,CAAC,CAACA,GAAO;IAAA;AAErB","debugId":null}},
    {"offset": {"line": 114, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@siberiacancode/reactuse/dist/esm/hooks/useIsomorphicLayoutEffect/useIsomorphicLayoutEffect.mjs","sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40siberiacancode/reactuse/src/hooks/useIsomorphicLayoutEffect/useIsomorphicLayoutEffect.ts"],"sourcesContent":["import { useEffect, useLayoutEffect } from 'react';\n\n/**\n * @name useIsomorphicLayoutEffect\n * @description - Hook conditionally selects either `useLayoutEffect` or `useEffect` based on the environment\n * @category Lifecycle\n *\n * @example\n * useIsomorphicLayoutEffect(() => console.log('effect'), [])\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n"],"names":["useIsomorphicLayoutEffect","useLayoutEffect","useEffect"],"mappings":";;;;;AAUO,MAAMA,IACX,OAAO,OAAW,4MAAcC,kBAAAA,yMAAkBC,YAAAA","debugId":null}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@siberiacancode/reactuse/dist/esm/hooks/useDidUpdate/useDidUpdate.mjs","sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40siberiacancode/reactuse/src/hooks/useDidUpdate/useDidUpdate.ts"],"sourcesContent":["import type { DependencyList, EffectCallback } from 'react';\n\nimport { useRef } from 'react';\n\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect/useIsomorphicLayoutEffect';\n\n/**\n * @name useDidUpdate\n * @description â€“ Hook that triggers the effect callback on updates\n * @category Lifecycle\n *\n * @param {EffectCallback} effect The effect callback\n * @param {DependencyList} [deps] The dependencies list for the effect\n *\n * @example\n * useDidUpdate(() => console.log(\"effect runs on updates\"), deps);\n */\nexport const useDidUpdate = (effect: EffectCallback, deps?: DependencyList) => {\n  const mounted = useRef(false);\n\n  useIsomorphicLayoutEffect(\n    () => () => {\n      mounted.current = false;\n    },\n    []\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (mounted.current) {\n      return effect();\n    }\n\n    mounted.current = true;\n    return undefined;\n  }, deps);\n};\n"],"names":["useDidUpdate","effect","deps","mounted","useRef","useIsomorphicLayoutEffect"],"mappings":";;;;;;;AAiBO,MAAMA,IAAe,CAACC,GAAwBC,MAA0B;IAC7E,MAAMC,uNAAUC,EAAO,CAAA,CAAK;oQAE5BC,EACE,IAAM,MAAM;YACVF,EAAQ,OAAA,GAAU,CAAA;QAAA,GAEpB,CAAA,CAAA,mQAGFE,EAA0B,MAAM;QAC9B,IAAIF,EAAQ,OAAA,EACV,OAAOF,EAAA;QAGTE,EAAQ,OAAA,GAAU,CAAA;IACX,GACND,CAAI;AACT","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@siberiacancode/reactuse/dist/esm/hooks/useMount/useMount.mjs","sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40siberiacancode/reactuse/src/hooks/useMount/useMount.ts"],"sourcesContent":["import type { EffectCallback } from 'react';\n\nimport { useEffect } from 'react';\n\n/**\n * @name useMount\n * @description - Hook that executes a callback when the component mounts\n * @category Lifecycle\n *\n * @param {EffectCallback} effect The callback to execute\n *\n * @example\n * useMount(() => console.log('This effect runs on the initial render'));\n */\nexport const useMount = (effect: EffectCallback) => useEffect(effect, []);\n"],"names":["useMount","effect","useEffect"],"mappings":";;;;;AAcO,MAAMA,IAAW,CAACC,0NAA2BC,EAAUD,GAAQ,CAAA,CAAE","debugId":null}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@siberiacancode/reactuse/dist/esm/utils/helpers/getRetry.mjs","sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40siberiacancode/reactuse/src/utils/helpers/getRetry.ts"],"sourcesContent":["export const getRetry = (retry: boolean | number) => {\n  if (typeof retry === 'number') return retry;\n  return retry ? 1 : 0;\n};\n"],"names":["getRetry","retry"],"mappings":";;;AAAO,MAAMA,IAAW,CAACC,IACnB,OAAOA,KAAU,WAAiBA,IAC/BA,IAAQ,IAAI","debugId":null}},
    {"offset": {"line": 170, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@siberiacancode/reactuse/dist/esm/hooks/useQuery/useQuery.mjs","sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40siberiacancode/reactuse/src/hooks/useQuery/useQuery.ts"],"sourcesContent":["import type { DependencyList } from 'react';\n\nimport { useEffect, useRef, useState } from 'react';\n\nimport { getRetry } from '@/utils/helpers';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\nimport { useMount } from '../useMount/useMount';\n\n/* The use query return type */\nexport interface UseQueryOptions<QueryData, Data> {\n  /* The enabled state of the query */\n  enabled?: boolean;\n  /* The depends for the hook */\n  keys?: DependencyList;\n  /* The placeholder data for the hook */\n  placeholderData?: (() => Data) | Data;\n  /* The refetch interval */\n  refetchInterval?: number;\n  /* The retry count of requests */\n  retry?: boolean | number;\n  /* The retry delay of requests */\n  retryDelay?: ((retry: number, error: Error) => number) | number;\n  /* The callback function to be invoked on error */\n  onError?: (error: Error) => void;\n  /* The callback function to be invoked on success */\n  onSuccess?: (data: Data) => void;\n  /* The select function to be invoked */\n  select?: (data: QueryData) => Data;\n}\n\ninterface UseQueryCallbackParams {\n  /* The depends for the hook */\n  keys: DependencyList;\n  /* The abort signal */\n  signal: AbortSignal;\n}\n\n/* The use query return type */\nexport interface UseQueryReturn<Data> {\n  /* The abort function */\n  abort: AbortController['abort'];\n  /* The state of the query */\n  data?: Data;\n  /* The success state of the query */\n  error?: Error;\n  /* The error state of the query */\n  isError: boolean;\n  /* The fetching state of the query */\n  isFetching: boolean;\n  /* The loading state of the query */\n  isLoading: boolean;\n  /* The refetching state of the query */\n  isRefetching: boolean;\n  /* The success state of the query */\n  isSuccess: boolean;\n  /* The refetch function */\n  refetch: () => void;\n}\n\n/**\n * @name useQuery\n * @description - Hook that defines the logic when query data\n * @category Async\n *\n * @template Data The type of the data\n * @param {() => Promise<Data>} callback The callback function to be invoked\n * @param {DependencyList} [options.keys] The dependencies for the hook\n * @param {(data: Data) => void} [options.onSuccess] The callback function to be invoked on success\n * @param {(error: Error) => void} [options.onError] The callback function to be invoked on error\n * @param {UseQueryOptionsSelect<Data>} [options.select] The select function to be invoked\n * @param {Data | (() => Data)} [options.initialData] The initial data for the hook\n * @param {Data | (() => Data)} [options.placeholderData] The placeholder data for the hook\n * @param {number} [options.refetchInterval] The refetch interval\n * @param {boolean | number} [options.retry] The retry count of requests\n * @returns {UseQueryReturn<Data>} An object with the state of the query\n *\n * @example\n * const { data, isFetching, isLoading, isError, isSuccess, error, refetch, isRefetching, abort, aborted } = useQuery(() => fetch('url'));\n */\nexport const useQuery = <QueryData, Data = QueryData>(\n  callback: (params: UseQueryCallbackParams) => Promise<QueryData>,\n  options?: UseQueryOptions<QueryData, Data>\n): UseQueryReturn<Data> => {\n  const enabled = options?.enabled ?? true;\n  const retryCountRef = useRef(options?.retry ? getRetry(options.retry) : 0);\n  const alreadyRequested = useRef(false);\n\n  const [isFetching, setIsFetching] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isError, setIsError] = useState(false);\n  const [isRefetching, setIsRefetching] = useState(false);\n  const [isSuccess, setIsSuccess] = useState(!!options?.placeholderData);\n\n  const [error, setError] = useState<Error | undefined>(undefined);\n  const [data, setData] = useState<Data | undefined>(options?.placeholderData);\n\n  const abortControllerRef = useRef<AbortController>(new AbortController());\n  const intervalIdRef = useRef<ReturnType<typeof setInterval>>(undefined);\n\n  const keys = options?.keys ?? [];\n\n  const abort = () => {\n    abortControllerRef.current.abort();\n    abortControllerRef.current = new AbortController();\n  };\n\n  const request = (action: 'init' | 'refetch') => {\n    abort();\n\n    setIsFetching(true);\n    if (action === 'init') {\n      alreadyRequested.current = true;\n      setIsLoading(true);\n    }\n    if (action === 'refetch') setIsRefetching(true);\n    callback({ signal: abortControllerRef.current.signal, keys })\n      .then((response) => {\n        const data = options?.select ? options?.select(response) : response;\n        options?.onSuccess?.(data as Data);\n        setData(data as Data);\n        setIsSuccess(true);\n        setError(undefined);\n        setIsError(false);\n        setIsFetching(false);\n        if (action === 'init') setIsLoading(false);\n        if (action === 'refetch') setIsRefetching(false);\n      })\n      .catch((error: Error) => {\n        if (retryCountRef.current > 0) {\n          retryCountRef.current -= 1;\n          const retryDelay =\n            typeof options?.retryDelay === 'function'\n              ? options?.retryDelay(retryCountRef.current, error)\n              : options?.retryDelay;\n\n          if (retryDelay) {\n            setTimeout(() => request(action), retryDelay);\n            return;\n          }\n\n          return request(action);\n        }\n        options?.onError?.(error);\n        setData(undefined);\n        setIsSuccess(false);\n        setError(error);\n        setIsError(true);\n        setIsFetching(false);\n        if (action === 'init') setIsLoading(false);\n        if (action === 'refetch') setIsRefetching(false);\n        retryCountRef.current = options?.retry ? getRetry(options.retry) : 0;\n      })\n      .finally(() => {\n        if (options?.refetchInterval) {\n          const interval = setInterval(() => {\n            clearInterval(interval);\n            request('refetch');\n          }, options?.refetchInterval);\n          intervalIdRef.current = interval;\n        }\n      });\n  };\n\n  useMount(() => {\n    if (!enabled) return;\n    request('init');\n  });\n\n  useDidUpdate(() => {\n    if (!enabled) return;\n    request(alreadyRequested.current ? 'refetch' : 'init');\n  }, [enabled, ...keys]);\n\n  useEffect(() => {\n    return () => {\n      clearInterval(intervalIdRef.current);\n    };\n  }, [enabled, options?.refetchInterval, options?.retry, ...keys]);\n\n  const refetch = () => request('refetch');\n\n  return {\n    abort,\n    data,\n    error,\n    refetch,\n    isFetching,\n    isLoading,\n    isError,\n    isSuccess,\n    isRefetching\n  };\n};\n"],"names":["useQuery","callback","options","enabled","retryCountRef","useRef","getRetry","alreadyRequested","isFetching","setIsFetching","useState","isLoading","setIsLoading","isError","setIsError","isRefetching","setIsRefetching","isSuccess","setIsSuccess","error","setError","data","setData","abortControllerRef","intervalIdRef","keys","abort","request","action","response","retryDelay","interval","useMount","useDidUpdate","useEffect"],"mappings":"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","debugId":null}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40swc/helpers/cjs/_interop_require_wildcard.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) return obj;\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") return { default: obj };\n\n    var cache = _getRequireWildcardCache(nodeInterop);\n\n    if (cache && cache.has(obj)) return cache.get(obj);\n\n    var newObj = { __proto__: null };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);\n            else newObj[key] = obj[key];\n        }\n    }\n\n    newObj.default = obj;\n\n    if (cache) cache.set(obj, newObj);\n\n    return newObj;\n}\nexports._ = _interop_require_wildcard;\n"],"names":[],"mappings":"AAEA,SAAS,yBAAyB,WAAW;IACzC,IAAI,OAAO,YAAY,YAAY,OAAO;IAE1C,IAAI,oBAAoB,IAAI;IAC5B,IAAI,mBAAmB,IAAI;IAE3B,OAAO,CAAC,2BAA2B,SAAS,WAAW;QACnD,OAAO,cAAc,mBAAmB;IAC5C,CAAC,EAAE;AACP;AACA,SAAS,0BAA0B,GAAG,EAAE,WAAW;IAC/C,IAAI,CAAC,eAAe,OAAO,IAAI,UAAU,EAAE,OAAO;IAClD,IAAI,QAAQ,QAAQ,OAAO,QAAQ,YAAY,OAAO,QAAQ,YAAY,OAAO;QAAE,SAAS;IAAI;IAEhG,IAAI,QAAQ,yBAAyB;IAErC,IAAI,SAAS,MAAM,GAAG,CAAC,MAAM,OAAO,MAAM,GAAG,CAAC;IAE9C,IAAI,SAAS;QAAE,WAAW;IAAK;IAC/B,IAAI,wBAAwB,OAAO,cAAc,IAAI,OAAO,wBAAwB;IAEpF,IAAK,IAAI,OAAO,IAAK;QACjB,IAAI,QAAQ,aAAa,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,MAAM;YACrE,IAAI,OAAO,wBAAwB,OAAO,wBAAwB,CAAC,KAAK,OAAO;YAC/E,IAAI,QAAQ,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,GAAG,OAAO,cAAc,CAAC,QAAQ,KAAK;iBAClE,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI;QAC/B;IACJ;IAEA,OAAO,OAAO,GAAG;IAEjB,IAAI,OAAO,MAAM,GAAG,CAAC,KAAK;IAE1B,OAAO;AACX;AACA,QAAQ,CAAC,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 282, "column": 0}, "map": {"version":3,"sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40swc/helpers/cjs/_class_private_field_loose_base.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _class_private_field_loose_base(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n        throw new TypeError(\"attempted to use private field on non-instance\");\n    }\n\n    return receiver;\n}\nexports._ = _class_private_field_loose_base;\n"],"names":[],"mappings":"AAEA,SAAS,gCAAgC,QAAQ,EAAE,UAAU;IACzD,IAAI,CAAC,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,aAAa;QAC7D,MAAM,IAAI,UAAU;IACxB;IAEA,OAAO;AACX;AACA,QAAQ,CAAC,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40swc/helpers/cjs/_class_private_field_loose_key.cjs"],"sourcesContent":["\"use strict\";\n\nvar id = 0;\n\nfunction _class_private_field_loose_key(name) {\n    return \"__private_\" + id++ + \"_\" + name;\n}\nexports._ = _class_private_field_loose_key;\n"],"names":[],"mappings":"AAEA,IAAI,KAAK;AAET,SAAS,+BAA+B,IAAI;IACxC,OAAO,eAAe,OAAO,MAAM;AACvC;AACA,QAAQ,CAAC,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"sources":["file:///Users/macbookpro/Documents/inforun-new/infoRUN/Client/node_modules/%40swc/helpers/cjs/_interop_require_default.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\nexports._ = _interop_require_default;\n"],"names":[],"mappings":"AAEA,SAAS,yBAAyB,GAAG;IACjC,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AACxD;AACA,QAAQ,CAAC,GAAG","ignoreList":[0],"debugId":null}}]
}