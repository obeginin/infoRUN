{
  "version": 3,
  "sources": ["../../@siberiacancode/reactuse/src/helpers/createContext/createContext.tsx", "../../@siberiacancode/reactuse/src/helpers/createEventEmitter/createEventEmitter.ts", "../../@siberiacancode/reactuse/src/hooks/useIsomorphicLayoutEffect/useIsomorphicLayoutEffect.ts", "../../@siberiacancode/reactuse/src/hooks/useEvent/useEvent.ts", "../../@siberiacancode/reactuse/src/helpers/createReactiveContext/createReactiveContext.ts", "../../@siberiacancode/reactuse/src/helpers/createStore/createStore.ts", "../../@siberiacancode/reactuse/src/hooks/useAsync/useAsync.ts", "../../@siberiacancode/reactuse/src/hooks/useLockCallback/useLockCallback.ts", "../../@siberiacancode/reactuse/src/hooks/useMutation/useMutation.ts", "../../@siberiacancode/reactuse/src/hooks/useDidUpdate/useDidUpdate.ts", "../../@siberiacancode/reactuse/src/hooks/useOptimistic/useOptimistic.ts", "../../@siberiacancode/reactuse/src/hooks/useMount/useMount.ts", "../../@siberiacancode/reactuse/src/utils/helpers/getRetry.ts", "../../@siberiacancode/reactuse/src/hooks/useQuery/useQuery.ts", "../../@siberiacancode/reactuse/src/hooks/useAudio/useAudio.ts", "../../@siberiacancode/reactuse/src/hooks/useBattery/useBattery.ts", "../../@siberiacancode/reactuse/src/hooks/useBluetooth/useBluetooth.ts", "../../@siberiacancode/reactuse/src/hooks/useBroadcastChannel/useBroadcastChannel.ts", "../../@siberiacancode/reactuse/src/utils/helpers/copy.ts", "../../@siberiacancode/reactuse/src/hooks/useClipboard/useClipboard.ts", "../../@siberiacancode/reactuse/src/hooks/useCopy/useCopy.ts", "../../@siberiacancode/reactuse/src/hooks/useRefState/useRefState.ts", "../../@siberiacancode/reactuse/src/utils/helpers/getElement.ts", "../../@siberiacancode/reactuse/src/utils/helpers/isTarget.ts", "../../@siberiacancode/reactuse/src/hooks/useCssVar/useCssVar.ts", "../../@siberiacancode/reactuse/src/hooks/useDisplayMedia/useDisplayMedia.ts", "../../@siberiacancode/reactuse/src/hooks/useDocumentTitle/useDocumentTitle.ts", "../../@siberiacancode/reactuse/src/hooks/useEventSource/useEventSource.ts", "../../@siberiacancode/reactuse/src/hooks/useEyeDropper/useEyeDropper.ts", "../../@siberiacancode/reactuse/src/hooks/useFavicon/useFavicon.ts", "../../@siberiacancode/reactuse/src/hooks/useFps/useFps.ts", "../../screenfull/index.js", "../../@siberiacancode/reactuse/src/hooks/useFullscreen/useFullscreen.ts", "../../@siberiacancode/reactuse/src/hooks/useRaf/useRaf.ts", "../../@siberiacancode/reactuse/src/hooks/useGamepad/useGamepad.ts", "../../@siberiacancode/reactuse/src/hooks/useGeolocation/useGeolocation.ts", "../../@siberiacancode/reactuse/src/hooks/useMediaControls/useMediaControls.ts", "../../@siberiacancode/reactuse/src/hooks/useMemory/useMemory.ts", "../../@siberiacancode/reactuse/src/hooks/useNetwork/useNetwork.ts", "../../@siberiacancode/reactuse/src/hooks/useOnline/useOnline.ts", "../../@siberiacancode/reactuse/src/hooks/useOtpCredential/useOtpCredential.ts", "../../@siberiacancode/reactuse/src/hooks/usePermission/usePermission.ts", "../../@siberiacancode/reactuse/src/hooks/usePictureInPicture/usePictureInPicture.ts", "../../@siberiacancode/reactuse/src/hooks/usePointerLock/usePointerLock.ts", "../../@siberiacancode/reactuse/src/hooks/usePostMessage/usePostMessage.ts", "../../@siberiacancode/reactuse/src/hooks/useShare/useShare.ts", "../../@siberiacancode/reactuse/src/hooks/useSpeechRecognition/useSpeechRecognition.ts", "../../@siberiacancode/reactuse/src/hooks/useSpeechSynthesis/useSpeechSynthesis.ts", "../../@siberiacancode/reactuse/src/hooks/useVibrate/useVibrate.ts", "../../@siberiacancode/reactuse/src/hooks/useWakeLock/useWakeLock.ts", "../../@siberiacancode/reactuse/src/hooks/useWebSocket/useWebSocket.ts", "../../@siberiacancode/reactuse/src/hooks/useLogger/useLogger.ts", "../../@siberiacancode/reactuse/src/hooks/useRenderCount/useRenderCount.ts", "../../@siberiacancode/reactuse/src/hooks/useRenderInfo/useRenderInfo.ts", "../../@siberiacancode/reactuse/src/hooks/useRerender/useRerender.ts", "../../@siberiacancode/reactuse/src/hooks/useActiveElement/useActiveElement.ts", "../../@siberiacancode/reactuse/src/hooks/useAutoScroll/useAutoScroll.ts", "../../@siberiacancode/reactuse/src/hooks/useClickOutside/useClickOutside.ts", "../../@siberiacancode/reactuse/src/hooks/useDoubleClick/useDoubleClick.ts", "../../@siberiacancode/reactuse/src/hooks/useDropZone/useDropZone.ts", "../../@siberiacancode/reactuse/src/hooks/useFileDialog/useFileDialog.ts", "../../@siberiacancode/reactuse/src/hooks/useFocus/useFocus.ts", "../../@siberiacancode/reactuse/src/hooks/useHover/useHover.ts", "../../@siberiacancode/reactuse/src/hooks/useImage/useImage.ts", "../../@siberiacancode/reactuse/src/hooks/useLongPress/useLongPress.ts", "../../@siberiacancode/reactuse/src/hooks/usePaint/usePaint.ts", "../../@siberiacancode/reactuse/src/hooks/useScript/useScript.ts", "../../@siberiacancode/reactuse/src/hooks/useSticky/useSticky.ts", "../../@siberiacancode/reactuse/src/hooks/useTextDirection/useTextDirection.ts", "../../@siberiacancode/reactuse/src/hooks/useFul/useFul.ts", "../../@siberiacancode/reactuse/src/hooks/useLess/useLess.ts", "../../@siberiacancode/reactuse/src/hooks/useOnce/useOnce.ts", "../../@siberiacancode/reactuse/src/hooks/useIsFirstRender/useIsFirstRender.ts", "../../@siberiacancode/reactuse/src/hooks/useShallowEffect/useShallowEffect.ts", "../../@siberiacancode/reactuse/src/hooks/useUnmount/useUnmount.ts", "../../@siberiacancode/reactuse/src/hooks/useBreakpoints/useBreakpoints.ts", "../../@siberiacancode/reactuse/src/utils/helpers/throttle.ts", "../../@siberiacancode/reactuse/src/hooks/useDeviceMotion/useDeviceMotion.ts", "../../@siberiacancode/reactuse/src/hooks/useDeviceOrientation/useDeviceOrientation.ts", "../../@siberiacancode/reactuse/src/hooks/useDevicePixelRatio/useDevicePixelRatio.ts", "../../@siberiacancode/reactuse/src/hooks/useEventListener/useEventListener.ts", "../../@siberiacancode/reactuse/src/hooks/useDocumentEvent/useDocumentEvent.ts", "../../@siberiacancode/reactuse/src/hooks/useDocumentVisibility/useDocumentVisibility.ts", "../../@siberiacancode/reactuse/src/hooks/useElementSize/useElementSize.ts", "../../@siberiacancode/reactuse/src/hooks/useHotkeys/useHotkeys.ts", "../../@siberiacancode/reactuse/src/hooks/useIdle/useIdle.ts", "../../@siberiacancode/reactuse/src/hooks/useInfiniteScroll/useInfiniteScroll.ts", "../../@siberiacancode/reactuse/src/hooks/useIntersectionObserver/useIntersectionObserver.ts", "../../@siberiacancode/reactuse/src/hooks/useKeyboard/useKeyboard.ts", "../../@siberiacancode/reactuse/src/hooks/useKeyPress/useKeyPress.ts", "../../@siberiacancode/reactuse/src/hooks/useKeyPressEvent/useKeyPressEvent.ts", "../../@siberiacancode/reactuse/src/hooks/useKeysPressed/useKeysPressed.ts", "../../@siberiacancode/reactuse/src/hooks/useLockScroll/useLockScroll.ts", "../../@siberiacancode/reactuse/src/hooks/useMeasure/useMeasure.ts", "../../@siberiacancode/reactuse/src/hooks/useMediaQuery/useMediaQuery.ts", "../../@siberiacancode/reactuse/src/hooks/useMouse/useMouse.ts", "../../@siberiacancode/reactuse/src/hooks/useMutationObserver/useMutationObserver.ts", "../../@siberiacancode/reactuse/src/hooks/useOrientation/useOrientation.ts", "../../@siberiacancode/reactuse/src/hooks/usePageLeave/usePageLeave.ts", "../../@siberiacancode/reactuse/src/hooks/useParallax/useParallax.ts", "../../@siberiacancode/reactuse/src/hooks/usePerformanceObserver/usePerformanceObserver.ts", "../../@siberiacancode/reactuse/src/hooks/useResizeObserver/useResizeObserver.ts", "../../@siberiacancode/reactuse/src/hooks/useScroll/useScroll.ts", "../../@siberiacancode/reactuse/src/hooks/useScrollIntoView/useScrollIntoView.ts", "../../@siberiacancode/reactuse/src/hooks/useScrollTo/useScrollTo.ts", "../../@siberiacancode/reactuse/src/hooks/useTextSelection/useTextSelection.ts", "../../@siberiacancode/reactuse/src/hooks/useWindowEvent/useWindowEvent.ts", "../../@siberiacancode/reactuse/src/hooks/useWindowFocus/useWindowFocus.ts", "../../@siberiacancode/reactuse/src/hooks/useWindowScroll/useWindowScroll.ts", "../../@siberiacancode/reactuse/src/hooks/useWindowSize/useWindowSize.ts", "../../@siberiacancode/reactuse/src/hooks/useBoolean/useBoolean.ts", "../../@siberiacancode/reactuse/src/hooks/useCookie/useCookie.ts", "../../@siberiacancode/reactuse/src/hooks/useCookies/useCookies.ts", "../../@siberiacancode/reactuse/src/hooks/useCounter/useCounter.ts", "../../@siberiacancode/reactuse/src/hooks/useDefault/useDefault.ts", "../../@siberiacancode/reactuse/src/hooks/useDisclosure/useDisclosure.ts", "../../@siberiacancode/reactuse/src/hooks/useField/useField.ts", "../../@siberiacancode/reactuse/src/hooks/useHash/useHash.ts", "../../@siberiacancode/reactuse/src/hooks/useList/useList.ts", "../../@siberiacancode/reactuse/src/hooks/useStorage/useStorage.ts", "../../@siberiacancode/reactuse/src/hooks/useLocalStorage/useLocalStorage.ts", "../../@siberiacancode/reactuse/src/hooks/useMap/useMap.ts", "../../@siberiacancode/reactuse/src/hooks/useOffsetPagination/useOffsetPagination.ts", "../../@siberiacancode/reactuse/src/hooks/useQueue/useQueue.ts", "../../@siberiacancode/reactuse/src/hooks/useRafState/useRafState.ts", "../../@siberiacancode/reactuse/src/hooks/useSessionStorage/useSessionStorage.ts", "../../@siberiacancode/reactuse/src/hooks/useSet/useSet.ts", "../../@siberiacancode/reactuse/src/hooks/useStateHistory/useStateHistory.ts", "../../@siberiacancode/reactuse/src/hooks/useStep/useStep.ts", "../../@siberiacancode/reactuse/src/hooks/useToggle/useToggle.ts", "../../@siberiacancode/reactuse/src/hooks/useUrlSearchParam/useUrlSearchParam.ts", "../../@siberiacancode/reactuse/src/hooks/useUrlSearchParams/useUrlSearchParams.ts", "../../@siberiacancode/reactuse/src/hooks/useWizard/useWizard.ts", "../../@siberiacancode/reactuse/src/hooks/useInterval/useInterval.ts", "../../@siberiacancode/reactuse/src/hooks/useStopwatch/useStopwatch.ts", "../../@siberiacancode/reactuse/src/utils/helpers/getDate.ts", "../../@siberiacancode/reactuse/src/hooks/useTime/useTime.ts", "../../@siberiacancode/reactuse/src/hooks/useTimeout/useTimeout.ts", "../../@siberiacancode/reactuse/src/hooks/useTimer/useTimer.ts", "../../@siberiacancode/reactuse/src/hooks/useBrowserLanguage/useBrowserLanguage.ts", "../../@siberiacancode/reactuse/src/hooks/useOperatingSystem/useOperatingSystem.ts", "../../@siberiacancode/reactuse/src/hooks/usePreferredColorScheme/usePreferredColorScheme.ts", "../../@siberiacancode/reactuse/src/hooks/usePreferredContrast/usePreferredContrast.ts", "../../@siberiacancode/reactuse/src/hooks/usePreferredDark/usePreferredDark.ts", "../../@siberiacancode/reactuse/src/hooks/usePreferredLanguages/usePreferredLanguages.ts", "../../@siberiacancode/reactuse/src/hooks/usePreferredReducedMotion/usePreferredReducedMotion.ts", "../../@siberiacancode/reactuse/src/hooks/useConst/useConst.ts", "../../@siberiacancode/reactuse/src/hooks/useDebounceCallback/useDebounceCallback.ts", "../../@siberiacancode/reactuse/src/hooks/useDebounceValue/useDebounceValue.ts", "../../@siberiacancode/reactuse/src/hooks/useLastChanged/useLastChanged.ts", "../../@siberiacancode/reactuse/src/hooks/useLatest/useLatest.ts", "../../@siberiacancode/reactuse/src/hooks/usePrevious/usePrevious.ts", "../../@siberiacancode/reactuse/src/hooks/useThrottleCallback/useThrottleCallback.ts", "../../@siberiacancode/reactuse/src/hooks/useThrottleValue/useThrottleValue.ts", "../../@siberiacancode/reactuse/src/utils/helpers/debounce.ts"],
  "sourcesContent": ["import type { JSX, ReactNode } from 'react';\n\nimport { createContext as createReactContext, useContext, useMemo, useState } from 'react';\n\n/** The create context options type */\nexport interface CreateContextOptions {\n  /** Display name for the context (useful for debugging) */\n  name?: string;\n  /** Whether to throw an error if context is used outside of Provider */\n  strict?: boolean;\n}\n\n/** The context value type */\nexport interface ContextValue<Value> {\n  /** The context value */\n  value: Value | undefined;\n  /** The context set function */\n  set: (value: Value) => void;\n}\n\n/** The provider props type */\nexport interface ProviderProps<Value> {\n  /** The children */\n  children?: ReactNode;\n  /** The initial value */\n  initialValue?: Value;\n}\n\n/** The create context return type */\nexport interface CreateContextReturn<Value> {\n  /** The context instance */\n  instance: React.Context<ContextValue<Value>>;\n  /** The provider component */\n  Provider: (props: ProviderProps<Value>) => JSX.Element;\n  /** The selector hook */\n  useSelect: {\n    <Selected>(selector: (value: Value) => Selected): Selected;\n    (): ContextValue<Value>;\n  };\n}\n\n/**\n * @name createContext\n * @description - Creates a typed context with additional utilities\n * @category Helpers\n *\n * @template Value - The type of value that will be stored in the context\n * @param {Value | undefined} [defaultValue] - Default value for the context\n * @param {CreateContextOptions<Value>} [options] - Additional options for context creation\n * @returns {CreateContextReturn<Value>} Object containing context utilities and components\n *\n * @example\n * const { useSelect, instance, Provider } = createContext<number>(0);\n */\nexport const createContext = <Value,>(\n  defaultValue: Value | undefined = undefined,\n  options: CreateContextOptions = {}\n): CreateContextReturn<Value> => {\n  const Context = createReactContext<{\n    value: Value | undefined;\n    set: (value: Value) => void;\n  }>({\n    value: defaultValue,\n    set: () => {}\n  });\n\n  Context.displayName = options.name;\n\n  function useSelect(): ContextValue<Value>;\n  function useSelect<Selected>(selector: (value: Value) => Selected): Selected;\n  function useSelect<Selected>(selector?: (value: Value) => Selected) {\n    const context = useContext(Context);\n\n    if (!context && options.strict) {\n      throw new Error(`Context hook ${options.name} must be used inside a Provider`);\n    }\n\n    if (!selector) {\n      return context;\n    }\n\n    return selector(context.value as Value);\n  }\n\n  const Provider = ({ children, initialValue }: ProviderProps<Value>) => {\n    const [profile, setProfile] = useState<Value | undefined>(initialValue ?? defaultValue);\n\n    const value = useMemo(\n      () => ({\n        value: profile,\n        set: setProfile\n      }),\n      [profile]\n    );\n\n    return <Context value={value}>{children}</Context>;\n  };\n\n  return {\n    useSelect,\n    instance: Context,\n    Provider\n  } as const;\n};\n", "import { useEffect, useRef, useState } from 'react';\n\n/**\n * @name createEventEmitter\n * @description - Creates a type-safe event emitter\n * @category Helpers\n *\n * @template Events - The type of events and their data\n * @returns {EventEmitterApi<Events>} - Object containing event emitter methods and hook\n *\n * @example\n * const { push, subscribe, unsubscribe, useSubscribe } = createEventEmitter<{ foo: number }>();\n */\nexport const createEventEmitter = <Events extends Record<string, any> = Record<string, any>>() => {\n  type ListenerMap = Map<string, Set<(data: any) => void>>;\n  const listeners: ListenerMap = new Map();\n\n  const push = <Event extends keyof Events>(event: Event, data: Events[Event]) => {\n    const eventListeners = listeners.get(event as string);\n    eventListeners?.forEach((listener) => listener(data));\n  };\n\n  const unsubscribe = <Key extends keyof Events>(\n    event: Key,\n    listener: (data: Events[Key]) => void\n  ) => {\n    const eventKey = event as string;\n    const eventListeners = listeners.get(eventKey);\n    if (!eventListeners) return;\n    eventListeners.delete(listener);\n    if (!eventListeners.size) listeners.delete(eventKey);\n  };\n\n  const subscribe = <Key extends keyof Events>(\n    event: Key,\n    listener: (data: Events[Key]) => void\n  ) => {\n    const eventKey = event as string;\n    if (!listeners.has(eventKey)) listeners.set(eventKey, new Set());\n    const eventListeners = listeners.get(event as string)!;\n    eventListeners.add(listener);\n\n    return () => {\n      unsubscribe(event, listener);\n    };\n  };\n\n  const useSubscribe = <Event extends keyof Events>(\n    event: Event,\n    listener?: (data: Events[Event]) => void\n  ) => {\n    const [data, setData] = useState<Events[Event] | undefined>(undefined);\n    const listenerRef = useRef(listener);\n    listenerRef.current = listener;\n\n    useEffect(() => {\n      const onSubscribe = (data: Events[Event]) => {\n        setData(data);\n        listenerRef.current?.(data);\n      };\n\n      const unsubscribe = subscribe(event, onSubscribe);\n      return () => {\n        unsubscribe();\n      };\n    }, [event]);\n\n    return data;\n  };\n\n  return {\n    push,\n    subscribe,\n    unsubscribe,\n    useSubscribe\n  };\n};\n", "import { useEffect, useLayoutEffect } from 'react';\n\n/**\n * @name useIsomorphicLayoutEffect\n * @description - Hook conditionally selects either `useLayoutEffect` or `useEffect` based on the environment\n * @category Lifecycle\n *\n * @example\n * useIsomorphicLayoutEffect(() => console.log('effect'), [])\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n", "import { useCallback, useRef } from 'react';\n\n/**\n * @name useEvent\n * @description - Hook that creates an event and returns a stable reference of it\n * @category Utilities\n *\n * @template Params The type of the params\n * @template Return The type of the return\n * @param {(...args: Params) => Return} callback The callback function\n * @returns {(...args: Params) => Return} The callback\n *\n * @example\n * const onClick = useEvent(() => console.log('clicked'));\n */\nexport const useEvent = <Params extends unknown[], Return>(\n  callback: (...args: Params) => Return\n): ((...args: Params) => Return) => {\n  const internalCallbackRef = useRef<typeof callback>(callback);\n  internalCallbackRef.current = callback;\n\n  return useCallback((...args) => {\n    const fn = internalCallbackRef.current;\n    return fn(...args);\n  }, []);\n};\n", "import type { Context, FC, Provider, ProviderProps, RefObject } from 'react';\n\nimport {\n  createContext,\n  createElement,\n  startTransition,\n  useContext,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\n\nimport { useEvent, useIsomorphicLayoutEffect } from '@/hooks';\n\n/** The create reactive context options type */\nexport interface CreateReactiveContextOptions {\n  /** Display name for the context (useful for debugging) */\n  name?: string;\n  /** Whether to throw an error if context is used outside of Provider */\n  strict?: boolean;\n}\n\n/** The create reactive context return type */\nexport interface CreateReactiveContextReturn<Value> {\n  /** The context instance */\n  instance: Context<ReactiveContextValue<Value>>;\n  /** The Provider component for the context */\n  Provider: Provider<Value>;\n  /** A hook to select a part of the context state */\n  useSelector: <Selected>(selector?: (state: Value) => Selected) => Selected;\n}\n\ntype ContextListener<Value> = (value: Value) => void;\n\ninterface ReactiveContextValue<Value> {\n  /** The listeners for the context */\n  listeners: Set<ContextListener<Value>>;\n  /** The value for the context */\n  value: RefObject<Value>;\n}\n\nconst createProvider = <Value>(originalProvider: Provider<ReactiveContextValue<Value>>) => {\n  const Provider: FC<ProviderProps<Value>> = (props) => {\n    const valueRef = useRef(props.value);\n    const contextValue = useMemo<ReactiveContextValue<Value>>(\n      () => ({\n        value: valueRef,\n        listeners: new Set()\n      }),\n      []\n    );\n\n    useIsomorphicLayoutEffect(() => {\n      if (!Object.is(valueRef.current, props.value)) {\n        valueRef.current = props.value;\n\n        startTransition(() => {\n          contextValue.listeners.forEach((listener) => {\n            listener(valueRef.current);\n          });\n        });\n      }\n    }, [props.value]);\n\n    return createElement(originalProvider, { value: contextValue }, props.children);\n  };\n\n  return Provider as unknown as Provider<ReactiveContextValue<Value>>;\n};\n\nconst createReactiveContextSelector = <Value, Selected>(\n  Context: Context<ReactiveContextValue<Value>>,\n  selector: (state: Value) => Selected,\n  options: CreateReactiveContextOptions = {}\n) => {\n  const context = useContext(Context);\n\n  if (!context && options.strict) {\n    throw new Error(`Context hook ${options.name} must be used inside a Provider`);\n  }\n\n  const [value, setValue] = useState({\n    selected: selector(context.value.current),\n    value: context.value.current\n  });\n\n  const dispatch = useEvent((newValue: Value) => {\n    setValue((prevValue) => {\n      if (Object.is(prevValue.value, newValue)) return prevValue;\n\n      const newSelected = selector(newValue);\n      if (Object.is(prevValue.selected, newSelected)) return prevValue;\n\n      return { value: newValue, selected: newSelected };\n    });\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    context.listeners.add(dispatch);\n    return () => {\n      context.listeners.delete(dispatch);\n    };\n  }, [context.listeners]);\n\n  return value.selected;\n};\n\n/**\n * @name createReactiveContext\n * @description - Creates a typed context selector with optimized updates for state selection\n * @category Helpers\n *\n * @warning - For complex interfaces, we strongly recommend using state management solutions outside of React like createStore, reatom, effector, or zustand instead of context\n *\n * @template Value - The type of value that will be stored in the context\n * @param {Value | undefined} [defaultValue] - Default value for the context\n * @param {CreateReactiveContextOptions<Value>} [options] - Additional options for context creation\n * @returns {CreateReactiveContextReturn<Value>} Object containing context utilities and components\n *\n * @example\n * const { Provider, useSelector, instance } = createReactiveContext<number>(0);\n */\nexport const createReactiveContext = <Value extends Record<string, any>>(\n  defaultValue: Value | undefined = undefined,\n  options: CreateReactiveContextOptions = {}\n) => {\n  const Context = createContext<ReactiveContextValue<Value>>({\n    value: { current: defaultValue as Value },\n    listeners: new Set()\n  });\n\n  const Provider = createProvider(Context.Provider) as unknown as Provider<Value>;\n\n  Context.displayName = options.name;\n\n  function useSelector(): Value;\n  function useSelector<SelectedValue>(selector: (state: Value) => SelectedValue): SelectedValue;\n  function useSelector<SelectedValue>(selector?: (state: Value) => SelectedValue) {\n    return createReactiveContextSelector(\n      Context as unknown as Context<ReactiveContextValue<Value>>,\n      selector ?? ((state) => state as unknown as SelectedValue),\n      options\n    );\n  }\n\n  return { instance: Context, Provider, useSelector };\n};\n", "import { useSyncExternalStore } from 'react';\n\ntype SetStateAction<Value> = ((prev: Value) => Value) | Value;\ntype StateCreator<Value> = (\n  set: (action: SetStateAction<Value>) => void,\n  get: () => Value\n) => Value;\n\nexport interface StoreApi<Value> {\n  getInitialState: () => Value;\n  getState: () => Value;\n  setState: (action: SetStateAction<Value>) => void;\n  subscribe: (listener: (state: Value, prevState: Value) => void) => () => void;\n}\n\n/**\n * @name createStore\n * @description - Creates a store with state management capabilities\n * @category Helpers\n *\n * @template Value - The type of the store state\n * @param {StateCreator<Value>} createState - Function that initializes the store state\n * @returns {StoreApi<Value>} - Object containing store methods and hook for accessing state\n *\n * @example\n * const { set, get, use, subscribe } = createStore((set) => ({\n *   count: 0,\n *   increment: () => set(state => ({ count: state.count + 1 }))\n * }));\n */\nexport const createStore = <Value>(createState: StateCreator<Value> | Value) => {\n  type Listener = (state: Value, prevState: Value) => void;\n  let state: Value;\n  const listeners: Set<Listener> = new Set();\n\n  const setState = (action: SetStateAction<Value>) => {\n    const nextState =\n      typeof action === 'function' ? (action as (state: Value) => Value)(state) : action;\n\n    if (!Object.is(nextState, state)) {\n      const prevState = state;\n      state = nextState;\n      listeners.forEach((listener) => listener(state, prevState));\n    }\n  };\n\n  const getState = () => state;\n  const getInitialState = () => state;\n\n  const subscribe = (listener: Listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  if (typeof createState === 'function') {\n    state = (createState as StateCreator<Value>)(setState, getState);\n  } else {\n    state = createState;\n  }\n\n  const useStore = <Selected>(selector?: (state: Value) => Selected) =>\n    useSyncExternalStore(\n      subscribe,\n      () => (selector ? selector(getState()) : getState()),\n      () => (selector ? selector(getInitialState()) : getInitialState())\n    );\n\n  return {\n    set: setState,\n    get: getState,\n    use: useStore,\n    subscribe\n  };\n};\n", "import type { DependencyList } from 'react';\n\nimport { useEffect, useState } from 'react';\n\n/* The use query return type */\nexport interface UseAsyncReturn<Data> {\n  /* The state of the query */\n  data?: Data;\n  /* The error of the query */\n  error?: Error;\n  /* The error state of the query  */\n  isError: boolean;\n  /* The loading state of the query */\n  isLoading: boolean;\n}\n\n/**\n * @name useAsync\n * @description - Hook that provides the state of an async callback\n * @category Async\n *\n * @param {() => Promise<Data>} callback The async callback\n * @param {DependencyList} deps The dependencies of the callback\n * @returns {UseAsyncReturn<Data>} The state of the async callback\n *\n * @example\n * const { data, isLoading, isError, error } = useAsync(() => fetch('url'), [deps]);\n */\nexport const useAsync = <Data>(\n  callback: () => Promise<Data>,\n  deps: DependencyList\n): UseAsyncReturn<Data> => {\n  const [isLoading, setIsLoading] = useState(true);\n  const [isError, setIsError] = useState(false);\n\n  const [error, setError] = useState<Error | undefined>(undefined);\n  const [data, setData] = useState<Data | undefined>(undefined);\n\n  useEffect(() => {\n    setIsLoading(true);\n    callback()\n      .then((response) => {\n        setData(response);\n        setError(undefined);\n        setIsError(false);\n      })\n      .catch((error: Error) => {\n        setError(error);\n        setIsError(true);\n      })\n      .finally(() => {\n        setIsLoading(false);\n      });\n  }, deps);\n\n  return {\n    data,\n    isLoading,\n    isError,\n    error\n  };\n};\n", "import { useRef } from 'react';\n\n/**\n * @name useLockCallback\n * @description - Hook that prevents a callback from being executed multiple times simultaneously\n * @category Async\n *\n * @param {Function} callback The callback to be locked\n * @returns {Function} The locked callback\n *\n * @example\n * const lockedCallback = useLockCallback(() => promise());\n */\nexport const useLockCallback = <Callback extends (...args: any[]) => any>(callback: Callback) => {\n  const lockRef = useRef(false);\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  return async (...args: Parameters<Callback>) => {\n    if (lockRef.current) return;\n    lockRef.current = true;\n\n    try {\n      return await internalCallbackRef.current(...args);\n    } finally {\n      lockRef.current = false;\n    }\n  };\n};\n", "import { useState } from 'react';\n\n/* The type of the options */\ninterface UseMutationOptions<Data> {\n  /* The retry count of requests */\n  retry?: ((failureCount: number, error: Error) => boolean) | boolean | number;\n  /* The retry delay of requests */\n  retryDelay?: ((retry: number, error: Error) => number) | number;\n  /* The callback function to be invoked on error */\n  onError?: (error: Error) => void;\n  /* The callback function to be invoked on success */\n  onSuccess?: (data: Data) => void;\n}\n\n/* The use mutation return type */\ninterface UseMutationReturn<Body, Data> {\n  /* The data of the mutation */\n  data: Data | null;\n  /* The error of the mutation */\n  error: Error | null;\n  /* The error state of the mutation */\n  isError: boolean;\n  /* The loading state of the mutation */\n  isLoading: boolean;\n  /* The success state of the mutation */\n  isSuccess: boolean;\n  /* The mutate function */\n  mutate: (body?: Body, options?: UseMutationOptions<Data>) => void;\n  /* The mutate async function */\n  mutateAsync: (body?: Body, options?: UseMutationOptions<Data>) => Promise<Data>;\n}\n\nexport interface RequestOptions<Data> extends UseMutationOptions<Data> {\n  /* The attempt count */\n  attempt?: number;\n}\n\n/**\n * @name useMutation\n * @description - Hook that defines the logic when mutate data\n * @category Async\n *\n * @template Body The type of the body\n * @template Data The type of the data\n * @param {(body: Body) => Promise<Data>} callback The callback function to be invoked\n * @param {boolean | number} [options.retry] The retry count of requests\n * @param {(data: Data) => void} [options.onSuccess] The callback function to be invoked on success\n * @param {(error: Error) => void} [options.onError] The callback function to be invoked on error\n * @returns {UseMutationReturn<Data>} An object with the state of the mutation\n *\n * @example\n * const { mutate, mutateAsync, isLoading, isError, isSuccess, error, data } = useMutation((name) => Promise.resolve(name));\n */\nexport const useMutation = <Body, Data>(\n  callback: (body: Body) => Promise<Data>,\n  options?: UseMutationOptions<Data>\n) => {\n  const [isLoading, setIsLoading] = useState(false);\n  const [isError, setIsError] = useState(false);\n  const [isSuccess, setIsSuccess] = useState(false);\n\n  const [error, setError] = useState<Error | null>(null);\n  const [data, setData] = useState<Data | null>(null);\n\n  const request = (\n    body: Body,\n    requestOptions?: RequestOptions<Data>\n  ): Promise<Data | undefined> => {\n    setIsLoading(true);\n    const attempt = requestOptions?.attempt ?? 0;\n\n    return callback(body)\n      .then((response) => {\n        requestOptions?.onSuccess?.(response);\n\n        setData(response);\n        setIsSuccess(true);\n        setIsLoading(false);\n        setError(null);\n        setIsError(false);\n        return response;\n      })\n      .catch((error: Error) => {\n        const retry =\n          typeof requestOptions?.retry === 'function'\n            ? requestOptions?.retry(attempt, error)\n            : requestOptions?.retry;\n\n        const retryDelay =\n          typeof requestOptions?.retryDelay === 'function'\n            ? requestOptions?.retryDelay(attempt, error)\n            : requestOptions?.retryDelay;\n\n        if (typeof retry === 'boolean' && retry) {\n          if (retryDelay) {\n            setTimeout(\n              () => request(body, { ...requestOptions, attempt: attempt + 1 }),\n              retryDelay\n            );\n            return;\n          }\n          return request(body, { ...requestOptions, attempt: attempt + 1 });\n        }\n\n        if (retry && retry > attempt) {\n          if (retryDelay) {\n            setTimeout(\n              () => request(body, { ...requestOptions, attempt: attempt + 1 }),\n              retryDelay\n            );\n            return;\n          }\n          return request(body, { ...requestOptions, attempt: attempt + 1 });\n        }\n\n        requestOptions?.onError?.(error);\n        setData(null);\n        setIsSuccess(false);\n        setIsLoading(false);\n        setError(error);\n        setIsError(true);\n      });\n  };\n  const mutate = (body: Body, mutateOptions?: UseMutationOptions<Data>) => {\n    const requestOptions = {\n      retry: mutateOptions?.retry ?? options?.retry,\n      retryDelay: mutateOptions?.retryDelay ?? options?.retryDelay,\n      onSuccess: mutateOptions?.onSuccess ?? options?.onSuccess,\n      onError: mutateOptions?.onError ?? options?.onError\n    };\n\n    request(body, requestOptions);\n  };\n\n  const mutateAsync = async (body: Body, mutateOptions?: UseMutationOptions<Data>) => {\n    const requestOptions = {\n      retry: mutateOptions?.retry ?? options?.retry,\n      retryDelay: mutateOptions?.retryDelay ?? options?.retryDelay,\n      onSuccess: mutateOptions?.onSuccess ?? options?.onSuccess,\n      onError: mutateOptions?.onError ?? options?.onError\n    };\n\n    return request(body, requestOptions) as Promise<Data>;\n  };\n\n  return {\n    data,\n    error,\n    mutate,\n    mutateAsync,\n    isLoading,\n    isError,\n    isSuccess\n  } as UseMutationReturn<Body, Data>;\n};\n", "import type { DependencyList, EffectCallback } from 'react';\n\nimport { useRef } from 'react';\n\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect/useIsomorphicLayoutEffect';\n\n/**\n * @name useDidUpdate\n * @description â€“ Hook that triggers the effect callback on updates\n * @category Lifecycle\n *\n * @param {EffectCallback} effect The effect callback\n * @param {DependencyList} [deps] The dependencies list for the effect\n *\n * @example\n * useDidUpdate(() => console.log(\"effect runs on updates\"), deps);\n */\nexport const useDidUpdate = (effect: EffectCallback, deps?: DependencyList) => {\n  const mounted = useRef(false);\n\n  useIsomorphicLayoutEffect(\n    () => () => {\n      mounted.current = false;\n    },\n    []\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (mounted.current) {\n      return effect();\n    }\n\n    mounted.current = true;\n    return undefined;\n  }, deps);\n};\n", "import { useRef, useState } from 'react';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\n\nexport type UseOptimisticReturn<State> = [\n  State,\n  (optimisticValue: State, promise: Promise<any>) => void\n];\n\n/**\n * @name useOptimistic\n * @description - Hook that allows get optimistic value before its update\n * @category Async\n *\n * @template State The type of the state\n * @param {State} state The value to be returned initially and whenever no action is pending\n * @param {(currentState: State, optimisticValue: State) => State} update A pure function that takes the current state and the optimistic value passed to updateOptimistic and returns the resulting optimistic state\n * @returns {UseOptimisticReturn<State>} The resulting optimistic state, and the function to update it\n *\n * @example\n * const [optimisticValue, updateOptimistic] = useOptimistic<number>(count, (currentState, optimisticValue) => currentState + optimisticValue);\n */\nexport const useOptimistic = <State, OptimisticState = State>(\n  externalState: State,\n  update: (currentState: State, optimisticState: OptimisticState) => State\n) => {\n  const [state, setState] = useState<State>(externalState);\n  const internalUpdateRef = useRef(update);\n  internalUpdateRef.current = update;\n\n  const [promised, setPromised] = useState(false);\n\n  useDidUpdate(() => {\n    if (!promised) return;\n    setState(externalState);\n    setPromised(false);\n  }, [promised]);\n\n  const updateState = (optimisticValue: OptimisticState, promise: Promise<any>) => {\n    setState((currentState) => internalUpdateRef.current(currentState, optimisticValue));\n    return promise.finally(() => setPromised(true));\n  };\n\n  return [state, updateState] as const;\n};\n", "import type { EffectCallback } from 'react';\n\nimport { useEffect } from 'react';\n\n/**\n * @name useMount\n * @description - Hook that executes a callback when the component mounts\n * @category Lifecycle\n *\n * @param {EffectCallback} effect The callback to execute\n *\n * @example\n * useMount(() => console.log('This effect runs on the initial render'));\n */\nexport const useMount = (effect: EffectCallback) => useEffect(effect, []);\n", "export const getRetry = (retry: boolean | number) => {\n  if (typeof retry === 'number') return retry;\n  return retry ? 1 : 0;\n};\n", "import type { DependencyList } from 'react';\n\nimport { useEffect, useRef, useState } from 'react';\n\nimport { getRetry } from '@/utils/helpers';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\nimport { useMount } from '../useMount/useMount';\n\n/* The use query return type */\nexport interface UseQueryOptions<QueryData, Data> {\n  /* The enabled state of the query */\n  enabled?: boolean;\n  /* The depends for the hook */\n  keys?: DependencyList;\n  /* The placeholder data for the hook */\n  placeholderData?: (() => Data) | Data;\n  /* The refetch interval */\n  refetchInterval?: number;\n  /* The retry count of requests */\n  retry?: boolean | number;\n  /* The retry delay of requests */\n  retryDelay?: ((retry: number, error: Error) => number) | number;\n  /* The callback function to be invoked on error */\n  onError?: (error: Error) => void;\n  /* The callback function to be invoked on success */\n  onSuccess?: (data: Data) => void;\n  /* The select function to be invoked */\n  select?: (data: QueryData) => Data;\n}\n\ninterface UseQueryCallbackParams {\n  /* The depends for the hook */\n  keys: DependencyList;\n  /* The abort signal */\n  signal: AbortSignal;\n}\n\n/* The use query return type */\nexport interface UseQueryReturn<Data> {\n  /* The abort function */\n  abort: AbortController['abort'];\n  /* The state of the query */\n  data?: Data;\n  /* The success state of the query */\n  error?: Error;\n  /* The error state of the query */\n  isError: boolean;\n  /* The fetching state of the query */\n  isFetching: boolean;\n  /* The loading state of the query */\n  isLoading: boolean;\n  /* The refetching state of the query */\n  isRefetching: boolean;\n  /* The success state of the query */\n  isSuccess: boolean;\n  /* The refetch function */\n  refetch: () => void;\n}\n\n/**\n * @name useQuery\n * @description - Hook that defines the logic when query data\n * @category Async\n *\n * @template Data The type of the data\n * @param {() => Promise<Data>} callback The callback function to be invoked\n * @param {DependencyList} [options.keys] The dependencies for the hook\n * @param {(data: Data) => void} [options.onSuccess] The callback function to be invoked on success\n * @param {(error: Error) => void} [options.onError] The callback function to be invoked on error\n * @param {UseQueryOptionsSelect<Data>} [options.select] The select function to be invoked\n * @param {Data | (() => Data)} [options.initialData] The initial data for the hook\n * @param {Data | (() => Data)} [options.placeholderData] The placeholder data for the hook\n * @param {number} [options.refetchInterval] The refetch interval\n * @param {boolean | number} [options.retry] The retry count of requests\n * @returns {UseQueryReturn<Data>} An object with the state of the query\n *\n * @example\n * const { data, isFetching, isLoading, isError, isSuccess, error, refetch, isRefetching, abort, aborted } = useQuery(() => fetch('url'));\n */\nexport const useQuery = <QueryData, Data = QueryData>(\n  callback: (params: UseQueryCallbackParams) => Promise<QueryData>,\n  options?: UseQueryOptions<QueryData, Data>\n): UseQueryReturn<Data> => {\n  const enabled = options?.enabled ?? true;\n  const retryCountRef = useRef(options?.retry ? getRetry(options.retry) : 0);\n  const alreadyRequested = useRef(false);\n\n  const [isFetching, setIsFetching] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isError, setIsError] = useState(false);\n  const [isRefetching, setIsRefetching] = useState(false);\n  const [isSuccess, setIsSuccess] = useState(!!options?.placeholderData);\n\n  const [error, setError] = useState<Error | undefined>(undefined);\n  const [data, setData] = useState<Data | undefined>(options?.placeholderData);\n\n  const abortControllerRef = useRef<AbortController>(new AbortController());\n  const intervalIdRef = useRef<ReturnType<typeof setInterval>>(undefined);\n\n  const keys = options?.keys ?? [];\n\n  const abort = () => {\n    abortControllerRef.current.abort();\n    abortControllerRef.current = new AbortController();\n  };\n\n  const request = (action: 'init' | 'refetch') => {\n    abort();\n\n    setIsFetching(true);\n    if (action === 'init') {\n      alreadyRequested.current = true;\n      setIsLoading(true);\n    }\n    if (action === 'refetch') setIsRefetching(true);\n    callback({ signal: abortControllerRef.current.signal, keys })\n      .then((response) => {\n        const data = options?.select ? options?.select(response) : response;\n        options?.onSuccess?.(data as Data);\n        setData(data as Data);\n        setIsSuccess(true);\n        setError(undefined);\n        setIsError(false);\n        setIsFetching(false);\n        if (action === 'init') setIsLoading(false);\n        if (action === 'refetch') setIsRefetching(false);\n      })\n      .catch((error: Error) => {\n        if (retryCountRef.current > 0) {\n          retryCountRef.current -= 1;\n          const retryDelay =\n            typeof options?.retryDelay === 'function'\n              ? options?.retryDelay(retryCountRef.current, error)\n              : options?.retryDelay;\n\n          if (retryDelay) {\n            setTimeout(() => request(action), retryDelay);\n            return;\n          }\n\n          return request(action);\n        }\n        options?.onError?.(error);\n        setData(undefined);\n        setIsSuccess(false);\n        setError(error);\n        setIsError(true);\n        setIsFetching(false);\n        if (action === 'init') setIsLoading(false);\n        if (action === 'refetch') setIsRefetching(false);\n        retryCountRef.current = options?.retry ? getRetry(options.retry) : 0;\n      })\n      .finally(() => {\n        if (options?.refetchInterval) {\n          const interval = setInterval(() => {\n            clearInterval(interval);\n            request('refetch');\n          }, options?.refetchInterval);\n          intervalIdRef.current = interval;\n        }\n      });\n  };\n\n  useMount(() => {\n    if (!enabled) return;\n    request('init');\n  });\n\n  useDidUpdate(() => {\n    if (!enabled) return;\n    request(alreadyRequested.current ? 'refetch' : 'init');\n  }, [enabled, ...keys]);\n\n  useEffect(() => {\n    return () => {\n      clearInterval(intervalIdRef.current);\n    };\n  }, [enabled, options?.refetchInterval, options?.retry, ...keys]);\n\n  const refetch = () => request('refetch');\n\n  return {\n    abort,\n    data,\n    error,\n    refetch,\n    isFetching,\n    isLoading,\n    isError,\n    isSuccess,\n    isRefetching\n  };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\n/** Type sprite map */\nexport interface SpriteMap {\n  /** [start time in seconds, end time in seconds] */\n  [key: string]: [number, number];\n}\n\n/** Type use audio options */\nexport interface UseAudioOptions {\n  /** Whether audio playback is initially enabled */\n  immediately?: boolean;\n  /** Whether to stop current playback when starting a new one */\n  interrupt?: boolean;\n  /** Initial playback speed (0.5 to 2) */\n  playbackRate?: number;\n  /** Map of named audio segments for sprite-based playback */\n  sprite?: SpriteMap;\n  /** Initial volume level (0 to 1) */\n  volume?: number;\n}\n\n/** Type use audio return type */\nexport interface UseAudioReturn {\n  /** Current playback speed (0.5 to 2) */\n  playbackRate: number;\n  /** Whether audio is currently playing */\n  playing: boolean;\n  /** Current volume level (0 to 1) */\n  volume: number;\n  /** Set playback speed (0.5 to 2) */\n  changePlaybackRate: (value: number) => void;\n  /** Pause audio playback at current position */\n  pause: () => void;\n  /** Start audio playback from the beginning or specified sprite segment */\n  play: (sprite?: string) => Promise<void>;\n  /** Set audio volume level (0 to 1) */\n  setVolume: (value: number) => void;\n  /** Stop audio playback and reset position to start */\n  stop: () => void;\n}\n\n/**\n * @name useAudio\n * @description - Hook that manages audio playback with sprite support\n * @category Browser\n *\n * @browserapi Audio https://developer.mozilla.org/en-US/docs/Web/API/Audio\n *\n * @template Value The type of the value\n * @param {string} url The URL of the audio file to play\n * @param {UseAudioOptions} [options] Audio configuration options\n * @param {number} [options.volume=1] Initial volume level (0 to 1)\n * @param {number} [options.playbackRate=1] Initial playback speed (0.5 to 2)\n * @param {boolean} [options.interrupt=false] Whether to stop current playback when starting a new one\n * @param {boolean} [options.soundEnabled=true] Whether audio playback is initially enabled\n * @param {SpriteMap} [options.sprite] Map of named audio segments for sprite-based playback\n * @returns {UseAudioReturn} An object containing audio controls and state\n *\n * @example\n * const audio = useAudio(\"/path/to/sound.mp3\");\n */\nexport const useAudio = (src: string, options: UseAudioOptions = {}): UseAudioReturn => {\n  const [playing, setPlaying] = useState(false);\n  const [volume, setCurrentVolume] = useState(options.volume ?? 1);\n  const [playbackRate, setPlaybackRate] = useState(options.playbackRate ?? 1);\n\n  const audioRef = useRef<HTMLAudioElement | null>(null);\n\n  useEffect(() => {\n    const audio = new Audio(src);\n\n    audio.volume = volume;\n    audio.playbackRate = playbackRate;\n    audioRef.current = audio;\n\n    if (options.immediately) audio.play();\n\n    const onPlay = () => setPlaying(true);\n    const onPause = () => setPlaying(false);\n    const onEnded = () => setPlaying(false);\n    const onTimeUpdate = () => {};\n    const onVolumeChange = () => setCurrentVolume(audio.volume);\n    const onRateChange = () => setPlaybackRate(audio.playbackRate);\n\n    audio.addEventListener('play', onPlay);\n    audio.addEventListener('pause', onPause);\n    audio.addEventListener('ended', onEnded);\n    audio.addEventListener('timeupdate', onTimeUpdate);\n    audio.addEventListener('volumechange', onVolumeChange);\n    audio.addEventListener('ratechange', onRateChange);\n\n    return () => {\n      audio.removeEventListener('play', onPlay);\n      audio.removeEventListener('pause', onPause);\n      audio.removeEventListener('ended', onEnded);\n      audio.removeEventListener('timeupdate', onTimeUpdate);\n      audio.removeEventListener('volumechange', onVolumeChange);\n      audio.removeEventListener('ratechange', onRateChange);\n\n      audio.pause();\n      audio.remove();\n    };\n  }, [src]);\n\n  const stop = () => {\n    if (!audioRef.current) return;\n    audioRef.current.pause();\n    audioRef.current.currentTime = 0;\n  };\n\n  const play = async (spriteName?: string) => {\n    if (!audioRef.current) return;\n    if (options.interrupt) stop();\n\n    if (!spriteName || !options.sprite?.[spriteName]) {\n      await audioRef.current.play();\n      return;\n    }\n\n    const [start, end] = options.sprite[spriteName];\n    audioRef.current.currentTime = start;\n    await audioRef.current.play();\n\n    const checkTime = () => {\n      if (!audioRef.current) return;\n      if (audioRef.current.currentTime >= end) {\n        stop();\n      }\n\n      if (!playing) return;\n\n      requestAnimationFrame(checkTime);\n    };\n\n    requestAnimationFrame(checkTime);\n  };\n\n  const pause = () => audioRef.current?.pause();\n\n  const setVolume = (value: number) => {\n    if (!audioRef.current) return;\n    const newVolume = Math.max(0, Math.min(1, value));\n    audioRef.current.volume = newVolume;\n    setCurrentVolume(newVolume);\n  };\n\n  const changePlaybackRate = (value: number) => {\n    if (!audioRef.current) return;\n    const newRate = Math.max(0.5, Math.min(2, value));\n    audioRef.current.playbackRate = newRate;\n    setPlaybackRate(newRate);\n  };\n\n  return {\n    play,\n    pause,\n    stop,\n    playing,\n    setVolume,\n    volume,\n    changePlaybackRate,\n    playbackRate\n  };\n};\n", "import { useEffect, useState } from 'react';\n\nexport interface BatteryManager extends EventTarget {\n  charging: boolean;\n  chargingTime: number;\n  dischargingTime: number;\n  level: number;\n}\n\ndeclare global {\n  interface Navigator {\n    readonly getBattery: () => Promise<BatteryManager>;\n  }\n}\n\n/** The use battery value type */\nexport interface UseBatteryValue {\n  /** Is charging battery? */\n  charging: boolean;\n  /** Time until the battery is fully charged */\n  chargingTime: number;\n  /** Time until the battery is completely discharged */\n  dischargingTime: number;\n  /** Battery charge level from 0 to 1 */\n  level: number;\n  /** Is battery information loading? */\n  loading: boolean;\n}\n\n/** The use battery return type */\nexport interface UseBatteryStateReturn {\n  /** Whether the battery api is supported*/\n  supported: boolean;\n  /** The use battery value type  */\n  value: UseBatteryValue;\n}\n\n/**\n * @name useBattery\n * @description - Hook for getting information about battery status\n * @category Browser\n *\n * @browserapi navigator.getBattery https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery\n *\n * @returns {UseBatteryStateReturn} Object containing battery information & Battery API support\n *\n * @example\n * const { supported, loading, charging, chargingTime, dischargingTime, level } = useBattery();\n */\nexport const useBattery = (): UseBatteryStateReturn => {\n  const supported =\n    typeof navigator !== 'undefined' &&\n    'getBattery' in navigator &&\n    typeof navigator.getBattery === 'function';\n  const [value, setValue] = useState<UseBatteryValue>({\n    loading: supported,\n    level: 0,\n    charging: false,\n    chargingTime: 0,\n    dischargingTime: 0\n  });\n\n  useEffect(() => {\n    if (!supported) return;\n\n    let battery: BatteryManager | null;\n\n    const onChange = () =>\n      setValue({\n        loading: false,\n        level: battery?.level ?? 0,\n        charging: battery?.charging ?? false,\n        dischargingTime: battery?.dischargingTime ?? 0,\n        chargingTime: battery?.chargingTime ?? 0\n      });\n\n    navigator.getBattery().then((batteryManager) => {\n      battery = batteryManager;\n      onChange();\n\n      battery.addEventListener('levelchange', onChange);\n      battery.addEventListener('chargingchange', onChange);\n      battery.addEventListener('chargingtimechange', onChange);\n      battery.addEventListener('dischargingtimechange', onChange);\n    });\n\n    return () => {\n      if (!battery) return;\n      console.log('unmount', battery);\n      battery.removeEventListener('levelchange', onChange);\n      battery.removeEventListener('chargingchange', onChange);\n      battery.removeEventListener('chargingtimechange', onChange);\n      battery.removeEventListener('dischargingtimechange', onChange);\n    };\n  }, []);\n\n  return { supported, value };\n};\n", "import { useEffect, useState } from 'react';\n\n/** The use bluetooth return type */\nexport interface UseBluetoothReturn {\n  /** Indicates if bluetooth device is currently connected */\n  connected: boolean;\n  /** Describe connected bluetooth device */\n  device?: BluetoothDevice;\n  /** The GATT server for connected bluetooth device */\n  server?: BluetoothRemoteGATTServer;\n  /** Whether the bluetooth is supported*/\n  supported: boolean;\n  /** Function to request bluetooth device from the user */\n  requestDevice: () => Promise<void>;\n}\n\n/** The use bluetooth options type */\nexport interface UseBluetoothOptions {\n  /** The options to request all bluetooth devices */\n  acceptAllDevices?: boolean;\n  /** Array of filters to apply when scanning bluetooth devices */\n  filters?: BluetoothLEScanFilter[];\n  /** Array of optional services that the application can use */\n  optionalServices?: BluetoothServiceUUID[];\n}\n\n/**\n * @name useBluetooth\n * @description - Hook for getting information about bluetooth\n * @category Browser\n *\n * @browserapi navigator.bluetooth https://developer.mozilla.org/en-US/docs/Web/API/Navigator/bluetooth\n *\n * @param {boolean} [options.acceptAllDevices=false] The options to request all Bluetooth devices\n * @param {Array<BluetoothLEScanFilter>} [options.filters] Array of filters to apply when scanning Bluetooth devices\n * @param {Array<BluetoothServiceUUID>} [options.optionalServices] Array of optional services that the application can use\n * @returns {UseBluetoothReturn} Object containing battery information & Battery API support\n *\n * @example\n * const { supported, connected, device, requestDevice, server } = useBluetooth(options);\n */\nexport const useBluetooth = (options?: UseBluetoothOptions): UseBluetoothReturn => {\n  const supported = typeof navigator !== 'undefined' && 'bluetooth' in navigator;\n  const { acceptAllDevices = false, filters, optionalServices } = options ?? {};\n\n  const [connected, setIsConnected] = useState(false);\n  const [device, setDevice] = useState<BluetoothDevice | undefined>(undefined);\n  const [server, setServer] = useState<BluetoothRemoteGATTServer | undefined>(undefined);\n\n  const requestDevice = async () => {\n    if (!supported) return;\n\n    const selectedDevice = await navigator.bluetooth.requestDevice({\n      acceptAllDevices,\n      optionalServices,\n      ...(filters && { filters, acceptAllDevices: false })\n    });\n\n    setDevice(selectedDevice);\n  };\n\n  useEffect(() => {\n    if (device && device.gatt) {\n      const connectToBluetoothGATTServer = async () => {\n        if (!device.gatt) return;\n        const gattServer = await device.gatt.connect();\n        setServer(gattServer);\n        setIsConnected(gattServer.connected);\n      };\n\n      const reset = () => {\n        setServer(undefined);\n        setDevice(undefined);\n        setIsConnected(false);\n      };\n\n      device.addEventListener('gattserverdisconnected', reset);\n      connectToBluetoothGATTServer();\n\n      return () => {\n        device.removeEventListener('gattserverdisconnected', reset);\n        device.gatt?.disconnect();\n      };\n    }\n  }, [device]);\n\n  return {\n    supported,\n    connected,\n    device,\n    requestDevice,\n    server\n  };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\n/** The use broadcast channel return type */\nexport interface UseBroadcastChannelReturn<Data = unknown> {\n  /** The underlying BroadcastChannel instance if supported, undefined otherwise */\n  channel?: BroadcastChannel;\n  /** Whether the channel has been closed */\n  closed: boolean;\n  /** The most recently received data from other contexts */\n  data?: Data;\n  /** Error object if any error occurred during channel operations */\n  error?: Event;\n  /** Whether the BroadcastChannel API is supported in the current environment */\n  supported: boolean;\n  /** Function to close the channel and clean up resources */\n  close: () => void;\n  /** Function to send data to other contexts through the channel */\n  post: (data: Data) => void;\n}\n\n/**\n * @name useBroadcastChannel\n * @description Hook that provides cross-tab/window communication\n * @category Browser\n *\n * @browserapi BroadcastChannel https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel\n *\n * @param {string} name The name of the channel\n * @param {Function} callback A callback function that will be called when a message is received\n * @returns {UseBroadcastChannelReturn} An object containing the channel state and controls\n *\n * @example\n * const { supported, data, post, error } = useBroadcastChannel('channel');\n */\nexport const useBroadcastChannel = <Data = unknown>(\n  name: string,\n  callback?: (data: Data) => void\n): UseBroadcastChannelReturn<Data> => {\n  const supported = typeof window !== 'undefined' && 'BroadcastChannel' in window;\n\n  const [closed, setClosed] = useState(false);\n  const [data, setData] = useState<Data>();\n  const [error, setError] = useState<MessageEvent>();\n  const channelRef = useRef<BroadcastChannel>(undefined);\n\n  useEffect(() => {\n    if (!supported) return;\n\n    channelRef.current = new BroadcastChannel(name);\n\n    const onMessage = (event: MessageEvent) => {\n      setData(event.data);\n      callback?.(event.data);\n    };\n    const onMessageError = (event: MessageEvent) => setError(event);\n    const onClose = () => setClosed(true);\n\n    channelRef.current.addEventListener('message', onMessage);\n    channelRef.current.addEventListener('messageerror', onMessageError);\n    channelRef.current.addEventListener('close', onClose);\n\n    return () => {\n      if (channelRef.current) {\n        channelRef.current.removeEventListener('message', onMessage);\n        channelRef.current.removeEventListener('messageerror', onMessageError);\n        channelRef.current.removeEventListener('close', onClose);\n        channelRef.current.close();\n      }\n    };\n  }, [name]);\n\n  const post = (data: Data) => {\n    console.log('post', data, channelRef.current);\n    if (!channelRef.current) return;\n    channelRef.current.postMessage(data);\n  };\n\n  const close = () => {\n    if (!channelRef.current) return;\n    channelRef.current.close();\n    setClosed(true);\n  };\n\n  return {\n    supported,\n    channel: channelRef.current,\n    data,\n    post,\n    close,\n    error,\n    closed\n  };\n};\n", "export const legacyCopyToClipboard = (value: string) => {\n  const tempTextArea = document.createElement('textarea');\n  tempTextArea.value = value;\n  tempTextArea.readOnly = true;\n  tempTextArea.style.fontSize = '16px';\n  document.body.appendChild(tempTextArea);\n  tempTextArea.select();\n  document.execCommand('copy');\n  document.body.removeChild(tempTextArea);\n};\n\nexport const copy = async (value: string) => {\n  try {\n    try {\n      await navigator.clipboard.writeText(value);\n    } catch {\n      return legacyCopyToClipboard(value);\n    }\n  } catch {\n    return legacyCopyToClipboard(value);\n  }\n};\n", "import { useEffect, useState } from 'react';\n\nimport { copy } from '@/utils/helpers';\n\n/** The use copy to clipboard return type */\nexport interface UseCopyToClipboardReturn {\n  /** The copied value */\n  value: string | null;\n  /** Function to copy to clipboard  */\n  copy: (value: string) => Promise<void>;\n}\n\n/** The use copy to clipboard params type */\nexport interface UseCopyToClipboardParams {\n  /** Whether the copy to clipboard is enabled */\n  enabled: boolean;\n}\n\n/**\n * @name useClipboard\n * @description - Hook that manages a copy to clipboard\n * @category Browser\n *\n * @browserapi navigator.clipboard https://developer.mozilla.org/en-US/docs/Web/API/Navigator/clipboard\n *\n * @param {boolean} [params.enabled=false] Whether the copy to clipboard is enabled\n * @returns {UseCopyToClipboardReturn} An object containing the boolean state value and utility functions to manipulate the state\n *\n * @example\n * const { value, copy } = useClipboard();\n */\nexport const useClipboard = (params?: UseCopyToClipboardParams): UseCopyToClipboardReturn => {\n  const [value, setValue] = useState<string | null>(null);\n  const enabled = params?.enabled ?? false;\n\n  const set = async () => {\n    try {\n      const value = await navigator.clipboard.readText();\n      setValue(value);\n    } catch {\n      setValue(document.getSelection?.()?.toString() ?? '');\n    }\n  };\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    document.addEventListener('copy', set);\n    document.addEventListener('cut', set);\n    return () => {\n      document.removeEventListener('copy', set);\n      document.removeEventListener('cut', set);\n    };\n  }, [enabled]);\n\n  const copyToClipboard = async (value: string) => {\n    copy(value);\n    setValue(value);\n  };\n\n  return { value, copy: copyToClipboard };\n};\n", "import { useState } from 'react';\n\nimport { copy } from '@/utils/helpers';\n\n/** The use copy return type */\nexport interface UseCopyReturn {\n  /** Whether copy is in progress */\n  copied: boolean;\n  /** The copied value */\n  value?: string;\n  /** Function to copy text */\n  copy: (value: string) => Promise<void>;\n}\n\n/** The use copy params type */\nexport interface UseCopyParams {\n  /** Reset delay in milliseconds */\n  resetDelay?: number;\n}\n\n/**\n * @name useCopy\n * @description - Hook that manages copying text with status reset\n * @category Browser\n *\n * @browserapi navigator.clipboard https://developer.mozilla.org/en-US/docs/Web/API/Navigator/clipboard\n *\n * @param {number} [delay=1000] Delay in ms before resetting copied status\n * @returns {UseCopyReturn} An object containing the copied value, status and copy function\n *\n * @example\n * const { copied, value, copy } = useCopy();\n */\nexport const useCopy = (delay: number = 1000): UseCopyReturn => {\n  const [value, setValue] = useState<string | undefined>();\n  const [copied, setCopied] = useState(false);\n\n  const copyToClipboard = async (text: string) => {\n    await copy(text);\n    setValue(text);\n    setCopied(true);\n    setTimeout(() => setCopied(false), delay);\n  };\n\n  return { value, copied, copy: copyToClipboard };\n};\n", "import { useState } from 'react';\n\nexport interface StateRef<Value> {\n  (node: Value): void;\n  current: Value;\n  state?: Value;\n}\n\nconst createRefState = <Value>(\n  initialValue: Value | undefined,\n  setState: (value: Value) => void\n) => {\n  let temp = initialValue;\n  function ref(value: Value) {\n    if (temp === value) return;\n    temp = value;\n    setState(temp);\n  }\n\n  Object.defineProperty(ref, 'current', {\n    get() {\n      return temp;\n    },\n    set(value: Value) {\n      if (temp === value) return;\n      temp = value;\n      setState(temp);\n    },\n    configurable: true,\n    enumerable: true\n  });\n\n  return ref as StateRef<Value>;\n};\n\n/**\n * @name useRefState\n * @description - Hook that returns the state reference of the value\n * @category State\n *\n * @template Value The type of the value\n * @param {Value} [initialValue] The initial value\n * @returns {StateRef<Value>} The current value\n *\n * @example\n * const internalRefState = useRefState();\n */\nexport const useRefState = <Value>(initialValue?: Value) => {\n  const [state, setState] = useState<Value | undefined>(initialValue);\n  const [ref] = useState(() => createRefState<Value>(initialValue, setState));\n  ref.state = state;\n  return ref;\n};\n", "import type { RefObject } from 'react';\n\nexport type Target = (() => Element) | string | Document | Element | Window;\nexport type HookTarget =\n  | RefObject<Element | null | undefined>\n  | {\n      value: Target;\n      type: symbol;\n    };\n\nexport const targetSymbol = Symbol('target');\nexport const target = (target: Target) => ({\n  value: target,\n  type: targetSymbol\n});\n\nexport const getElement = (target: HookTarget) => {\n  if ('current' in target) {\n    return target.current;\n  }\n\n  if (typeof target.value === 'function') {\n    return target.value();\n  }\n\n  if (typeof target.value === 'string') {\n    return document.querySelector(target.value);\n  }\n\n  if (target.value instanceof Document) {\n    return target.value;\n  }\n\n  if (target.value instanceof Window) {\n    return target.value;\n  }\n\n  if (target.value instanceof Element) {\n    return target.value;\n  }\n\n  return target.value;\n};\n", "import type { HookTarget } from './getElement';\n\nimport { targetSymbol } from './getElement';\n\nexport const isTarget = (target: HookTarget) =>\n  typeof target === 'object' && ('current' in target || target.type === targetSymbol);\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The css variable return type */\nexport interface UseCssVarReturn {\n  /** The value of the CSS variable */\n  value: string;\n  /** Remove the value of the CSS variable */\n  remove: () => void;\n  /** Set the value of the CSS variable */\n  set: (value: string) => void;\n}\n\nexport interface UseCssVar {\n  <Target extends HTMLElement>(\n    key: string,\n    initialValue?: string\n  ): UseCssVarReturn & {\n    ref: StateRef<Target>;\n  };\n\n  (target: HookTarget, key: string, initialValue?: string): UseCssVarReturn;\n}\n\n/**\n * @name useCssVar\n * @description - Hook that returns the value of a css variable\n * @category Browser\n *\n * @overload\n * @param {string} key The CSS variable key\n * @param {string} initialValue The initial value of the CSS variable\n * @returns {UseCssVarReturn & { ref: StateRef<Element> }} The object containing the value of the CSS variable and ref\n *\n * @example\n * const { ref, value, set, remove } = useCssVar('--color', 'red');\n *\n * @overload\n * @param {HookTarget} target The target element\n * @param {string} key The CSS variable key\n * @param {string} initialValue The initial value of the CSS variable\n * @returns {UseCssVarReturn} The object containing the value of the CSS variable\n *\n * @example\n * const { value, set, remove } = useCssVar(ref, '--color', 'red');\n */\nexport const useCssVar = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const key = (target ? params[1] : params[0]) as string;\n  const initialValue = (target ? params[2] : params[1]) as string | undefined;\n\n  const [value, setValue] = useState(initialValue ?? '');\n  const internalRef = useRefState<HTMLElement>();\n  const elementRef = useRef<HTMLElement>(null);\n\n  const set = (value: string) => {\n    if (!elementRef.current) return;\n    const element = elementRef.current;\n\n    if (!element.style) return;\n    element.style.setProperty(key, value);\n    setValue(value);\n  };\n\n  const remove = () => {\n    if (!elementRef.current) return;\n    const element = elementRef.current;\n    if (!element.style) return;\n\n    element.style.removeProperty(key);\n    setValue('');\n  };\n\n  useEffect(() => {\n    if (!initialValue) return;\n\n    const element =\n      ((target ? getElement(target) : internalRef.current) as HTMLElement) ??\n      window.document.documentElement;\n\n    if (!element.style) return;\n    element.style.setProperty(key, initialValue);\n    setValue(initialValue);\n  }, []);\n\n  useEffect(() => {\n    const element =\n      ((target ? getElement(target) : internalRef.current) as HTMLElement) ??\n      window.document.documentElement;\n\n    elementRef.current = element;\n\n    const onChange = () => {\n      const value = window.getComputedStyle(element).getPropertyValue(key)?.trim();\n\n      setValue(value ?? initialValue);\n    };\n\n    const observer = new MutationObserver(onChange);\n\n    observer.observe(element, { attributeFilter: ['style', 'class'] });\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return { value, set, remove };\n  return { ref: internalRef, value, set, remove };\n}) as UseCssVar;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use display media return type */\nexport interface UseDisplayMediaReturn {\n  /** Whether screen sharing is currently active */\n  sharing: boolean;\n  /** The media stream object */\n  stream: MediaStream | null;\n  /** Whether the display media API is supported */\n  supported: boolean;\n  /** Start screen sharing */\n  start: () => Promise<void>;\n  /** Stop screen sharing */\n  stop: () => void;\n}\n\n/** The use display media options type */\nexport interface UseDisplayMediaOptions {\n  /** Whether to enable audio sharing */\n  audio?: boolean | MediaTrackConstraints;\n  /** Whether to start immediately */\n  immediately?: boolean;\n  /** Whether to enable video sharing */\n  video?: boolean | MediaTrackConstraints;\n}\n\nexport interface UseDisplayMedia {\n  (target: HookTarget, options?: UseDisplayMediaOptions): UseDisplayMediaReturn;\n\n  <Target extends HTMLVideoElement>(\n    options?: UseDisplayMediaOptions,\n    target?: never\n  ): { ref: StateRef<Target> } & UseDisplayMediaReturn;\n}\n\n/**\n * @name useDisplayMedia\n * @description - Hook that provides screen sharing functionality\n * @category Browser\n *\n * @browserapi mediaDevices.getDisplayMedia https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia\n *\n * @overload\n * @param {HookTarget} target The target video element to display the media stream\n * @param {boolean | MediaTrackConstraints} [options.audio] Whether to enable audio sharing\n * @param {boolean} [options.immediately=false] Whether to start immediately\n * @param {boolean | MediaTrackConstraints} [options.video] Whether to enable video sharing\n * @returns {UseDisplayMediaReturn} Object containing stream, sharing status and control methods\n *\n * @example\n * const { stream, sharing, start, stop } = useDisplayMedia(ref);\n *\n * @overload\n * @template Target The target video element\n * @param {boolean | MediaTrackConstraints} [options.audio] Whether to enable audio sharing\n * @param {boolean} [options.immediately=false] Whether to start immediately\n * @param {boolean | MediaTrackConstraints} [options.video] Whether to enable video sharing\n * @returns {UseDisplayMediaReturn & { ref: StateRef<HTMLVideoElement> }} Object containing stream, sharing status, control methods and ref\n *\n * @example\n * const { ref, stream, sharing, start, stop } = useDisplayMedia<HTMLVideoElement>();\n */\nexport const useDisplayMedia = ((...params: any[]) => {\n  const supported =\n    typeof navigator !== 'undefined' &&\n    'mediaDevices' in navigator &&\n    !!navigator.mediaDevices &&\n    'getDisplayMedia' in navigator.mediaDevices;\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (params[1] ? params[1] : params[0]) as UseDisplayMediaOptions | undefined;\n  const immediately = options?.immediately ?? false;\n\n  const [sharing, setSharing] = useState(false);\n\n  const elementRef = useRef<HTMLVideoElement>(null);\n  const streamRef = useRef<MediaStream>(null);\n  const internalRef = useRefState<Element>();\n\n  const stop = () => {\n    if (!streamRef.current || !supported || !elementRef.current) return;\n\n    setSharing(false);\n    elementRef.current.srcObject = null;\n    streamRef.current.getTracks().forEach((track) => track.stop());\n    streamRef.current = null;\n  };\n\n  const start = async () => {\n    if (!supported || !elementRef.current) return;\n\n    const displayMedia = await navigator.mediaDevices.getDisplayMedia({\n      video: options?.video,\n      audio: options?.audio\n    });\n\n    setSharing(true);\n    streamRef.current = displayMedia;\n    elementRef.current.srcObject = displayMedia;\n\n    displayMedia.getTracks().forEach((track) => (track.onended = stop));\n    return displayMedia;\n  };\n\n  useEffect(() => {\n    if (!supported || (!target && !internalRef.state)) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as HTMLVideoElement;\n\n    if (!element) return;\n\n    elementRef.current = element;\n\n    if (!immediately) return;\n\n    start();\n\n    return () => {\n      stop();\n    };\n  }, [target, internalRef.state]);\n\n  if (target)\n    return {\n      stream: streamRef.current,\n      sharing,\n      supported,\n      start,\n      stop\n    };\n\n  return {\n    stream: streamRef.current,\n    sharing,\n    supported,\n    start,\n    stop,\n    ref: internalRef\n  };\n}) as UseDisplayMedia;\n", "import { useEffect, useRef, useState } from 'react';\n\n/** The use document title options type */\nexport interface UseDocumentTitleOptions {\n  /** Restore the previous title on unmount */\n  restoreOnUnmount?: boolean;\n}\n\n/** The use document title return type */\nexport interface UseDocumentTitleReturn {\n  /** The current title */\n  value: string;\n  /** Function to update the title */\n  set: (title: string) => void;\n}\n\n/**\n * @name useDocumentTitle\n * @description - Hook that manages the document title and allows updating it\n * @category Browser\n *\n * @browserapi document.title https://developer.mozilla.org/en-US/docs/Web/API/Document/title\n *\n * @param {string} [initialValue] The initial title. If not provided, the current document title will be used\n * @param {boolean} [options.restoreOnUnmount] Restore the previous title on unmount\n * @returns {UseDocumentTitleReturn} An array containing the current title and a function to update the title\n *\n * @example\n * const { value, set } = useDocumentTitle();\n */\nexport function useDocumentTitle(\n  initialValue?: string,\n  options?: UseDocumentTitleOptions\n): UseDocumentTitleReturn {\n  const prevValueRef = useRef(document.title);\n  const [value, setValue] = useState(initialValue ?? document.title);\n\n  const set = (value: string) => {\n    const updatedValue = value.trim();\n    if (updatedValue.length > 0) document.title = updatedValue;\n  };\n\n  useEffect(() => {\n    if (typeof value !== 'string') return;\n    set(value);\n  }, [value]);\n\n  useEffect(() => {\n    const observer = new MutationObserver(() => {\n      setValue((prevValue) => {\n        if (document && document.title !== prevValue) {\n          return document.title;\n        }\n        return prevValue;\n      });\n    });\n\n    observer.observe(document.head.querySelector('title')!, {\n      childList: true\n    });\n\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n\n  useEffect(() => {\n    if (options?.restoreOnUnmount) {\n      return () => {\n        document.title = prevValueRef.current;\n      };\n    }\n  }, []);\n\n  return { value, set };\n}\n", "import { useEffect, useRef, useState } from 'react';\n\nimport { getRetry } from '@/utils/helpers';\n\n/** The use event source options type */\nexport interface UseEventSourceOptions<QueryData, Data> extends EventSourceInit {\n  /** Immediately open the connection when calling this hook */\n  immediately?: boolean;\n  /* The placeholder data for the hook */\n  placeholderData?: (() => Data) | Data;\n  /* The retry count of requests */\n  retry?: boolean | number;\n  /* The retry delay of requests */\n  retryDelay?: ((retry: number, event: Event) => number) | number;\n  /* The onError function to be invoked */\n  onError?: (error: Event) => void;\n  /* The onMessage function to be invoked */\n  onMessage?: (event: Event & { data?: Data }) => void;\n  /* The onOpen function to be invoked */\n  onOpen?: () => void;\n  /* The select function to be invoked */\n  select?: (data: QueryData) => Data;\n}\n\n/** The use event source return type */\ninterface UseEventSourceReturn<Data = any> {\n  /** The latest data received via the EventSource */\n  data?: Data;\n  /** The current error */\n  error?: Event;\n  /** The instance of the EventSource */\n  instance?: EventSource;\n  /* The connecting state of the query */\n  isConnecting: boolean;\n  /* The error state of the query */\n  isError: boolean;\n  /* The open state of the query */\n  isOpen: boolean;\n  /** Closes the EventSource connection gracefully */\n  close: () => void;\n  /** Reopen the EventSource connection */\n  open: () => void;\n}\n\n/**\n * @name useEventSource\n * @description - Hook that provides a reactive wrapper for event source\n * @category Browser\n *\n * @browserapi EventSource https://developer.mozilla.org/en-US/docs/Web/API/EventSource\n *\n * @param {string | URL} url The URL of the EventSource\n * @param {string[]} [events=[]] List of events to listen to\n * @param {UseEventSourceOptions} [options={}] Configuration options\n * @returns {UseEventSourceReturn<Data>} The EventSource state and controls\n *\n * @example\n * const { instance, data, isConnecting, isOpen, isError, close, open } = useEventSource('url', ['message']);\n */\nexport const useEventSource = <QueryData = any, Data = QueryData>(\n  url: string | URL,\n  events: string[] = [],\n  options: UseEventSourceOptions<QueryData, Data> = {}\n): UseEventSourceReturn<Data> => {\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [isOpen, setIsOpen] = useState(false);\n  const [isError, setIsError] = useState(false);\n\n  const retryCountRef = useRef(options?.retry ? getRetry(options.retry) : 0);\n  const [error, setError] = useState<Event | undefined>(undefined);\n  const [data, setData] = useState<Data | undefined>(options?.placeholderData);\n\n  const eventSourceRef = useRef<EventSource>(undefined);\n\n  const immediately = options.immediately ?? true;\n\n  const close = () => {\n    if (!eventSourceRef.current) return;\n\n    eventSourceRef.current.close();\n    eventSourceRef.current = undefined;\n    setIsOpen(false);\n    setIsConnecting(false);\n    setIsError(false);\n  };\n\n  const open = () => {\n    close();\n\n    const eventSource = new EventSource(url, {\n      withCredentials: options.withCredentials ?? false\n    });\n    eventSourceRef.current = eventSource;\n\n    setIsConnecting(true);\n\n    eventSource.onopen = () => {\n      setIsOpen(true);\n      setIsConnecting(false);\n      setError(undefined);\n      options?.onOpen?.();\n    };\n\n    eventSource.onerror = (event) => {\n      setIsOpen(false);\n      setIsConnecting(false);\n      setIsError(true);\n      setError(event);\n      options?.onError?.(event);\n\n      if (retryCountRef.current > 0) {\n        retryCountRef.current -= 1;\n\n        const retryDelay =\n          typeof options?.retryDelay === 'function'\n            ? options?.retryDelay(retryCountRef.current, event)\n            : options?.retryDelay;\n\n        if (retryDelay) {\n          setTimeout(open, retryDelay);\n          return;\n        }\n      }\n\n      retryCountRef.current = options?.retry ? getRetry(options.retry) : 0;\n    };\n\n    eventSource.onmessage = (event) => {\n      const data = options?.select ? options?.select(event.data) : event.data;\n      setData(data);\n      options?.onMessage?.(event);\n    };\n\n    events.forEach((eventName) => {\n      eventSource.addEventListener(eventName, (event: Event & { data?: Data }) => {\n        setData(event.data);\n      });\n    });\n  };\n\n  useEffect(() => {\n    if (!immediately) return;\n\n    open();\n    return () => {\n      close();\n    };\n  }, [immediately]);\n\n  return {\n    instance: eventSourceRef.current,\n    data,\n    error,\n    isConnecting,\n    isOpen,\n    isError,\n    close,\n    open\n  };\n};\n", "import { useState } from 'react';\n\nexport interface ColorSelectionOptions {\n  signal?: AbortSignal;\n}\n\nexport interface ColorSelectionResult {\n  sRGBHex: string;\n}\n\nexport interface EyeDropper {\n  open: (options?: ColorSelectionOptions) => Promise<ColorSelectionResult>;\n}\n\nexport interface EyeDropperConstructor {\n  new (): EyeDropper;\n}\n\ndeclare global {\n  interface Window {\n    readonly EyeDropper?: EyeDropperConstructor | undefined;\n  }\n}\n\n/** The color selection return type */\nexport interface UseEyeDropperReturn {\n  /** The eye dropper supported status */\n  supported: boolean;\n  /** The eye dropper value */\n  value?: string;\n  /** The eye dropper open method */\n  open: (colorSelectionOptions?: ColorSelectionOptions) => Promise<ColorSelectionResult>;\n}\n\n/**\n * @name useEyeDropper\n * @description - Hook that gives you access to the eye dropper\n * @category Browser\n *\n * @browserapi EyeDropper https://developer.mozilla.org/en-US/docs/Web/API/EyeDropper\n *\n * @param {string} [initialValue=undefined] The initial value for the eye dropper\n * @returns {UseEyeDropperReturn} An object containing the supported status, the value and the open method\n *\n * @example\n * const { supported, value, open } = useEyeDropper();\n */\nexport const useEyeDropper = (\n  initialValue: string | undefined = undefined\n): UseEyeDropperReturn => {\n  const supported = typeof window !== 'undefined' && 'EyeDropper' in window;\n  const [value, setValue] = useState(initialValue);\n\n  const open = async (colorSelectionOptions?: ColorSelectionOptions) => {\n    if (!window.EyeDropper) throw new Error('EyeDropper is not supported');\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(colorSelectionOptions);\n    setValue(result.sRGBHex);\n    return result;\n  };\n\n  return {\n    supported,\n    value,\n    open\n  };\n};\n", "import type { Dispatch, SetStateAction } from 'react';\n\nimport { useState } from 'react';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\nimport { useMount } from '../useMount/useMount';\n\n/** The use favicon return type */\nexport type UseFaviconReturn = [string, Dispatch<SetStateAction<string>>];\n\n/**\n * @name useFavicon\n * @description - Hook that manages the favicon\n * @category Browser\n *\n * @param {string} [initialFavicon] The initial favicon. If not provided, the current favicon will be used\n * @returns {UseFaviconReturn} An array containing the current favicon and a function to update the favicon\n *\n * @example\n * const { href, set } = useFavicon('https://www.google.com/favicon.ico');\n */\nexport const useFavicon = (initialHref?: string) => {\n  const [href, setHref] = useState(\n    initialHref ?? document.querySelector<HTMLLinkElement>(`link[rel*=\"icon\"]`)?.href\n  );\n\n  const injectFavicon = (favicon: string) => {\n    const link =\n      document.querySelector<HTMLLinkElement>(`link[rel*=\"icon\"]`) ||\n      document.createElement('link');\n    link.rel = 'icon';\n    link.href = favicon;\n    link.type = `image/${favicon.split('.').pop()}`;\n    document.head.append(link);\n  };\n\n  const set = (favicon: string) => {\n    setHref(favicon);\n    injectFavicon(favicon);\n  };\n\n  useMount(() => {\n    if (!initialHref) return;\n    injectFavicon(initialHref);\n  });\n\n  useDidUpdate(() => {\n    if (!initialHref) return;\n    setHref(initialHref);\n    injectFavicon(initialHref);\n  }, [initialHref]);\n\n  return { href, set } as const;\n};\n", "import { useEffect, useState } from 'react';\n\n/**\n * @name useFps\n * @description - Hook that measures frames per second\n * @category Browser\n *\n * @browserapi requestAnimationFrame https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n *\n * @returns {number} A number which determines frames per second\n *\n * @example\n * const fps = useFps();\n */\nexport const useFps = () => {\n  const [fps, setFps] = useState(0);\n\n  useEffect(() => {\n    let frameCount = 0;\n    let startTime = performance.now();\n    let rafId: number;\n\n    const onRequestAnimationFrame = () => {\n      frameCount += 1;\n      const currentTime = performance.now();\n      const elapsedTime = currentTime - startTime;\n\n      if (elapsedTime >= 1000) {\n        const calculatedFps = Math.round((frameCount * 1000) / elapsedTime);\n        setFps(calculatedFps);\n        frameCount = 0;\n        startTime = currentTime;\n      }\n\n      rafId = requestAnimationFrame(onRequestAnimationFrame);\n    };\n\n    rafId = requestAnimationFrame(onRequestAnimationFrame);\n\n    return () => {\n      cancelAnimationFrame(rafId);\n    };\n  }, []);\n\n  return fps;\n};\n", "/* eslint-disable promise/prefer-await-to-then */\n\nconst methodMap = [\n\t[\n\t\t'requestFullscreen',\n\t\t'exitFullscreen',\n\t\t'fullscreenElement',\n\t\t'fullscreenEnabled',\n\t\t'fullscreenchange',\n\t\t'fullscreenerror',\n\t],\n\t// New WebKit\n\t[\n\t\t'webkitRequestFullscreen',\n\t\t'webkitExitFullscreen',\n\t\t'webkitFullscreenElement',\n\t\t'webkitFullscreenEnabled',\n\t\t'webkitfullscreenchange',\n\t\t'webkitfullscreenerror',\n\n\t],\n\t// Old WebKit\n\t[\n\t\t'webkitRequestFullScreen',\n\t\t'webkitCancelFullScreen',\n\t\t'webkitCurrentFullScreenElement',\n\t\t'webkitCancelFullScreen',\n\t\t'webkitfullscreenchange',\n\t\t'webkitfullscreenerror',\n\n\t],\n\t[\n\t\t'mozRequestFullScreen',\n\t\t'mozCancelFullScreen',\n\t\t'mozFullScreenElement',\n\t\t'mozFullScreenEnabled',\n\t\t'mozfullscreenchange',\n\t\t'mozfullscreenerror',\n\t],\n\t[\n\t\t'msRequestFullscreen',\n\t\t'msExitFullscreen',\n\t\t'msFullscreenElement',\n\t\t'msFullscreenEnabled',\n\t\t'MSFullscreenChange',\n\t\t'MSFullscreenError',\n\t],\n];\n\nconst nativeAPI = (() => {\n\tif (typeof document === 'undefined') {\n\t\treturn false;\n\t}\n\n\tconst unprefixedMethods = methodMap[0];\n\tconst returnValue = {};\n\n\tfor (const methodList of methodMap) {\n\t\tconst exitFullscreenMethod = methodList?.[1];\n\t\tif (exitFullscreenMethod in document) {\n\t\t\tfor (const [index, method] of methodList.entries()) {\n\t\t\t\treturnValue[unprefixedMethods[index]] = method;\n\t\t\t}\n\n\t\t\treturn returnValue;\n\t\t}\n\t}\n\n\treturn false;\n})();\n\nconst eventNameMap = {\n\tchange: nativeAPI.fullscreenchange,\n\terror: nativeAPI.fullscreenerror,\n};\n\n// eslint-disable-next-line import/no-mutable-exports\nlet screenfull = {\n\t// eslint-disable-next-line default-param-last\n\trequest(element = document.documentElement, options) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst onFullScreenEntered = () => {\n\t\t\t\tscreenfull.off('change', onFullScreenEntered);\n\t\t\t\tresolve();\n\t\t\t};\n\n\t\t\tscreenfull.on('change', onFullScreenEntered);\n\n\t\t\tconst returnPromise = element[nativeAPI.requestFullscreen](options);\n\n\t\t\tif (returnPromise instanceof Promise) {\n\t\t\t\treturnPromise.then(onFullScreenEntered).catch(reject);\n\t\t\t}\n\t\t});\n\t},\n\texit() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (!screenfull.isFullscreen) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst onFullScreenExit = () => {\n\t\t\t\tscreenfull.off('change', onFullScreenExit);\n\t\t\t\tresolve();\n\t\t\t};\n\n\t\t\tscreenfull.on('change', onFullScreenExit);\n\n\t\t\tconst returnPromise = document[nativeAPI.exitFullscreen]();\n\n\t\t\tif (returnPromise instanceof Promise) {\n\t\t\t\treturnPromise.then(onFullScreenExit).catch(reject);\n\t\t\t}\n\t\t});\n\t},\n\ttoggle(element, options) {\n\t\treturn screenfull.isFullscreen ? screenfull.exit() : screenfull.request(element, options);\n\t},\n\tonchange(callback) {\n\t\tscreenfull.on('change', callback);\n\t},\n\tonerror(callback) {\n\t\tscreenfull.on('error', callback);\n\t},\n\ton(event, callback) {\n\t\tconst eventName = eventNameMap[event];\n\t\tif (eventName) {\n\t\t\tdocument.addEventListener(eventName, callback, false);\n\t\t}\n\t},\n\toff(event, callback) {\n\t\tconst eventName = eventNameMap[event];\n\t\tif (eventName) {\n\t\t\tdocument.removeEventListener(eventName, callback, false);\n\t\t}\n\t},\n\traw: nativeAPI,\n};\n\nObject.defineProperties(screenfull, {\n\tisFullscreen: {\n\t\tget: () => Boolean(document[nativeAPI.fullscreenElement]),\n\t},\n\telement: {\n\t\tenumerable: true,\n\t\tget: () => document[nativeAPI.fullscreenElement] ?? undefined,\n\t},\n\tisEnabled: {\n\t\tenumerable: true,\n\t\t// Coerce to boolean in case of old WebKit.\n\t\tget: () => Boolean(document[nativeAPI.fullscreenEnabled]),\n\t},\n});\n\nif (!nativeAPI) {\n\tscreenfull = {isEnabled: false};\n}\n\nexport default screenfull;\n", "import { useEffect, useState } from 'react';\nimport screenfull from 'screenfull';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use fullscreen options type */\nexport interface UseFullScreenOptions {\n  /** initial value */\n  initialValue?: boolean;\n  /** on enter fullscreen */\n  onEnter?: () => void;\n  /** on exit fullscreen */\n  onExit?: () => void;\n}\n\n/** The use click outside return type */\nexport interface UseFullScreenReturn {\n  /** The fullscreen state */\n  value: boolean;\n  /** The fullscreen enter method */\n  enter: () => void;\n  /** The fullscreen exit method */\n  exit: () => void;\n  /** The fullscreen toggle method */\n  toggle: () => void;\n}\n\nexport interface UseFullScreen {\n  (target: HookTarget, options?: UseFullScreenOptions): UseFullScreenReturn;\n\n  <Target extends Element>(\n    options?: UseFullScreenOptions,\n    target?: never\n  ): UseFullScreenReturn & { ref: StateRef<Target> };\n}\n\n/**\n * @name useFullscreen\n * @description - Hook to handle fullscreen events\n * @category Browser\n *\n * @overload\n * @param {HookTarget} target The target element for fullscreen\n * @param {boolean} [options.initialValue=false] initial value of fullscreen\n * @param {() => void} [options.onEnter] on enter fullscreen\n * @param {() => void} [options.onExit] on exit fullscreen\n * @returns {UseFullScreenReturn} An object with the fullscreen state and methods\n *\n * @example\n * const { enter, exit, toggle, value } = useFullscreen(ref);\n *\n * @overload\n * @template Target The target element for fullscreen\n * @param {boolean} [options.initialValue=false] initial value of fullscreen\n * @param {() => void} [options.onEnter] on enter fullscreen\n * @param {() => void} [options.onExit] on exit fullscreen\n * @returns {UseFullScreenReturn & { ref: RefObject<Target> }} An object with the fullscreen state and methods\n *\n * @example\n * const { ref, enter, exit, toggle, value } = useFullscreen();\n */\nexport const useFullscreen = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (target ? params[1] : params[0]) as UseFullScreenOptions | undefined;\n\n  const [value, setValue] = useState(options?.initialValue ?? false);\n  const internalRef = useRefState<Element>();\n\n  const onChange = () => {\n    if (!screenfull.isEnabled) return;\n\n    if (screenfull.isFullscreen) {\n      options?.onEnter?.();\n    } else {\n      screenfull.off('change', onChange);\n      options?.onExit?.();\n    }\n\n    setValue(screenfull.isFullscreen);\n  };\n\n  const enter = () => {\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    if (screenfull.isEnabled) {\n      try {\n        screenfull.request(element);\n        screenfull.on('change', onChange);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  };\n\n  const exit = () => {\n    if (screenfull.isEnabled) screenfull.exit();\n  };\n\n  const toggle = () => {\n    if (value) return exit();\n    enter();\n  };\n\n  useEffect(\n    () => () => {\n      if (screenfull.isEnabled) screenfull.off('change', onChange);\n    },\n    []\n  );\n\n  if (target)\n    return {\n      enter,\n      exit,\n      toggle,\n      value\n    };\n  return {\n    ref: internalRef,\n    enter,\n    exit,\n    toggle,\n    value\n  };\n}) as UseFullScreen;\n", "import { useEffect, useRef, useState } from 'react';\n\n/* The use raf params type */\nexport interface UseRafParams {\n  /** The delta between each frame in milliseconds */\n  delta: number;\n  /** The timestamp of the current frame in milliseconds */\n  timestamp: DOMHighResTimeStamp;\n}\n\n/* The use raf type */\nexport type UseRafCallback = (params: UseRafParams) => void;\n\n/* The use raf options type */\nexport interface UseRafOptions {\n  /** The delay between each frame in milliseconds */\n  delay?: number;\n  /** Whether the callback should be enabled */\n  enabled?: boolean;\n}\n\n/* The use raf return type */\nexport interface UseRafReturn {\n  /** Whether the callback is active */\n  active: boolean;\n  /** Function to pause the callback */\n  pause: () => void;\n  /** Function to resume the callback */\n  resume: () => void;\n}\n\n/**\n * @name useRaf\n * @description - Hook that defines the logic for raf callback\n * @category Browser\n *\n * @browserapi requestAnimationFrame https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n *\n * @param {UseRafCallback} callback The callback to execute\n * @param {number} [options.delay] The delay between each frame in milliseconds\n * @param {boolean} [options.enabled=true] Whether the callback should be enabled\n * @returns {UseRafCallbackReturn} An object of raf callback functions\n *\n * @example\n * useRaf(() => console.log('callback'));\n */\nexport const useRaf = (callback: UseRafCallback, options?: UseRafOptions): UseRafReturn => {\n  const rafIdRef = useRef<number | null>(null);\n  const previousFrameTimestampRef = useRef(0);\n  const [active, setActive] = useState(false);\n  const enabled = options?.enabled ?? true;\n\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  const loop = (timestamp: DOMHighResTimeStamp) => {\n    const delta = timestamp - previousFrameTimestampRef.current;\n\n    if (options?.delay && delta < options?.delay) {\n      rafIdRef.current = window.requestAnimationFrame(loop);\n      return;\n    }\n\n    previousFrameTimestampRef.current = timestamp;\n    internalCallbackRef.current({ delta, timestamp });\n    rafIdRef.current = window.requestAnimationFrame(loop);\n  };\n\n  const resume = () => {\n    if (active) return;\n    setActive(true);\n    previousFrameTimestampRef.current = 0;\n    rafIdRef.current = window.requestAnimationFrame(loop);\n  };\n\n  function pause() {\n    if (!rafIdRef.current) return;\n\n    setActive(false);\n    window.cancelAnimationFrame(rafIdRef.current);\n    rafIdRef.current = null;\n  }\n\n  useEffect(() => {\n    if (!enabled) return;\n    resume();\n\n    return pause;\n  }, [enabled, options?.delay]);\n\n  return {\n    active,\n    pause,\n    resume\n  };\n};\n", "import { useEffect, useState } from 'react';\n\nimport { useRaf } from '../useRaf/useRaf';\n\ndeclare global {\n  interface Gamepad {\n    hapticActuators?: GamepadHapticActuator[];\n  }\n}\n\n/** The use gamepad return type  */\nexport interface UseGamepadStateReturn {\n  /** The gamepad active status */\n  active: boolean;\n  /** The gamepad state */\n  gamepads: Gamepad[];\n  /** The gamepad supported status */\n  supported: boolean;\n}\n\n/**\n * @name useGamepad\n * @description - Hook for getting information about gamepad\n * @category Browser\n *\n * @browserapi navigator.getGamepads https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getGamepads\n *\n * @returns {UseGamepadStateReturn} An object containing the gamepad information\n *\n * @example\n * const { supported, gamepads, active } = useGamepad();\n */\nexport const useGamepad = () => {\n  const supported = typeof navigator !== 'undefined' && 'getGamepads' in navigator;\n  const [gamepads, setGamepads] = useState<Record<number, Gamepad>>({});\n\n  const createGamepad = (gamepad: Gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = 'vibrationActuator' in gamepad ? gamepad.vibrationActuator : null;\n\n    if (vibrationActuator) hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators) hapticActuators.push(...gamepad.hapticActuators);\n\n    return {\n      ...gamepad,\n      hapticActuators\n    } as Gamepad;\n  };\n\n  const updateGamepadState = () => {\n    for (const gamepad of navigator.getGamepads() ?? []) {\n      if (gamepad && gamepads[gamepad.index]) gamepads[gamepad.index] = createGamepad(gamepad);\n    }\n  };\n\n  const { active } = useRaf(updateGamepadState, {\n    enabled: !!Object.keys(gamepads).length\n  });\n\n  useEffect(() => {\n    if (!supported) return;\n    const gamepads = navigator.getGamepads();\n    setGamepads(\n      gamepads.reduce(\n        (acc, gamepad) => ({\n          ...acc,\n          ...(gamepad && { [gamepad.index]: createGamepad(gamepad) })\n        }),\n        {}\n      )\n    );\n  }, []);\n\n  useEffect(() => {\n    const onConnected = (event: Event) => {\n      const { gamepad } = event as GamepadEvent;\n      setGamepads({ ...gamepads, [gamepad.index]: createGamepad(gamepad) });\n    };\n\n    const onDisconnected = (event: Event) => {\n      const { gamepad } = event as GamepadEvent;\n      const updatedGamepads = { ...gamepads };\n      delete updatedGamepads[gamepad.index];\n      setGamepads(updatedGamepads);\n    };\n\n    document.addEventListener('gamepadconnected', onConnected);\n    document.addEventListener('gamepaddisconnected', onDisconnected);\n\n    return () => {\n      document.removeEventListener('gamepadconnected', onConnected);\n      document.removeEventListener('gamepaddisconnected', onDisconnected);\n    };\n  }, []);\n\n  return {\n    active,\n    supported,\n    gamepads: Object.values(gamepads)\n  };\n};\n\nexport const mapGamepadToXbox360Controller = (gamepad: Gamepad) => ({\n  buttons: {\n    a: gamepad.buttons[0],\n    b: gamepad.buttons[1],\n    x: gamepad.buttons[2],\n    y: gamepad.buttons[3]\n  },\n  bumper: {\n    left: gamepad.buttons[4],\n    right: gamepad.buttons[5]\n  },\n  triggers: {\n    left: gamepad.buttons[6],\n    right: gamepad.buttons[7]\n  },\n  stick: {\n    left: {\n      horizontal: gamepad.axes[0],\n      vertical: gamepad.axes[1],\n      button: gamepad.buttons[10]\n    },\n    right: {\n      horizontal: gamepad.axes[2],\n      vertical: gamepad.axes[3],\n      button: gamepad.buttons[11]\n    }\n  },\n  dpad: {\n    up: gamepad.buttons[12],\n    down: gamepad.buttons[13],\n    left: gamepad.buttons[14],\n    right: gamepad.buttons[15]\n  },\n  back: gamepad.buttons[8],\n  start: gamepad.buttons[9]\n});\n", "import { useEffect, useState } from 'react';\n\n/** The use geolocation return type */\nexport interface UseGeolocationReturn {\n  /** The accuracy of the last position update */\n  accuracy: number | null;\n  /** The altitude of the last position update */\n  altitude: number | null;\n  /** The altitude accuracy of the last position update */\n  altitudeAccuracy: number | null;\n  /** The error of the last position update */\n  error: GeolocationPositionError | null;\n  /** The heading of the last position update */\n  heading: number | null;\n  /** The latitude of the last position update */\n  latitude: number | null;\n  /** The loading state */\n  loading: boolean;\n  /** The longitude of the last position update */\n  longitude: number | null;\n  /** The speed of the last position update */\n  speed: number | null;\n  /** The timestamp of the last position update */\n  timestamp: number | null;\n}\n\n/** The use geolocation params type */\nexport type UseGeolocationParams = PositionOptions;\n\n/**\n * @name useGeolocation\n * @description - Hook that returns the current geolocation\n * @category Browser\n *\n * @browserapi navigator.geolocation https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation\n *\n * @param {boolean} [params.enableHighAccuracy] Enable high accuracy\n * @param {number} [params.maximumAge] Maximum age\n * @param {number} [params.timeout] Timeout\n * @returns {UseGeolocationReturn}\n *\n * @example\n * const { loading, error, timestamp, accuracy, latitude, longitude, altitude, altitudeAccuracy, heading, speed } = useGeolocation();\n */\nexport const useGeolocation = (params?: UseGeolocationParams): UseGeolocationReturn => {\n  const [value, setValue] = useState<UseGeolocationReturn>({\n    loading: true,\n    error: null,\n    timestamp: Date.now(),\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n\n  useEffect(() => {\n    const onEvent = ({ coords, timestamp }: GeolocationPosition) => {\n      setValue({\n        ...value,\n        loading: false,\n        timestamp,\n        latitude: coords.latitude,\n        longitude: coords.longitude,\n        altitude: coords.altitude,\n        accuracy: coords.accuracy,\n        altitudeAccuracy: coords.altitudeAccuracy,\n        heading: coords.heading,\n        speed: coords.speed\n      });\n    };\n\n    const onEventError = (error: GeolocationPositionError) => {\n      setValue({\n        ...value,\n        loading: false,\n        error\n      });\n    };\n\n    navigator.geolocation.getCurrentPosition(onEvent, onEventError, params);\n    const watchId = navigator.geolocation.watchPosition(onEvent, onEventError, params);\n\n    return () => {\n      navigator.geolocation.clearWatch(watchId);\n    };\n  }, [params?.enableHighAccuracy, params?.maximumAge, params?.timeout]);\n\n  return value;\n};\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nexport const timeRangeToArray = (timeRanges: TimeRanges) => {\n  let ranges: [number, number][] = [];\n\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n\n  return ranges;\n};\n\n/** The media source configuration type */\nexport interface UseMediaSource {\n  /** The media attribute of the media */\n  media?: string;\n  /** The source URL of the media */\n  src: string;\n  /** The MIME type of the media */\n  type?: string;\n}\n\n/** The media controls return type */\nexport interface UseMediaControlsReturn {\n  /** Whether the media is currently buffering */\n  buffered: [number, number][];\n  /** The current playback position in seconds */\n  currentTime: number;\n  /** The total duration of the media in seconds */\n  duration: number;\n  /** Whether the media has ended */\n  ended: boolean;\n  /** Whether the media is currently muted */\n  muted: boolean;\n  /** The current playback rate (1.0 is normal speed) */\n  playbackRate: number;\n  /** Whether the media is currently playing */\n  playing: boolean;\n  /** Whether the media is currently seeking */\n  seeking: boolean;\n  /** Whether the media is currently stalled */\n  stalled: boolean;\n  /** The current volume level (0.0 to 1.0) */\n  volume: number;\n  /** Whether the media is currently waiting */\n  waiting: boolean;\n\n  /** Set the playback rate */\n  changePlaybackRate: (rate: number) => void;\n  /** Set the volume level (0.0 to 1.0) */\n  changeVolume: (volume: number) => void;\n  /** Set the muted state */\n  mute: () => void;\n  /** Pause the media */\n  pause: () => void;\n  /** Start playing the media */\n  play: () => Promise<void>;\n  /** Seek to a specific time in seconds */\n  seek: (time: number) => void;\n  /** Toggle between play and pause */\n  toggle: () => Promise<void>;\n  /** Set the unmuted state */\n  unmute: () => void;\n}\n\nexport interface UseMediaControls {\n  (target: HookTarget, src: string): UseMediaControlsReturn;\n\n  (target: HookTarget, options: UseMediaSource): UseMediaControlsReturn;\n\n  <Target extends HTMLMediaElement>(\n    src: string\n  ): UseMediaControlsReturn & {\n    ref: StateRef<Target>;\n  };\n\n  <Target extends HTMLMediaElement>(\n    options: UseMediaSource\n  ): UseMediaControlsReturn & { ref: StateRef<Target> };\n}\n\n/**\n * @name useMediaControls\n * @description Hook that provides controls for HTML media elements (audio/video)\n * @category Browser\n *\n * @overload\n * @param {HookTarget} target The target media element\n * @param {string} src The source URL of the media\n * @returns {UseMediaControlsReturn} An object containing media controls and state\n *\n * @example\n * const { playing, play, pause } = useMediaControls(videoRef, 'video.mp4');\n *\n * @overload\n * @param {HookTarget} target The target media element\n * @param {UseMediaSource} options The media source configuration\n * @returns {UseMediaControlsReturn} An object containing media controls and state\n *\n * @example\n * const { playing, play, pause } = useMediaControls(audioRef, { src: 'audio.mp3', type: 'audio/mp3' });\n *\n * @overload\n * @template Target The target media element type\n * @param {string} src The source URL of the media\n * @returns {UseMediaControlsReturn & { ref: StateRef<Target> }} An object containing media controls, state and ref\n *\n * @example\n * const { ref, playing, play, pause } = useMediaControls<HTMLVideoElement>('video.mp4');\n *\n * @overload\n * @template Target The target media element type\n * @param {UseMediaSource} options The media source configuration\n * @returns {UseMediaControlsReturn & { ref: StateRef<Target> }} An object containing media controls, state and ref\n *\n * @example\n * const { ref, playing, play, pause } = useMediaControls<HTMLVideoElement>({ src: 'video.mp4', type: 'video/mp4' });\n */\nexport const useMediaControls = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { src: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { src: params[0] }\n  ) as UseMediaSource;\n\n  const internalRef = useRefState<HTMLMediaElement>();\n  const elementRef = useRef<HTMLMediaElement | null>(null);\n\n  const [playing, setPlaying] = useState(false);\n  const [duration, setDuration] = useState(0);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [seeking, setSeeking] = useState(false);\n  const [waiting, setWaiting] = useState(false);\n  const [buffered, setBuffered] = useState<[number, number][]>([]);\n  const [stalled, setStalled] = useState(false);\n  const [ended, setEnded] = useState(false);\n  const [playbackRate, setPlaybackRateState] = useState(1);\n\n  const [muted, setMutedState] = useState(false);\n  const [volume, setVolumeState] = useState(1);\n\n  useEffect(() => {\n    const element = (target ? getElement(target) : internalRef.current) as HTMLMediaElement;\n\n    if (!element) return;\n\n    elementRef.current = element;\n    element.src = options.src;\n\n    if (options.type) element.setAttribute('type', options.type);\n    if (options.media) element.setAttribute('media', options.media);\n\n    setDuration(element.duration);\n    setCurrentTime(element.currentTime);\n    setPlaying(false);\n    setEnded(element.ended);\n    setMutedState(element.muted);\n    setVolumeState(element.volume);\n    setPlaybackRateState(element.playbackRate);\n\n    const onPlaying = () => {\n      setPlaying(true);\n      setStalled(false);\n    };\n    const onPause = () => setPlaying(false);\n    const onWaiting = () => setWaiting(true);\n    const onStalled = () => setStalled(true);\n    const onSeeking = () => setSeeking(true);\n    const onSeeked = () => setSeeking(false);\n    const onEnded = () => {\n      setPlaying(false);\n      setEnded(true);\n    };\n    const onDurationChange = () => setDuration(element.duration);\n    const onTimeUpdate = () => setCurrentTime(element.currentTime);\n    const onVolumechange = () => {\n      setMutedState(element.muted);\n      setVolumeState(element.volume);\n    };\n    const onRatechange = () => setPlaybackRateState(element.playbackRate);\n    const onProgress = () => setBuffered(timeRangeToArray(element.buffered));\n\n    element.addEventListener('playing', onPlaying);\n    element.addEventListener('pause', onPause);\n    element.addEventListener('waiting', onWaiting);\n    element.addEventListener('progress', onProgress);\n    element.addEventListener('stalled', onStalled);\n    element.addEventListener('seeking', onSeeking);\n    element.addEventListener('seeked', onSeeked);\n    element.addEventListener('ended', onEnded);\n    element.addEventListener('loadedmetadata', onDurationChange);\n    element.addEventListener('timeupdate', onTimeUpdate);\n    element.addEventListener('volumechange', onVolumechange);\n    element.addEventListener('ratechange', onRatechange);\n\n    return () => {\n      element.removeEventListener('playing', onPlaying);\n      element.removeEventListener('pause', onPause);\n      element.removeEventListener('waiting', onWaiting);\n      element.removeEventListener('progress', onProgress);\n      element.removeEventListener('stalled', onStalled);\n      element.removeEventListener('seeking', onSeeking);\n      element.removeEventListener('seeked', onSeeked);\n      element.removeEventListener('ended', onEnded);\n      element.removeEventListener('loadedmetadata', onDurationChange);\n      element.removeEventListener('timeupdate', onTimeUpdate);\n      element.removeEventListener('volumechange', onVolumechange);\n      element.removeEventListener('ratechange', onRatechange);\n    };\n  }, [target, internalRef.state]);\n\n  const play = async () => {\n    const element = elementRef.current;\n    if (!element) return;\n\n    await element.play();\n  };\n\n  const pause = () => {\n    if (!elementRef.current) return;\n    elementRef.current.pause();\n  };\n\n  const toggle = async () => {\n    if (playing) return pause();\n    return play();\n  };\n\n  const seek = (time: number) => {\n    if (!elementRef.current) return;\n    elementRef.current.currentTime = Math.min(Math.max(time, 0), duration);\n  };\n\n  const changeVolume = (value: number) => {\n    if (!elementRef.current) return;\n    elementRef.current.volume = Math.min(Math.max(value, 0), 1);\n  };\n\n  const mute = () => {\n    if (!elementRef.current) return;\n    elementRef.current.muted = true;\n  };\n\n  const unmute = () => {\n    if (!elementRef.current) return;\n    elementRef.current.muted = false;\n  };\n\n  const changePlaybackRate = (value: number) => {\n    if (!elementRef.current) return;\n    elementRef.current.playbackRate = value;\n  };\n\n  return {\n    playing,\n    duration,\n    currentTime,\n    seeking,\n    waiting,\n    buffered,\n    stalled,\n    ended,\n    playbackRate,\n    muted,\n    volume,\n\n    play,\n    pause,\n    toggle,\n    seek,\n    changeVolume,\n    mute,\n    unmute,\n    changePlaybackRate,\n\n    ...(!target && { ref: internalRef })\n  };\n}) as UseMediaControls;\n", "import { useEffect, useState } from 'react';\n\ndeclare global {\n  interface Performance {\n    memory: {\n      readonly jsHeapSizeLimit: number;\n      readonly totalJSHeapSize: number;\n      readonly usedJSHeapSize: number;\n    };\n  }\n}\n\n/** The use memory return type */\nexport interface UseMemoryReturn {\n  /** The memory supported status */\n  supported: boolean;\n  /** The current memory usage */\n  value: Performance['memory'];\n}\n\n/**\n * @name useMemory\n * @description - Hook that gives you current memory usage\n * @category Browser\n *\n * @browserapi performance.memory https://developer.mozilla.org/en-US/docs/Web/API/Performance/memory\n *\n * @returns {UseMemoryReturn} An object containing the current memory usage\n *\n * @example\n * const { supported, value } = useMemory();\n */\nexport const useMemory = (): UseMemoryReturn => {\n  const supported = performance && 'memory' in performance && !!performance.memory;\n  const [value, setValue] = useState<Performance['memory']>(\n    performance?.memory ?? {\n      jsHeapSizeLimit: 0,\n      totalJSHeapSize: 0,\n      usedJSHeapSize: 0\n    }\n  );\n\n  useEffect(() => {\n    if (!supported) return;\n    const intervalId = setInterval(() => setValue(performance.memory), 1000);\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return { supported, value };\n};\n", "import { useEffect, useState } from 'react';\n\nexport interface Connection extends EventTarget {\n  readonly downlink: number;\n  readonly downlinkMax: number;\n  readonly effectiveType: '2g' | '3g' | '4g' | 'slow-2g';\n  readonly rtt: number;\n  readonly saveData: boolean;\n  onChange: (event: Event) => void;\n  readonly type:\n    | 'bluetooth'\n    | 'cellular'\n    | 'ethernet'\n    | 'mixed'\n    | 'none'\n    | 'other'\n    | 'unknown'\n    | 'wifi'\n    | 'wimax';\n}\n\ndeclare global {\n  interface Navigator {\n    readonly connection: Connection;\n    readonly mozConnection: Connection;\n    readonly webkitConnection: Connection;\n  }\n}\n\n/** The type of network connection */\nexport type ConnectionType = Connection['type'];\n/** The effective type of connection */\nexport type ConnectionEffectiveType = Connection['effectiveType'];\n\n/** The use network return type */\nexport interface UseNetworkReturn {\n  /** The estimated downlink speed in megabits per seconds */\n  downlink?: Connection['downlink'];\n  /** The maximum downlink speed, if available */\n  downlinkMax?: Connection['downlinkMax'];\n  /** The effective type of connection (e.g., '2g', '3g', '4g') */\n  effectiveType?: Connection['effectiveType'];\n  /** Indicates if the device is currently online */\n  online: boolean;\n  /** The estimated round-trip time in milliseconds */\n  rtt?: Connection['rtt'];\n  /** Indicates if the user has enabled data saving mode */\n  saveData?: Connection['saveData'];\n  /** The type of network connection (e.g., 'wifi', 'cellular') */\n  type?: Connection['type'];\n}\n\nexport const getConnection = () =>\n  navigator?.connection || navigator?.mozConnection || navigator?.webkitConnection;\n\n/**\n * @name useNetwork\n * @description - Hook to track network status\n * @category Browser\n *\n * @browserapi navigator.connection https://developer.mozilla.org/en-US/docs/Web/API/Navigator/connection\n *\n * @returns {UseNetworkReturn} An object containing the network status\n *\n * @example\n * const { online, downlink, downlinkMax, effectiveType, rtt, saveData, type } = useNetwork();\n */\nexport const useNetwork = (): UseNetworkReturn => {\n  const [value, setValue] = useState(() => {\n    if (typeof navigator === 'undefined') {\n      return {\n        online: false,\n        type: undefined,\n        effectiveType: undefined,\n        saveData: false,\n        downlink: 0,\n        downlinkMax: 0,\n        rtt: 0\n      };\n    }\n    const online = navigator.onLine;\n    const connection = getConnection();\n\n    return {\n      online,\n      downlink: connection?.downlink,\n      downlinkMax: connection?.downlinkMax,\n      effectiveType: connection?.effectiveType,\n      rtt: connection?.rtt,\n      saveData: connection?.saveData,\n      type: connection?.type\n    };\n  });\n\n  useEffect(() => {\n    const callback = () => {\n      const online = navigator.onLine;\n      const connection = getConnection();\n\n      setValue({\n        online,\n        downlink: connection?.downlink,\n        downlinkMax: connection?.downlinkMax,\n        effectiveType: connection?.effectiveType,\n        rtt: connection?.rtt,\n        saveData: connection?.saveData,\n        type: connection?.type\n      });\n    };\n    window.addEventListener('online', callback, { passive: true });\n    window.addEventListener('offline', callback, { passive: true });\n\n    const connection = getConnection();\n\n    if (connection) {\n      connection.addEventListener('change', callback, { passive: true });\n    }\n\n    return () => {\n      window.removeEventListener('online', callback);\n      window.removeEventListener('offline', callback);\n\n      if (connection) {\n        connection.removeEventListener('change', callback);\n      }\n    };\n  });\n\n  return value;\n};\n", "import { useSyncExternalStore } from 'react';\n\nconst getSnapshot = () => navigator.onLine;\nconst getServerSnapshot = () => false;\nconst subscribe = (callback: () => void) => {\n  window.addEventListener('online', callback);\n  window.addEventListener('offline', callback);\n  return () => {\n    window.removeEventListener('online', callback);\n    window.removeEventListener('offline', callback);\n  };\n};\n\n/**\n * @name useOnline\n * @description - Hook that manages if the user is online\n * @category Browser\n *\n * @browserapi navigator.onLine https://developer.mozilla.org/en-US/docs/Web/API/Navigator/onLine\n *\n * @returns {boolean} A boolean indicating if the user is online\n *\n * @example\n * const online = useOnline();\n */\nexport const useOnline = () => useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n", "import { useRef, useState } from 'react';\n\ndeclare global {\n  interface OTPOptions {\n    readonly transport: string[];\n  }\n\n  interface CredentialRequestOptions {\n    readonly otp: OTPOptions;\n  }\n\n  interface Credential {\n    readonly code: string;\n  }\n}\n\n/* The use otp credential callback type */\nexport type UseOtpCredentialCallback = (otp: Credential | null) => void;\n\n/* The use otp credential options type */\nexport interface UseOtpCredentialParams {\n  /* The callback function to be invoked on error */\n  onError: (error: any) => void;\n  /* The callback function to be invoked on success */\n  onSuccess: (credential: Credential | null) => void;\n}\n\n/* The use otp credential return type */\nexport interface UseOtpCredentialReturn {\n  /* The abort function */\n  abort: AbortController['abort'];\n  /*  The aborted state of the query */\n  aborted: boolean;\n  /* The supported state of the otp credential */\n  supported: boolean;\n  /* The get otp credential function */\n  get: () => Promise<Credential | null>;\n}\n\nexport interface UseOtpCredential {\n  (callback?: UseOtpCredentialCallback): UseOtpCredentialReturn;\n\n  (params?: UseOtpCredentialParams): UseOtpCredentialReturn;\n}\n\n/**\n * @name useOtpCredential\n * @description - Hook that creates an otp credential\n * @category Browser\n *\n * @browserapi navigator.credentials https://developer.mozilla.org/en-US/docs/Web/API/Navigator/credentials\n *\n * @overload\n * @param {UseOtpCredentialCallback} callback The callback function to be invoked\n * @returns {UseOtpCredentialReturn}\n *\n * @example\n * useOtpCredential((credential) => console.log(credential));\n *\n * @overload\n * @param {UseOtpCredentialCallback} params.onSuccess The callback function to be invoked on success\n * @param {UseOtpCredentialCallback} params.onError The callback function to be invoked on error\n * @returns {UseOtpCredentialReturn}\n *\n * @example\n * useOtpCredential({ onSuccess: (credential) => console.log(credential), onError: (error) => console.log(error) });\n */\nexport const useOtpCredential = ((...params: any[]) => {\n  const onSuccess =\n    typeof params[0] === 'function'\n      ? (params[0] as UseOtpCredentialCallback | undefined)\n      : (params[0] as UseOtpCredentialParams | undefined)?.onSuccess;\n\n  const onError =\n    typeof params[0] === 'function'\n      ? (params[0] as UseOtpCredentialParams | undefined)?.onError\n      : undefined;\n\n  const supported = typeof navigator !== 'undefined' && 'OTPCredential' in window;\n  const [aborted, setAborted] = useState(false);\n\n  const abortControllerRef = useRef<AbortController>(new AbortController());\n\n  const get = async () => {\n    if (!supported) return;\n\n    abortControllerRef.current = new AbortController();\n    try {\n      const credential = await navigator.credentials.get({\n        otp: { transport: ['sms'] },\n        signal: abortControllerRef.current.signal\n      });\n      onSuccess?.(credential);\n      setAborted(false);\n      return credential;\n    } catch (error) {\n      onError?.(error);\n    }\n  };\n\n  const abort = () => {\n    abortControllerRef.current.abort();\n    abortControllerRef.current = new AbortController();\n    abortControllerRef.current.signal.onabort = () => setAborted(true);\n  };\n\n  return { supported, abort, aborted, get };\n}) as UseOtpCredential;\n", "import { useEffect, useState } from 'react';\n\nimport { useEvent } from '../useEvent/useEvent';\n\n/** The permission name */\nexport type UsePermissionName =\n  | 'accelerometer'\n  | 'accessibility-events'\n  | 'ambient-light-sensor'\n  | 'background-sync'\n  | 'camera'\n  | 'clipboard-read'\n  | 'clipboard-write'\n  | 'gyroscope'\n  | 'magnetometer'\n  | 'microphone'\n  | 'notifications'\n  | 'payment-handler'\n  | 'persistent-storage'\n  | 'push'\n  | 'speaker'\n  | PermissionName;\n\n/** The use permission options type */\nexport interface UsePermissionOptions {\n  /** Whether the permission is enabled */\n  enabled: boolean;\n}\n\n/** The use permission return type */\nexport interface UsePermissionReturn {\n  /** The permission state */\n  state: PermissionState;\n  /** The permission supported status */\n  supported: boolean;\n  /** The permission query function */\n  query: () => Promise<PermissionState>;\n}\n\n/**\n *  @name usePermission\n *  @description - Hook that gives you the state of permission\n *  @category Browser\n *\n *  @browserapi navigator.permissions https://developer.mozilla.org/en-US/docs/Web/API/Navigator/permissions\n *\n *  @param {UsePermissionName} permissionDescriptorName - The permission name\n *  @param {boolean} [options.enabled=true] - Whether the permission is enabled\n *  @returns {UsePermissionReturn} An object containing the state and the supported status\n *\n *  @example\n *  const { state, supported, query } = usePermission('microphone');\n */\nexport const usePermission = (\n  permissionDescriptorName: UsePermissionName,\n  options?: UsePermissionOptions\n) => {\n  const supported = typeof navigator !== 'undefined' && 'permissions' in navigator;\n  const [state, setState] = useState<PermissionState>('prompt');\n  const enabled = options?.enabled ?? true;\n\n  const permissionDescriptor = { name: permissionDescriptorName };\n\n  const query = useEvent(async () => {\n    try {\n      const permissionStatus = await navigator.permissions.query(\n        permissionDescriptor as PermissionDescriptor\n      );\n      setState(permissionStatus.state);\n      return permissionStatus.state;\n    } catch {\n      setState('prompt');\n      return 'prompt';\n    }\n  });\n\n  useEffect(() => {\n    if (!supported || !enabled) return;\n    query();\n    window.addEventListener('change', query);\n    return () => {\n      window.removeEventListener('change', query);\n    };\n  }, [permissionDescriptorName, enabled]);\n\n  return {\n    state,\n    supported,\n    query\n  };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use picture in picture options type */\nexport interface UsePictureInPictureOptions {\n  /** The callback when Picture-in-Picture mode is entered */\n  onEnter?: () => void;\n  /** The callback when Picture-in-Picture mode is exited */\n  onExit?: () => void;\n}\n\n/** The use picture in picture return type */\nexport interface UsePictureInPictureReturn {\n  /** Whether Picture-in-Picture mode is currently active */\n  open: boolean;\n  /** Whether Picture-in-Picture mode is supported by the browser */\n  supported: boolean;\n  /** Request to enter Picture-in-Picture mode */\n  enter: () => Promise<void>;\n  /** Request to exit Picture-in-Picture mode */\n  exit: () => Promise<void>;\n  /** Toggle Picture-in-Picture mode */\n  toggle: () => Promise<void>;\n}\n\nexport interface UsePictureInPicture {\n  (target: HookTarget, options?: UsePictureInPictureOptions): UsePictureInPictureReturn;\n\n  (options?: UsePictureInPictureOptions): UsePictureInPictureReturn & {\n    ref: StateRef<HTMLVideoElement>;\n  };\n}\n\n/**\n * @name usePictureInPicture\n * @description - Hook that provides Picture-in-Picture functionality for video elements\n * @category Browser\n *\n * @browserapi window.PictureInPicture https://developer.mozilla.org/en-US/docs/Web/API/Picture-in-Picture_API\n *\n * @overload\n * @param {HookTarget} target The target video element\n * @param {() => void} [options.onEnter] Callback when Picture-in-Picture mode is entered\n * @param {() => void} [options.onExit] Callback when Picture-in-Picture mode is exited\n * @returns {UsePictureInPictureReturn} An object containing Picture-in-Picture state and controls\n *\n * @example\n * const { open, supported, enter, exit, toggle } = usePictureInPicture(videoRef);\n *\n * @overload\n * @param {() => void} [options.onEnter] Callback when Picture-in-Picture mode is entered\n * @param {() => void} [options.onExit] Callback when Picture-in-Picture mode is exited\n * @returns {UsePictureInPictureReturn & { ref: StateRef<HTMLVideoElement> }} An object containing Picture-in-Picture state, controls and ref\n *\n * @example\n * const { ref, open, supported, enter, exit, toggle } = usePictureInPicture();\n */\nexport const usePictureInPicture = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = ((target ? params[1] : params[0]) as UsePictureInPictureOptions) ?? {};\n\n  const [open, setOpen] = useState(false);\n\n  const internalRef = useRefState<HTMLVideoElement>();\n  const elementRef = useRef<HTMLVideoElement>(null);\n  const onOptionsRef = useRef<UsePictureInPictureOptions>(options);\n  onOptionsRef.current = options;\n\n  const supported = typeof document !== 'undefined' && 'pictureInPictureEnabled' in document;\n\n  const enter = async () => {\n    if (!supported) return;\n\n    if (!elementRef.current) return;\n\n    await elementRef.current.requestPictureInPicture();\n    setOpen(true);\n\n    options.onEnter?.();\n  };\n\n  const exit = async () => {\n    if (!supported) return;\n\n    await document.exitPictureInPicture();\n    setOpen(false);\n    options.onExit?.();\n  };\n\n  useEffect(() => {\n    const element = target ? (getElement(target) as HTMLVideoElement) : internalRef.current;\n    if (!element) return;\n\n    elementRef.current = element;\n\n    const onEnterPictureInPicture = () => {\n      setOpen(true);\n      onOptionsRef.current.onEnter?.();\n    };\n\n    const onLeavePictureInPicture = () => {\n      setOpen(false);\n      onOptionsRef.current.onExit?.();\n    };\n\n    element.addEventListener('enterpictureinpicture', onEnterPictureInPicture);\n    element.addEventListener('leavepictureinpicture', onLeavePictureInPicture);\n\n    return () => {\n      element.removeEventListener('enterpictureinpicture', onEnterPictureInPicture);\n      element.removeEventListener('leavepictureinpicture', onLeavePictureInPicture);\n    };\n  }, [target]);\n\n  const toggle = async () => {\n    if (open) await exit();\n    else await enter();\n  };\n\n  const value = {\n    open,\n    supported,\n    enter,\n    exit,\n    toggle\n  };\n\n  if (target) return value;\n  return { ...value, ref: internalRef };\n}) as UsePictureInPicture;\n", "import type { MouseEvent } from 'react';\n\nimport { useEffect, useState } from 'react';\n\n/** The use pointer lock return type */\ninterface UsePointerLockReturn {\n  /** The pointer lock element */\n  element?: Element;\n  /** Whether the pointer lock is supported */\n  supported: boolean;\n  /** Lock the pointer lock */\n  lock: (event: MouseEvent) => void;\n  /** Unlock the pointer lock */\n  unlock: () => boolean;\n}\n\n/**\n * @name usePointerLock\n * @description - Hook that provides reactive pointer lock\n * @category Browser\n *\n * @browserapi pointerLockElement https://developer.mozilla.org/en-US/docs/Web/API/Document/pointerLockElement\n *\n * @returns {UsePointerLockReturn} An object containing the pointer lock element and functions to interact with the pointer lock\n *\n * @example\n * const { supported, lock, unlock, element } = usePointerLock();\n */\nexport const usePointerLock = (): UsePointerLockReturn => {\n  const supported = typeof document !== 'undefined' && 'pointerLockElement' in document;\n  const [element, setElement] = useState<Element>();\n\n  useEffect(() => {\n    if (!supported) return;\n\n    const handlePointerLockChange = () => {\n      if (!supported) return;\n\n      const currentElement = document.pointerLockElement ?? element;\n\n      if (currentElement && currentElement === element) {\n        setElement(document.pointerLockElement as Element);\n      }\n    };\n    const handlePointerLockError = () => {\n      if (!supported) return;\n\n      const currentElement = document.pointerLockElement ?? element;\n\n      if (currentElement && currentElement === element) {\n        const action = document.pointerLockElement ? 'release' : 'acquire';\n\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    };\n\n    document.addEventListener('pointerlockchange', handlePointerLockChange);\n    document.addEventListener('pointerlockerror', handlePointerLockError);\n\n    return () => {\n      document.removeEventListener('pointerlockchange', handlePointerLockChange);\n      document.removeEventListener('pointerlockerror', handlePointerLockError);\n    };\n  }, []);\n\n  const lock = (event: MouseEvent) => {\n    if (!supported) return false;\n\n    if (event instanceof Event) return false;\n\n    event.currentTarget.requestPointerLock();\n\n    setElement(event.currentTarget);\n    return true;\n  };\n\n  const unlock = () => {\n    if (!supported) return false;\n\n    if (!element) return false;\n\n    document.exitPointerLock();\n    setElement(undefined);\n\n    return true;\n  };\n\n  return {\n    supported,\n    element,\n    lock,\n    unlock\n  };\n};\n", "import { useEffect, useRef } from 'react';\n\nexport type UsePostMessageReturn<Message> = (message: Message) => void;\n\n/**\n * @name usePostMessage\n * @description - Hook that allows you to receive messages from other origins\n * @category Browser\n *\n * @overload\n * @template Message The message data type\n * @param {string | string[]} origin The origin of the message\n * @param {(message: Message) => Message} callback callback to get received message\n * @returns {(message: Message) => void} An object containing the current message\n *\n * @example\n * const postMessage = usePostMessage();\n */\nexport const usePostMessage = <Message>(\n  origin: string | '*' | string[],\n  callback: (message: Message, event: MessageEvent<Message>) => void\n): UsePostMessageReturn<Message> => {\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  useEffect(() => {\n    const onMessage = (event: MessageEvent<Message>) => {\n      if (\n        (Array.isArray(origin) && (!origin.includes(event.origin) || !origin.includes('*'))) ||\n        (event.origin !== origin && origin !== '*')\n      )\n        return;\n\n      internalCallbackRef.current(event.data as Message, event);\n    };\n\n    window.addEventListener('message', onMessage);\n    return () => window.removeEventListener('message', onMessage);\n  }, []);\n\n  const postMessage = (message: Message) => {\n    if (Array.isArray(origin)) {\n      origin.forEach((origin) => window.postMessage(message, origin));\n      return;\n    }\n\n    window.postMessage(message, origin);\n  };\n\n  return postMessage;\n};\n", "/** The use share options type */\nexport interface UseShareParams {\n  /** Array of files to be shared */\n  files?: File[];\n  /** Text content to be shared */\n  text?: string;\n  /** Title of the content being shared */\n  title?: string;\n  /** URL link to be shared */\n  url?: string;\n}\n\n/** The use share return type */\nexport interface UseShareReturn {\n  /** Whether the Web Share API is supported in the current environment */\n  supported: boolean;\n  /** Function to trigger the native share dialog */\n  trigger: (shareParams: ShareData) => Promise<void>;\n}\n\n/**\n * @name useShare\n * @description - Hook that utilizes the share api\n * @category Browser\n *\n * @browserapi share https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share\n *\n * @param {UseShareParams} [params] The use share options\n * @returns {UseShareReturn}\n *\n * @example\n * const { share, supported } = useShare();\n */\nexport const useShare = (params?: UseShareParams) => {\n  const supported = typeof navigator !== 'undefined' && 'share' in navigator;\n\n  const trigger = async (shareParams: ShareData) => {\n    if (!supported) return;\n\n    const data = {\n      ...params,\n      ...shareParams\n    };\n\n    if (data.files && navigator.canShare({ files: data.files })) navigator.share(data);\n\n    return navigator.share(data);\n  };\n\n  return { trigger, supported };\n};\n", "import { useEffect, useState } from 'react';\n\n/** The use speech recognition hook options type */\ninterface UseSpeechRecognitionOptions {\n  /** If true, recognition continues even after pauses in speech. Default is false */\n  continuous?: SpeechRecognition['continuous'];\n  /** A list of grammar rules */\n  grammars?: SpeechRecognition['grammars'];\n  /** If true, interim (non-final) results are provided as the user speaks */\n  interimResults?: SpeechRecognition['interimResults'];\n  /** The language in which recognition should occur. Must be a valid BCP 47 language tag (e.g., \"en-US\", \"ru-RU\") */\n  language?: SpeechRecognition['lang'];\n  /** The maximum number of alternative transcripts returned for a given recognition result. Must be a positive integer */\n  maxAlternatives?: SpeechRecognition['maxAlternatives'];\n  /** Callback invoked when speech recognition ends */\n  onEnd?: () => void;\n  /** Callback invoked when an error occurs during recognition */\n  onError?: (error: SpeechRecognitionErrorEvent) => void;\n  /** Callback invoked when recognition produces a result */\n  onResult?: (event: SpeechRecognitionEvent) => void;\n  /** Callback invoked when speech recognition starts */\n  onStart?: () => void;\n}\n\n/** The return type of the useSpeechRecognition hook. */\ninterface UseSpeechRecognitionReturn {\n  /** The error state */\n  error: SpeechRecognitionErrorEvent | null;\n  /** The final transcript */\n  final: boolean;\n  /** Whether the hook is currently listening for speech */\n  listening: boolean;\n  /** The speech recognition instance */\n  recognition: SpeechRecognition;\n  /** Whether the current browser supports the Web Speech API */\n  supported: boolean;\n  /** The current transcript */\n  transcript: string;\n  /** Begins speech recognition */\n  start: () => void;\n  /** Ends speech recognition, finalizing results */\n  stop: () => void;\n  /** Toggles the listening state */\n  toggle: (value?: boolean) => void;\n}\n\nexport const getSpeechRecognition = () =>\n  window?.SpeechRecognition ?? window?.webkitSpeechRecognition;\n\n/**\n * @name useSpeechRecognition\n * @description - Hook that provides a streamlined interface for incorporating speech-to-text functionality\n * @category Browser\n *\n * @browserapi window.SpeechRecognition https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition\n *\n * @param {boolean} [options.continuous=false] Whether recognition should continue after pauses\n * @param {boolean} [options.interimResults=false] Whether interim results should be provided\n * @param {string} [options.language=\"en-US\"] The language for recognition, as a valid BCP 47 tag\n * @param {number} [options.maxAlternatives=1] The maximum number of alternative transcripts to return\n * @param {SpeechGrammarList} [options.grammars] A list of grammar rules\n * @param {() => void} [options.onStart] Callback invoked when speech recognition starts\n * @param {() => void} [options.onEnd] Callback invoked when speech recognition ends\n * @param {(error: SpeechRecognitionErrorEvent) => void} [options.onError] Callback invoked when an error occurs during recognition\n * @param {(event: SpeechRecognitionEvent) => void} [options.onResult] Callback invoked when recognition produces a result\n * @returns {UseSpeechRecognitionReturn} An object containing the speech recognition functionality\n *\n * @example\n * const { supported, value, recognition, listening, error, start, stop, toggle  } = useSpeechRecognition();\n */\nexport const useSpeechRecognition = (\n  options: UseSpeechRecognitionOptions = {}\n): UseSpeechRecognitionReturn => {\n  const supported = typeof window !== 'undefined' && !!getSpeechRecognition();\n\n  const {\n    continuous = false,\n    interimResults = false,\n    language = 'en-US',\n    grammars,\n    maxAlternatives = 1,\n    onStart,\n    onEnd,\n    onError,\n    onResult\n  } = options;\n\n  const [listening, setListening] = useState(false);\n  const [transcript, setTranscript] = useState('');\n  const [final, setFinal] = useState(false);\n  const [error, setError] = useState<SpeechRecognitionErrorEvent | null>(null);\n  const [recognition] = useState<SpeechRecognition>(() => {\n    if (!supported) return {} as SpeechRecognition;\n\n    const SpeechRecognition = getSpeechRecognition();\n    const speechRecognition = new SpeechRecognition();\n\n    speechRecognition.continuous = continuous;\n    if (grammars) speechRecognition.grammars = grammars;\n    speechRecognition.interimResults = interimResults;\n    speechRecognition.lang = language;\n    speechRecognition.maxAlternatives = maxAlternatives;\n\n    speechRecognition.onstart = () => {\n      setListening(true);\n      setFinal(false);\n      onStart?.();\n    };\n    speechRecognition.onend = () => {\n      setListening(false);\n      onEnd?.();\n    };\n    speechRecognition.onerror = (event) => {\n      setError(event);\n      setListening(false);\n      onError?.(event);\n    };\n    speechRecognition.onresult = (event) => {\n      console.log('onresult', event);\n      const currentResult = event.results[event.resultIndex];\n      const { transcript } = currentResult[0];\n\n      setTranscript(transcript);\n      setError(null);\n      onResult?.(event);\n    };\n    speechRecognition.onend = () => {\n      setListening(false);\n      speechRecognition.lang = language;\n    };\n\n    return speechRecognition;\n  });\n\n  useEffect(() => () => recognition.stop(), []);\n\n  const start = () => recognition.start();\n  const stop = () => recognition.stop();\n\n  const toggle = (value = !listening) => {\n    if (value) return start();\n    stop();\n  };\n\n  return {\n    supported,\n    transcript,\n    recognition,\n    final,\n    listening,\n    error,\n    start,\n    stop,\n    toggle\n  };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\n/** The use speech synthesis status type */\nexport type UseSpeechSynthesisStatus = 'end' | 'init' | 'pause' | 'play';\n\n/** The use speech synthesis options type */\nexport interface UseSpeechSynthesisOptions {\n  /** Language for SpeechSynthesis */\n  lang?: string;\n  /** Gets and sets the pitch at which the utterance will be spoken at. */\n  pitch?: number;\n  /** Gets and sets the speed at which the utterance will be spoken at. */\n  rate?: number;\n  /** The text to be spoken */\n  text?: string;\n  /** Gets and sets the voice that will be used to speak the utterance. */\n  voice?: SpeechSynthesisVoice | null;\n  /** Gets and sets the volume that the utterance will be spoken at. */\n  volume?: number;\n}\n\n/** The use speech synthesis return type */\nexport interface UseSpeechSynthesisReturn {\n  /** Any error that occurred during speech synthesis. */\n  error: SpeechSynthesisErrorEvent | undefined;\n  /** Indicates if speech is currently playing. */\n  playing: boolean;\n  /** The current status of speech synthesis. */\n  status: UseSpeechSynthesisStatus;\n  /** Indicates if the SpeechSynthesis API is supported in the current environment. */\n  supported: boolean;\n  /** The SpeechSynthesisUtterance instance. */\n  utterance: SpeechSynthesisUtterance | null;\n  /** Function to pause speech synthesis. */\n  pause: () => void;\n  /** Function to resume speech synthesis. */\n  resume: () => void;\n  /** Function to start speech synthesis. */\n  speak: () => void;\n  /** Function to stop speech synthesis. */\n  stop: () => void;\n  /** Function to toggle between play and pause. */\n  toggle: (value?: boolean) => void;\n}\n\n/**\n * @name useSpeechSynthesis\n * @description - Hook that provides speech synthesis functionality\n * @category Browser\n *\n * @browserapi SpeechSynthesis https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis\n *\n * @params {string} [options.text] - The text to be spoken\n * @params {string} [options.lang] - The language to be spoken\n * @params {number} [options.pitch] - The pitch to be spoken\n * @params {number} [options.rate] - The rate to be spoken\n * @params {SpeechSynthesisVoice} [options.voice] - The voice to be spoken\n * @params {number} [options.volume] - The volume to be spoken\n * @returns {UseSpeechSynthesisReturn} An object containing the speech synthesis state and control methods\n *\n * @example\n * const { supported, playing, status, utterance, error, stop, toggle, speak, resume, pause } = useSpeechSynthesis();\n */\nexport const useSpeechSynthesis = (\n  options: UseSpeechSynthesisOptions = {}\n): UseSpeechSynthesisReturn => {\n  const supported = typeof window !== 'undefined' && 'speechSynthesis' in window;\n\n  const { text = '', lang = 'en-US', pitch = 1, rate = 1, voice = null, volume = 1 } = options;\n\n  const [playing, setPlaying] = useState(false);\n  const [status, setStatus] = useState<UseSpeechSynthesisStatus>('init');\n  const [error, setError] = useState<SpeechSynthesisErrorEvent>();\n  const speechSynthesisUtteranceRef = useRef<SpeechSynthesisUtterance | null>(null);\n\n  const bindSpeechSynthesisUtterance = (speechSynthesisUtterance: SpeechSynthesisUtterance) => {\n    speechSynthesisUtterance.lang = lang;\n    speechSynthesisUtterance.pitch = pitch;\n    speechSynthesisUtterance.rate = rate;\n    speechSynthesisUtterance.volume = volume;\n    speechSynthesisUtterance.voice = voice;\n\n    speechSynthesisUtterance.onstart = () => {\n      setPlaying(true);\n      setStatus('play');\n    };\n\n    speechSynthesisUtterance.onpause = () => {\n      setPlaying(false);\n      setStatus('pause');\n    };\n\n    speechSynthesisUtterance.onresume = () => {\n      setPlaying(true);\n      setStatus('play');\n    };\n\n    speechSynthesisUtterance.onend = () => {\n      setPlaying(false);\n      setStatus('end');\n    };\n\n    speechSynthesisUtterance.onerror = (event) => {\n      setPlaying(false);\n      setError(event);\n    };\n  };\n\n  useEffect(() => {\n    if (!supported) return;\n\n    const speechSynthesisUtterance = new SpeechSynthesisUtterance(text);\n    bindSpeechSynthesisUtterance(speechSynthesisUtterance);\n    speechSynthesisUtteranceRef.current = speechSynthesisUtterance;\n\n    return () => {\n      window.speechSynthesis?.cancel();\n    };\n  }, [text, lang, pitch, rate, voice, volume]);\n\n  const speak = (text?: string) => {\n    if (!supported) return;\n\n    if (text) {\n      speechSynthesisUtteranceRef.current = new SpeechSynthesisUtterance(text);\n      bindSpeechSynthesisUtterance(speechSynthesisUtteranceRef.current);\n    }\n\n    window.speechSynthesis?.cancel();\n    if (speechSynthesisUtteranceRef.current)\n      window.speechSynthesis?.speak(speechSynthesisUtteranceRef.current);\n  };\n\n  const stop = () => {\n    if (!supported) return;\n\n    window.speechSynthesis?.cancel();\n    setPlaying(false);\n  };\n\n  const toggle = (value = !playing) => {\n    if (!supported) return;\n\n    if (value) {\n      window.speechSynthesis?.resume();\n    } else {\n      window.speechSynthesis?.pause();\n    }\n    setPlaying(value);\n  };\n\n  const resume = () => {\n    setPlaying(true);\n    window.speechSynthesis?.resume();\n  };\n\n  const pause = () => {\n    setPlaying(false);\n    window.speechSynthesis?.pause();\n  };\n\n  return {\n    supported,\n    playing,\n    status,\n    utterance: speechSynthesisUtteranceRef.current,\n    error,\n\n    stop,\n    toggle,\n    speak,\n    resume,\n    pause\n  };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\n/** The use vibrate pattern type */\nexport type UseVibratePattern = number | number[];\n\n/** The use vibrate return type */\nexport interface UseVibrateReturn {\n  /** The support indicator */\n  supported: boolean;\n  /** The vibrating indicator */\n  vibrating: boolean;\n  /** The pause function */\n  pause: () => void;\n  /** The resume function */\n  resume: () => void;\n  /** The start function */\n  start: (interval: number) => void;\n  /** The vibrate function */\n  trigger: (pattern?: UseVibratePattern) => void;\n}\n\n/**\n * @name useVibrate\n * @description - Hook that provides vibrate api\n * @category Browser\n *\n * @browserapi navigator.vibrate https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate\n *\n * @overload\n * @param {UseVibratePattern} options.pattern The pattern for vibration\n * @param {number} [options.interval=0] Time in milliseconds between vibrations\n * @returns {UseVibrateReturn} An object containing support indicator, start vibration and stop vibration functions\n *\n * @example\n * const { supported, active, vibrate, stop, pause, resume } = useVibrate(1000);\n */\nexport const useVibrate = (pattern: UseVibratePattern, interval: number = 0) => {\n  const supported = typeof navigator !== 'undefined' && 'vibrate' in navigator;\n\n  const intervalIdRef = useRef<ReturnType<typeof setInterval>>(undefined);\n  const [active, setActive] = useState(false);\n\n  const trigger = (internalPattern: UseVibratePattern = pattern) => {\n    if (!supported) return;\n    navigator.vibrate(internalPattern);\n  };\n\n  const stop = () => {\n    if (!supported) return;\n    navigator.vibrate(0);\n    setActive(false);\n    if (intervalIdRef.current) clearInterval(intervalIdRef.current);\n  };\n\n  const pause = () => {\n    if (!supported) return;\n    setActive(false);\n    if (intervalIdRef.current) clearInterval(intervalIdRef.current);\n  };\n\n  const resume = (intervalInterval: number = interval) => {\n    if (!supported) return;\n    if (intervalIdRef.current) clearInterval(intervalIdRef.current);\n    setActive(true);\n    intervalIdRef.current = setInterval(trigger, intervalInterval);\n  };\n\n  useEffect(() => {\n    if (!supported || interval <= 0) return;\n    resume(interval);\n    return () => {\n      stop();\n    };\n  }, [interval, pattern]);\n\n  return { supported, trigger, stop, active, pause, resume };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\n/** The use wake lock options type */\nexport interface UseWakeLockOptions {\n  /** Determines if the wake lock should be automatically reacquired when the document becomes visible. */\n  immediately?: boolean;\n  /** A string specifying the screen wake lock type. */\n  type?: WakeLockType;\n}\n\n/** The use wake lock return type */\nexport interface UseWakeLockReturn {\n  /** Indicates if the wake lock is currently active. */\n  active: boolean;\n  /** Indicates if the Wake Lock API is supported in the current environment. */\n  supported: boolean;\n  /** Function to release the wake lock. */\n  release: () => Promise<void>;\n  /** Function to request the wake lock. */\n  request: () => Promise<void>;\n}\n\n/**\n * @name useWakeLock\n * @description - Hook that provides a wake lock functionality\n * @category Browser\n *\n * @browserapi navigator.wakeLock https://developer.mozilla.org/en-US/docs/Web/API/WakeLock\n *\n * @param {immediately} [options] Configuration options for the hook.\n * @returns {UseWakeLockReturn} An object containing the wake lock state and control methods.\n *\n * @example\n * const { supported, active, request, release } = useWakeLock();\n */\nexport const useWakeLock = (options?: UseWakeLockOptions): UseWakeLockReturn => {\n  const supported = typeof navigator !== 'undefined' && 'wakeLock' in navigator;\n\n  const [active, setActive] = useState(false);\n  const sentinel = useRef<WakeLockSentinel>(undefined);\n\n  const immediately = options?.immediately ?? false;\n  const type = options?.type ?? 'screen';\n\n  const request = async (type?: WakeLockType) => {\n    if (!supported) return;\n\n    sentinel.current = await navigator.wakeLock.request(type ?? options?.type);\n    sentinel.current.addEventListener('release', () => {\n      setActive(false);\n      sentinel.current = undefined;\n    });\n\n    setActive(true);\n  };\n\n  const release = async () => {\n    if (!supported || !sentinel.current) return;\n\n    await sentinel.current.release();\n    sentinel.current = undefined;\n    setActive(false);\n  };\n\n  useEffect(() => {\n    if (!supported || !immediately || document.visibilityState !== 'visible' || type !== 'screen')\n      return;\n\n    const onVisibilityChange = async () => {\n      await release();\n      await request(type);\n    };\n\n    document.addEventListener('visibilitychange', onVisibilityChange);\n    return () => {\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n    };\n  }, [type]);\n\n  return { supported, active, request, release };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\nimport { getRetry } from '@/utils/helpers';\n\nimport { useEvent } from '../useEvent/useEvent';\n\nexport type UseWebSocketUrl = (() => string) | string;\n\nexport interface UseWebSocketOptions {\n  protocols?: Array<'soap' | 'wasm'>;\n  retry?: boolean | number;\n  onConnected?: (webSocket: WebSocket) => void;\n  onDisconnected?: (event: CloseEvent, webSocket: WebSocket) => void;\n  onError?: (event: Event, webSocket: WebSocket) => void;\n  onMessage?: (event: MessageEvent, webSocket: WebSocket) => void;\n}\n\nexport type UseWebSocketStatus = 'connected' | 'connecting' | 'disconnected' | 'failed';\n\nexport interface UseWebSocketReturn {\n  client?: WebSocket;\n  close: WebSocket['close'];\n  send: WebSocket['send'];\n  status: UseWebSocketStatus;\n  open: () => void;\n}\n\n/**\n * @name useWebSocket\n * @description - Hook that connects to a WebSocket server and handles incoming and outgoing messages\n * @category Browser\n *\n * @param {UseWebSocketUrl} url The URL of the WebSocket server\n * @param {(webSocket: WebSocket) => void} [options.onConnected] The callback function that is called when the WebSocket connection is established\n * @param {(event: CloseEvent, webSocket: WebSocket) => void} [options.onDisconnected] The callback function that is called when the WebSocket connection is closed\n * @param {(event: Event, webSocket: WebSocket) => void} [options.onError] The callback function that is called when an error occurs\n * @param {(event: MessageEvent, webSocket: WebSocket) => void} [options.onMessage] The callback function that is called when a message is received\n * @param {boolean | number} [options.retry] The number of times to retry the connection\n * @param {Array<'soap' | 'wasm'>} [options.protocols] The list of protocols to use\n * @returns {UseWebSocketReturn} An object with the status, close, send, open, and ws properties\n *\n * @example\n * const { status, close, send, open, client } = useWebSocket('url');\n */\nexport const useWebSocket = (\n  url: UseWebSocketUrl,\n  options?: UseWebSocketOptions\n): UseWebSocketReturn => {\n  const webSocketRef = useRef<WebSocket>(undefined);\n  const retryCountRef = useRef(options?.retry ? getRetry(options.retry) : 0);\n  const explicityCloseRef = useRef(false);\n\n  const [status, setStatus] = useState<UseWebSocketStatus>('connecting');\n\n  const send = (data: string | ArrayBufferLike | ArrayBufferView | Blob) =>\n    webSocketRef.current?.send(data);\n\n  const close = () => {\n    explicityCloseRef.current = true;\n    webSocketRef.current?.close();\n  };\n\n  const init = useEvent(() => {\n    webSocketRef.current = new WebSocket(\n      typeof url === 'function' ? url() : url,\n      options?.protocols\n    );\n    setStatus('connecting');\n\n    const webSocket = webSocketRef.current;\n    if (!webSocket) return;\n\n    webSocket.onopen = () => {\n      setStatus('connected');\n      options?.onConnected?.(webSocket);\n    };\n\n    webSocket.onerror = (event) => {\n      setStatus('failed');\n      options?.onError?.(event, webSocket);\n    };\n\n    webSocket.onmessage = (event) => options?.onMessage?.(event, webSocket);\n\n    webSocket.onclose = (event) => {\n      setStatus('disconnected');\n      options?.onDisconnected?.(event, webSocket);\n      if (explicityCloseRef.current) return;\n\n      if (retryCountRef.current > 0) {\n        retryCountRef.current -= 1;\n        return init();\n      }\n      retryCountRef.current = options?.retry ? getRetry(options.retry) : 0;\n    };\n  });\n\n  useEffect(() => {\n    init();\n\n    return () => {\n      if (!webSocketRef.current) return;\n      webSocketRef.current.close();\n      webSocketRef.current = undefined;\n    };\n  }, [url]);\n\n  const open = () => {\n    explicityCloseRef.current = false;\n    init();\n  };\n\n  return { client: webSocketRef.current, close, open, send, status };\n};\n", "import { useEffect } from 'react';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\n\n/**\n * @name useLogger\n * @description - Hook for debugging lifecycle\n * @category Debug\n *\n * @param {string} name The name or identifier for the logger\n * @param {unknown[]} params Additional arguments to be logged\n *\n * @example\n * useLogger('Component', [1, 2, 3]);\n */\nexport const useLogger = (name: string, params: unknown[]) => {\n  useEffect(() => {\n    console.log(`${name} mounted`, ...params);\n    return () => console.log(`${name} unmounted`);\n  }, []);\n\n  useDidUpdate(() => {\n    console.log(`${name} updated`, ...params);\n  }, params);\n};\n", "import { useEffect, useRef } from 'react';\n\n/**\n * @name useRenderCount\n * @description - Hook returns count component render times\n * @category Debug\n *\n * @returns {number} A number which determines how many times component renders\n *\n * @example\n * const renderCount = useRenderCount();\n */\nexport const useRenderCount = () => {\n  const renderCountRef = useRef(0);\n\n  useEffect(() => {\n    renderCountRef.current += 1;\n  });\n\n  return renderCountRef.current;\n};\n", "import { useRef } from 'react';\n\n/** The use render info return type */\nexport interface UseRenderInfoReturn {\n  /** The name of the component */\n  component: string;\n  /** The number of renders */\n  renders: number;\n  /** The time since the last render */\n  sinceLast: number;\n  /** The timestamp of the render */\n  timestamp: number | null;\n}\n\n/**\n * @name useRenderInfo\n * @description - Hook for getting information about component rerender\n * @category Debug\n *\n * @param {string} [name='Unknown'] Component name\n * @param {boolean} [log=true] Toggle logging\n * @returns {UseRenderInfoReturn} An object containing rerender information\n *\n * @example\n * const rerenderInfo = useRenderInfo('Component');\n */\nexport const useRenderInfo = (name: string = 'Unknown', log: boolean = true) => {\n  const renderInfoRef = useRef<UseRenderInfoReturn>({\n    component: name,\n    renders: 0,\n    timestamp: Date.now(),\n    sinceLast: 0\n  });\n  const now = Date.now();\n\n  renderInfoRef.current.renders += 1;\n  renderInfoRef.current.sinceLast = renderInfoRef.current.timestamp\n    ? now - renderInfoRef.current.timestamp\n    : 0;\n  renderInfoRef.current.timestamp = now;\n\n  if (log) {\n    console.group(`${name} info, render number: ${renderInfoRef.current.renders}`);\n    console.log(`Timestamp: ${renderInfoRef.current.timestamp}`);\n    console.log(`Since last render: ${renderInfoRef.current.sinceLast}`);\n    console.log(`Renders: ${renderInfoRef.current.renders}`);\n    console.dir(renderInfoRef.current);\n    console.groupEnd();\n  }\n\n  return renderInfoRef.current;\n};\n", "import { useReducer } from 'react';\n\n/** The use rerender return type */\ntype UseRerenderReturn = () => void;\n\n/**\n * @name useRerender\n * @description - Hook that defines the logic to force rerender a component\n * @category Debug\n *\n * @returns {UseRerenderReturn} The rerender function\n *\n * @example\n * const rerender = useRerender();\n */\nexport const useRerender = (): UseRerenderReturn => useReducer(() => ({}), {})[1];\n", "import { useEffect, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nexport interface UseActiveElement {\n  (): HTMLElement | null;\n\n  <Target extends Element, ActiveElement extends HTMLElement = HTMLElement>(\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n    value: ActiveElement | null;\n  };\n\n  <ActiveElement extends HTMLElement = HTMLElement>(target: HookTarget): ActiveElement | null;\n}\n\n/**\n * @name useActiveElement\n * @description - Hook that returns the active element\n * @category Elements\n *\n * @overload\n * @param {HookTarget} [target=window] The target element to observe active element changes\n * @returns {ActiveElement | null} The active element\n *\n * @example\n * const activeElement = useActiveElement(ref);\n *\n * @overload\n * @template ActiveElement The active element type\n * @returns {{ ref: StateRef<Element>; activeElement: ActiveElement | null }} An object containing the ref and active element\n *\n * @example\n * const { ref, value } = useActiveElement();\n *\n * @see {@link https://siberiacancode.github.io/reactuse/functions/hooks/useActiveElement.html}\n */\nexport const useActiveElement = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n\n  const [value, setValue] = useState<HTMLElement | null>(null);\n  const internalRef = useRefState(window);\n\n  useEffect(() => {\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n\n    if (!element) return;\n\n    const observer = new MutationObserver((mutations) => {\n      mutations\n        .filter((mutation) => mutation.removedNodes.length)\n        .map((mutation) => Array.from(mutation.removedNodes))\n        .flat()\n        .forEach((node) => {\n          setValue((prevActiveElement) => {\n            if (node === prevActiveElement) return document.activeElement as HTMLElement | null;\n            return prevActiveElement;\n          });\n        });\n    });\n\n    observer.observe(element, {\n      childList: true,\n      subtree: true\n    });\n\n    const onActiveElementChange = () => setValue(document?.activeElement as HTMLElement | null);\n\n    element.addEventListener('focus', onActiveElementChange, true);\n    element.addEventListener('blur', onActiveElementChange, true);\n\n    return () => {\n      observer.disconnect();\n      element.removeEventListener('focus', onActiveElementChange, true);\n      element.removeEventListener('blur', onActiveElementChange, true);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return value;\n  return {\n    ref: internalRef,\n    value\n  };\n}) as UseActiveElement;\n", "import { useEffect, useRef } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use auto scroll options type */\nexport interface UseAutoScrollOptions {\n  /** Whether auto-scrolling is enabled */\n  enabled?: boolean;\n  /** Whether to force auto-scrolling regardless of user interactions */\n  force?: boolean;\n}\n\nexport interface UseAutoScroll {\n  (target: HookTarget, options?: UseAutoScrollOptions): void;\n\n  <Target extends HTMLElement>(options?: UseAutoScrollOptions): StateRef<Target>;\n}\n\n/**\n * @name useAutoScroll\n * @description - Hook that automatically scrolls a list element to the bottom\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to auto-scroll\n * @param {boolean} [options.enabled] Whether auto-scrolling is enabled\n * @returns {void}\n *\n * @example\n * useAutoScroll(ref);\n *\n * @overload\n * @template Target\n * @param {boolean} [options.enabled] Whether auto-scrolling is enabled\n * @returns {StateRef<Target>} A React ref to attach to the list element\n *\n * @example\n * const ref = useAutoScroll();\n */\nexport const useAutoScroll = ((...params: any[]) => {\n  const target = isTarget(params[0]) ? params[0] : undefined;\n  const options = (params[1] ||\n    (typeof params[0] === 'object' ? params[0] : {})) as UseAutoScrollOptions;\n  const { enabled = true } = options;\n\n  const internalRef = useRefState<HTMLElement>();\n  const internalOptionsRef = useRef<UseAutoScrollOptions>(options);\n  internalOptionsRef.current = options;\n\n  useEffect(() => {\n    if (!enabled || (!target && !internalRef.state)) return;\n\n    const element = (target ? getElement(target) : internalRef.state) as HTMLElement;\n\n    if (!element) return;\n\n    let shouldAutoScroll = true;\n    let touchStartY = 0;\n    let lastScrollTop = 0;\n\n    const onCheckScrollPosition = () => {\n      if (internalOptionsRef.current.force) return;\n\n      const { scrollHeight, clientHeight, scrollTop } = element;\n      const maxScrollHeight = scrollHeight - clientHeight;\n      const scrollThreshold = maxScrollHeight / 2;\n      console.log(\n        maxScrollHeight,\n        scrollTop,\n        scrollThreshold,\n        scrollTop < lastScrollTop,\n        maxScrollHeight - scrollTop <= scrollThreshold\n      );\n\n      if (scrollTop < lastScrollTop) shouldAutoScroll = false;\n      else if (maxScrollHeight - scrollTop <= scrollThreshold) shouldAutoScroll = true;\n\n      lastScrollTop = scrollTop;\n    };\n\n    const onWheel = (event: WheelEvent) => {\n      if (internalOptionsRef.current.force) return;\n\n      if (event.deltaY < 0) shouldAutoScroll = false;\n      else onCheckScrollPosition();\n    };\n\n    const onTouchStart = (event: TouchEvent) => {\n      if (internalOptionsRef.current.force) return;\n      touchStartY = event.touches[0].clientY;\n    };\n\n    const onTouchMove = (event: TouchEvent) => {\n      if (internalOptionsRef.current.force) return;\n\n      const touchEndY = event.touches[0].clientY;\n      const deltaY = touchStartY - touchEndY;\n\n      if (deltaY < 0) shouldAutoScroll = false;\n      else onCheckScrollPosition();\n\n      touchStartY = touchEndY;\n    };\n\n    const onMutation = () => {\n      if (!shouldAutoScroll && !internalOptionsRef.current.force) return;\n      element.scrollTo({ top: element.scrollHeight });\n    };\n\n    element.addEventListener('wheel', onWheel);\n    element.addEventListener('touchstart', onTouchStart);\n    element.addEventListener('touchmove', onTouchMove);\n\n    const observer = new MutationObserver(onMutation);\n\n    observer.observe(element, {\n      childList: true,\n      subtree: true,\n      characterData: true\n    });\n\n    return () => {\n      observer.disconnect();\n      element.removeEventListener('wheel', onWheel);\n      element.removeEventListener('touchstart', onTouchStart);\n      element.removeEventListener('touchmove', onTouchMove);\n    };\n  }, [enabled, target, internalRef.state]);\n\n  if (target) return;\n  return internalRef;\n}) as UseAutoScroll;\n", "import { useEffect, useRef } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nexport interface UseClickOutside {\n  (target: HookTarget, callback: (event: Event) => void): void;\n\n  <Target extends Element>(callback: (event: Event) => void, target?: never): StateRef<Target>;\n}\n\n/**\n * @name useClickOutside\n * @description - Hook to handle click events outside the specified target element(s)\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element(s) to detect outside clicks for\n * @param {(event: Event) => void} callback The callback to execute when a click outside the target is detected\n * @returns {void}\n *\n * @example\n * useClickOutside(ref, () => console.log('click outside'));\n *\n * @overload\n * @template Target The target element(s)\n * @param {(event: Event) => void} callback The callback to execute when a click outside the target is detected\n * @returns {(node: Target) => void} A React ref to attach to the target element\n *\n * @example\n * const ref = useClickOutside<HTMLDivElement>(() => console.log('click outside'));\n *\n * @see {@link https://siberiacancode.github.io/reactuse/functions/hooks/useClickOutside.html}\n */\nexport const useClickOutside = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const callback = (params[1] ? params[1] : params[0]) as (event: Event) => void;\n\n  const internalRef = useRefState<Element>();\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n    const onClick = (event: Event) => {\n      const element = (target ? getElement(target) : internalRef.current) as Element;\n\n      if (element && !element.contains(event.target as Node)) {\n        internalCallbackRef.current(event);\n      }\n    };\n\n    document.addEventListener('click', onClick);\n\n    return () => {\n      document.removeEventListener('click', onClick);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return;\n  return internalRef;\n}) as UseClickOutside;\n", "import { useEffect, useRef } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nexport type DoubleClickEvents = MouseEvent | TouchEvent;\n\n/** The use double click options type */\nexport interface UseDoubleClickOptions {\n  /** The threshold time in milliseconds between clicks */\n  threshold?: number;\n  /** The callback function to be invoked on single click */\n  onSingleClick?: (event: DoubleClickEvents) => void;\n}\n\nexport interface UseDoubleClick {\n  (\n    target: HookTarget,\n    callback: (event: DoubleClickEvents) => void,\n    options?: UseDoubleClickOptions\n  ): boolean;\n\n  <Target extends Element>(\n    callback: (event: DoubleClickEvents) => void,\n    options?: UseDoubleClickOptions,\n    target?: never\n  ): StateRef<Target>;\n}\n\nexport const DEFAULT_THRESHOLD_TIME = 300;\n\n/**\n * @name useDoubleClick\n * @description - Hook that defines the logic when double clicking an element\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to be double clicked\n * @param {(event: DoubleClickEvents) => void} callback The callback function to be invoked on double click\n * @param {UseDoubleClickOptions} [options] The options for the double click\n * @returns {boolean} The double clicking state\n *\n * @example\n * useDoubleClick(ref, () => console.log('double clicked'));\n *\n * @overload\n * @template Target The target element\n * @param {(event: DoubleClickEvents) => void} callback The callback function to be invoked on double click\n * @param {UseDoubleClickOptions} [options] The options for the double click\n * @returns {boolean} The double clicking state\n *\n * @example\n * const ref = useDoubleClick(() => console.log('double clicked'));\n *\n * @see {@link https://siberiacancode.github.io/reactuse/functions/hooks/useDoubleClick.html}\n */\nexport const useDoubleClick = ((...params: any[]): any => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const callback = (target ? params[1] : params[0]) as (event: DoubleClickEvents) => void;\n  const options = (target ? params[2] : params[1]) as UseDoubleClickOptions | undefined;\n\n  const timeoutIdRef = useRef<ReturnType<typeof setTimeout>>(undefined);\n  const clickCountRef = useRef(0);\n  const internalRef = useRefState<Element>();\n\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = target ? getElement(target) : internalRef.current;\n    if (!element) return;\n\n    const onClick = (event: DoubleClickEvents) => {\n      clickCountRef.current += 1;\n\n      if (clickCountRef.current === 1) {\n        timeoutIdRef.current = setTimeout(() => {\n          if (internalOptionsRef.current?.onSingleClick)\n            internalOptionsRef.current.onSingleClick(event);\n          clickCountRef.current = 0;\n        }, internalOptionsRef.current?.threshold ?? DEFAULT_THRESHOLD_TIME);\n      }\n\n      if (clickCountRef.current === 2) {\n        clearTimeout(timeoutIdRef.current);\n        internalCallbackRef.current(event);\n        clickCountRef.current = 0;\n      }\n    };\n\n    element.addEventListener('mousedown', onClick as EventListener);\n    element.addEventListener('touchstart', onClick as EventListener);\n\n    return () => {\n      element.removeEventListener('mousedown', onClick as EventListener);\n      element.removeEventListener('touchstart', onClick as EventListener);\n      if (timeoutIdRef.current) clearTimeout(timeoutIdRef.current);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return;\n  return internalRef;\n}) as UseDoubleClick;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nexport type DropZoneDataTypes = ((types: string[]) => boolean) | string[];\n\nexport interface UseDropZoneOptions {\n  /** The data types for drop zone */\n  dataTypes?: DropZoneDataTypes;\n  /** The multiple mode for drop zone */\n  multiple?: boolean;\n  /** The on drop callback */\n  onDrop?: (files: File[] | null, event: DragEvent) => void;\n  /** The on enter callback */\n  onEnter?: (event: DragEvent) => void;\n  /** The on leave callback */\n  onLeave?: (event: DragEvent) => void;\n  /** The on over callback */\n  onOver?: (event: DragEvent) => void;\n}\n\nexport interface UseDropZoneReturn {\n  /** The files that was dropped in drop zone */\n  files: File[] | null;\n  /** The over drop zone status */\n  overed: boolean;\n}\n\nexport interface UseDropZone {\n  (\n    target: HookTarget,\n    callback?: (files: File[] | null, event: DragEvent) => void\n  ): UseDropZoneReturn;\n\n  <Target extends Element>(\n    callback?: (files: File[] | null, event: DragEvent) => void,\n    target?: never\n  ): UseDropZoneReturn & {\n    ref: StateRef<Target>;\n  };\n\n  (target: HookTarget, options?: UseDropZoneOptions): UseDropZoneReturn;\n\n  <Target extends Element>(\n    options?: UseDropZoneOptions,\n    target?: never\n  ): UseDropZoneReturn & {\n    ref: StateRef<Target>;\n  };\n}\n\n/**\n * @name useDropZone\n * @description - Hook that provides drop zone functionality\n * @category Elements\n *\n * @overload\n * @template Target The target element\n * @param {Target} target The target element drop zone's\n * @param {DataTypes} [options.dataTypes] The data types\n * @param {boolean} [options.multiple] The multiple mode\n * @param {(files: File[] | null, event: DragEvent) => void} [options.onDrop] The on drop callback function\n * @param {(event: DragEvent) => void} [options.onEnter] The on enter callback function\n * @param {(event: DragEvent) => void} [options.onLeave] The on leave callback function\n * @param {(event: DragEvent) => void} [options.onOver] The on over callback function\n * @returns {UseDropZoneReturn} The object with drop zone states\n *\n * @example\n * const { overed, files } = useDropZone(ref, options);\n *\n * @overload\n * @param {Target} target The target element drop zone's\n * @param {(files: File[] | null, event: DragEvent) => void} [callback] The callback function to be invoked on drop\n * @returns {UseDropZoneReturn} The object with drop zone states\n *\n * @example\n * const { overed, files } = useDropZone(ref, () => console.log('callback'));\n *\n * @overload\n * @param {DataTypes} [options.dataTypes] The data types\n * @param {boolean} [options.multiple] The multiple mode\n * @param {(files: File[] | null, event: DragEvent) => void} [options.onDrop] The on drop callback function\n * @param {(event: DragEvent) => void} [options.onEnter] The on enter callback function\n * @param {(event: DragEvent) => void} [options.onLeave] The on leave callback function\n * @param {(event: DragEvent) => void} [options.onOver] The on over callback function\n * @returns {UseDropZoneReturn & { ref: StateRef<Target> }} The object with drop zone states and ref\n *\n * @example\n * const { ref, overed, files } = useDropZone(options);\n *\n * @overload\n * @param {(files: File[] | null, event: DragEvent) => void} [callback] The callback function to be invoked on drop\n * @returns {UseDropZoneReturn & { ref: StateRef<Target> }} The object with drop zone states and ref\n *\n * @example\n * const { ref, overed, files } = useDropZone(() => console.log('callback'));\n */\n\nexport const useDropZone = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { onDrop: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { onDrop: params[0] }\n  ) as UseDropZoneOptions;\n\n  const internalRef = useRefState<Element>();\n\n  const counterRef = useRef(0);\n  const [files, setFiles] = useState<File[] | null>(null);\n  const [overed, setOvered] = useState(false);\n\n  const dataTypes = options.dataTypes;\n\n  const getFiles = (event: DragEvent) => {\n    if (!event.dataTransfer) return null;\n    const list = Array.from(event.dataTransfer.files);\n    if (options.multiple) return list;\n    if (!list.length) return null;\n    return [list[0]];\n  };\n\n  const checkDataTypes = (types: string[]) => {\n    if (!dataTypes) return true;\n    if (typeof dataTypes === 'function') return dataTypes(types);\n    if (!dataTypes.length) return true;\n    if (!types.length) return false;\n\n    return types.every((type) => {\n      console.log('type', type);\n      console.log('dataTypes', dataTypes);\n      return dataTypes.some((dataType) => type.includes(dataType));\n    });\n  };\n\n  const checkValidity = (items: DataTransferItemList) => {\n    const types = Array.from(items).map((item) => item.type);\n    const dataTypesValid = checkDataTypes(types);\n    const multipleFilesValid = options.multiple || items.length <= 1;\n\n    return dataTypesValid && multipleFilesValid;\n  };\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = target ? getElement(target) : internalRef.current;\n\n    if (!element) return;\n\n    const onEvent = (event: DragEvent, type: 'drop' | 'enter' | 'leave' | 'over') => {\n      if (!event.dataTransfer) return;\n\n      const isValid = checkValidity(event.dataTransfer.items);\n      if (!isValid) {\n        event.dataTransfer.dropEffect = 'none';\n        return;\n      }\n\n      event.preventDefault();\n      event.dataTransfer.dropEffect = 'copy';\n\n      const currentFiles = getFiles(event);\n\n      if (type === 'drop') {\n        counterRef.current = 0;\n        setOvered(false);\n        setFiles(currentFiles);\n        options.onDrop?.(currentFiles, event);\n        return;\n      }\n\n      if (type === 'enter') {\n        counterRef.current += 1;\n        setOvered(true);\n        options.onEnter?.(event);\n        return;\n      }\n\n      if (type === 'leave') {\n        counterRef.current -= 1;\n        if (counterRef.current !== 0) return;\n        setOvered(false);\n        options.onLeave?.(event);\n        return;\n      }\n\n      if (type === 'over') options.onOver?.(event);\n    };\n\n    const onDrop = ((event: DragEvent) => onEvent(event, 'drop')) as EventListener;\n    const onDragOver = ((event: DragEvent) => onEvent(event, 'over')) as EventListener;\n    const onDragEnter = ((event: DragEvent) => onEvent(event, 'enter')) as EventListener;\n    const onDragLeave = ((event: DragEvent) => onEvent(event, 'leave')) as EventListener;\n\n    element.addEventListener('dragenter', onDragEnter);\n    element.addEventListener('dragover', onDragOver);\n    element.addEventListener('dragleave', onDragLeave);\n    element.addEventListener('drop', onDrop);\n\n    return () => {\n      element.removeEventListener('dragenter', onDragEnter);\n      element.removeEventListener('dragover', onDragOver);\n      element.removeEventListener('dragleave', onDragLeave);\n      element.removeEventListener('drop', onDrop);\n    };\n  }, [target, internalRef.current]);\n\n  if (target) return { overed, files };\n  return { ref: internalRef, overed, files };\n}) as UseDropZone;\n", "import type { ComponentProps } from 'react';\n\nimport { useEffect, useRef, useState } from 'react';\n\n/* The use file dialog options */\nexport interface UseFileDialogOptions extends Pick<ComponentProps<'input'>, 'accept' | 'multiple'> {\n  /** The capture value */\n  capture?: string;\n  /** The reset value */\n  reset?: boolean;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: '*',\n  reset: false\n} satisfies UseFileDialogOptions;\n\n/* The use file dialog return type */\nexport interface UseFileDialogReturn {\n  /** The selected files */\n  value: FileList | null;\n  /** The open function */\n  open: (openParams?: UseFileDialogOptions) => void;\n  /** The reset function */\n  reset: () => void;\n}\n\nexport interface UseFileDialog {\n  (\n    callback?: (value: FileList | null) => void,\n    options?: UseFileDialogOptions\n  ): UseFileDialogReturn;\n\n  (options?: UseFileDialogOptions, callback?: never): UseFileDialogReturn;\n}\n\n/**\n * @name useFileDialog\n * @description - Hook to handle file input\n * @category Elements\n *\n * @overload\n * @param {(value: FileList | null) => void} callback The callback to execute when a file is selected\n * @param {boolean} [options.multiple=true] Whether multiple files can be selected\n * @param {string} [options.accept='*'] The accepted file types\n * @param {boolean} [options.reset=false] Whether the input should be reset when the callback is called\n * @param {string} [options.capture] The capture value\n * @returns {UseFileDialogReturn} An object containing the selected files\n *\n * @example\n * const { values, open, reset } = useFileDialog((value) => console.log(value));\n *\n * @overload\n * @param {boolean} [options.multiple=true] Whether multiple files can be selected\n * @param {string} [options.accept='*'] The accepted file types\n * @param {boolean} [options.reset=false] Whether the input should be reset when the callback is called\n * @param {string} [options.capture] The capture value\n * @returns {UseFileDialogReturn} An object containing the selected files\n *\n * @example\n * const { values, open, reset } = useFileDialog({ accept: 'image/*' });\n */\nexport const useFileDialog = ((...params: any[]) => {\n  const callback = (typeof params[0] === 'function' ? params[0] : undefined) as\n    | ((value: FileList | null) => void)\n    | undefined;\n  const options = (callback ? params[0] : params[1]) as UseFileDialogOptions | undefined;\n\n  const [value, setValue] = useState<FileList | null>(null);\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  const reset = () => {\n    setValue(null);\n    internalCallbackRef.current?.(null);\n    if (inputRef.current) inputRef.current.value = '';\n  };\n\n  const open = (openParams?: UseFileDialogOptions) => {\n    if (!inputRef.current) return;\n\n    inputRef.current.multiple =\n      openParams?.multiple ?? options?.multiple ?? DEFAULT_OPTIONS.multiple;\n    inputRef.current.accept = openParams?.accept ?? options?.accept ?? DEFAULT_OPTIONS.accept;\n\n    const capture = openParams?.capture ?? options?.capture;\n    if (capture) inputRef.current.capture = capture;\n\n    if (openParams?.reset ?? options?.reset ?? DEFAULT_OPTIONS.reset) reset();\n\n    inputRef.current.click();\n  };\n\n  useEffect(() => {\n    const init = () => {\n      const input = document.createElement('input');\n      input.type = 'file';\n\n      input.onchange = (event: Event) => {\n        const { files } = event.target as HTMLInputElement;\n        setValue(files);\n        internalCallbackRef.current?.(files);\n      };\n      return input;\n    };\n\n    inputRef.current = init();\n    return () => {\n      inputRef.current?.remove();\n    };\n  }, [options?.multiple, options?.accept, options?.capture, options?.reset]);\n\n  return { value, open, reset };\n}) as UseFileDialog;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use focus options type */\nexport interface UseFocusOptions {\n  /** The initial focus state of the target */\n  initialValue?: boolean;\n  /** The on blur callback */\n  onBlur?: (event: FocusEvent) => void;\n  /** The on focus callback */\n  onFocus?: (event: FocusEvent) => void;\n}\n\n/** The use focus return type */\nexport interface UseFocusReturn {\n  /** The boolean state value of the target */\n  focused: boolean;\n  /** Blur the target */\n  blur: () => void;\n  /** Focus the target */\n  focus: () => void;\n}\n\nexport interface UseFocus {\n  (target: HookTarget, options?: UseFocusOptions): UseFocusReturn;\n\n  <Target extends Element>(\n    options?: UseFocusOptions,\n    target?: never\n  ): UseFocusReturn & { ref: StateRef<Target> };\n}\n\n/**\n * @name useFocus\n * @description - Hook that allows you to focus on a specific element\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to focus\n * @param {boolean} [options.initialValue=false] The initial focus state of the target\n * @param {(event: FocusEvent) => void} [options.onFocus] The callback function to be invoked on focus\n * @param {(event: FocusEvent) => void} [options.onBlur] The callback function to be invoked on blur\n * @returns {UseFocusReturn} An object with focus state and methods\n *\n * @example\n * const { focus, blur, focused } = useFocus(ref);\n *\n * @overload\n * @template Target The target element\n * @param {boolean} [options.initialValue=false] The initial focus state of the target\n * @param {(event: FocusEvent) => void} [options.onFocus] The callback function to be invoked on focus\n * @param {(event: FocusEvent) => void} [options.onBlur] The callback function to be invoked on blur\n * @returns {UseFocusReturn & { ref: StateRef<Target> }} An object with focus state, methods and ref\n *\n * @example\n * const { ref, focus, blur, focused } = useFocus();\n */\nexport const useFocus = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = ((target ? params[1] : params[0]) as UseFocusOptions) ?? {};\n  const initialValue = options.initialValue ?? false;\n\n  const [focused, setFocused] = useState(initialValue);\n  const internalRef = useRefState<Element>();\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  const elementRef = useRef<HTMLElement | null>(null);\n\n  const focus = () => elementRef.current?.focus();\n  const blur = () => elementRef.current?.blur();\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n    const element = (target ? getElement(target) : internalRef.current) as HTMLElement;\n    if (!element) return;\n\n    elementRef.current = element;\n\n    const onFocus = (event: FocusEvent) => {\n      internalOptionsRef.current?.onFocus?.(event);\n      if (!focus || (event.target as HTMLElement).matches?.(':focus-visible')) setFocused(true);\n    };\n\n    const onBlur = (event: FocusEvent) => {\n      internalOptionsRef.current?.onBlur?.(event);\n      setFocused(false);\n    };\n\n    if (initialValue) element.focus();\n\n    element.addEventListener('focus', onFocus);\n    element.addEventListener('blur', onBlur);\n\n    return () => {\n      element.removeEventListener('focus', onFocus);\n      element.removeEventListener('blur', onBlur);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return { focus, blur, focused };\n  return {\n    ref: internalRef,\n    focus,\n    blur,\n    focused\n  };\n}) as UseFocus;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use hover options type */\nexport interface UseHoverOptions {\n  /** The on entry callback */\n  onEntry?: (event: Event) => void;\n  /** The on leave callback */\n  onLeave?: (event: Event) => void;\n}\n\nexport interface UseHoverReturn {\n  value: boolean;\n}\n\nexport interface UseHover {\n  (target: HookTarget, callback?: (event: Event) => void): boolean;\n\n  (target: HookTarget, options?: UseHoverOptions): boolean;\n\n  <Target extends Element>(\n    callback?: (event: Event) => void,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n  } & UseHoverReturn;\n\n  <Target extends Element>(\n    options?: UseHoverOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n  } & UseHoverReturn;\n}\n\n/**\n * @name useHover\n * @description - Hook that defines the logic when hovering an element\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to be hovered\n * @param {(event: Event) => void} [callback] The callback function to be invoked on mouse enter\n * @returns {boolean} The state of the hover\n *\n * @example\n * const hovering = useHover(ref, () => console.log('callback'));\n *\n * @overload\n * @param {HookTarget} target The target element to be hovered\n * @param {(event: Event) => void} [options.onEntry] The callback function to be invoked on mouse enter\n * @param {(event: Event) => void} [options.onLeave] The callback function to be invoked on mouse leave\n * @returns {boolean} The state of the hover\n *\n * @example\n * const hovering = useHover(ref, options);\n *\n * @overload\n * @template Target The target element\n * @param {(event: Event) => void} [callback] The callback function to be invoked on mouse enter\n * @returns {{ ref: StateRef<Target> } & UseHoverReturn} The state of the hover\n *\n * @example\n * const [ref, hovering] = useHover(() => console.log('callback'));\n *\n * @overload\n * @template Target The target element\n * @param {(event: Event) => void} [options.onEntry] The callback function to be invoked on mouse enter\n * @param {(event: Event) => void} [options.onLeave] The callback function to be invoked on mouse leave\n * @returns {{ ref: StateRef<Target> } & UseHoverReturn} The state of the hover\n *\n * @example\n * const [ref, hovering] = useHover(options);\n */\nexport const useHover = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { onEntry: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { onEntry: params[0] }\n  ) as UseHoverOptions | undefined;\n\n  const [hovering, setHovering] = useState(false);\n  const internalRef = useRefState<Element>();\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n\n    if (!element) return;\n\n    const onMouseEnter = (event: Event) => {\n      internalOptionsRef.current?.onEntry?.(event);\n      setHovering(true);\n    };\n\n    const onMouseLeave = (event: Event) => {\n      internalOptionsRef.current?.onLeave?.(event);\n      setHovering(false);\n    };\n\n    element.addEventListener('mouseenter', onMouseEnter);\n    element.addEventListener('mouseleave', onMouseLeave);\n\n    return () => {\n      element.removeEventListener('mouseenter', onMouseEnter);\n      element.removeEventListener('mouseleave', onMouseLeave);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return hovering;\n  return {\n    ref: internalRef,\n    value: hovering\n  } as const;\n}) as UseHover;\n", "import type { UseQueryOptions, UseQueryReturn } from '../useQuery/useQuery';\n\nimport { useQuery } from '../useQuery/useQuery';\n\n/** The use image options */\nexport interface UseImageOptions {\n  /** The alt of the image */\n  alt?: string;\n  /** The class of the image */\n  class?: string;\n  /** The crossorigin of the image */\n  crossorigin?: string;\n  /** The loading of the image */\n  loading?: HTMLImageElement['loading'];\n  /** The referrer policy of the image */\n  referrerPolicy?: HTMLImageElement['referrerPolicy'];\n  /** The sizes of the image */\n  sizes?: string;\n  /** The srcset of the image */\n  srcset?: string;\n}\n\n/** The use image return type */\nexport type UseImageReturn = UseQueryReturn<HTMLImageElement>;\n\nconst loadImage = async (src: string, options: UseImageOptions = {}): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    const { srcset, sizes, class: className, loading, crossorigin, referrerPolicy } = options;\n\n    img.src = src;\n    if (srcset) img.srcset = srcset;\n    if (sizes) img.sizes = sizes;\n    if (className) img.className = className;\n    if (loading) img.loading = loading;\n    if (crossorigin) img.crossOrigin = crossorigin;\n\n    if (referrerPolicy) img.referrerPolicy = referrerPolicy;\n\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n\n/**\n * @name useImage\n * @description - Hook that load an image in the browser\n * @category Elements\n *\n * @param {string} src The source of the image\n * @param {string} [options.srcset] The srcset of the image\n * @param {string} [options.sizes] The sizes of the image\n * @param {string} [options.alt] The alt of the image\n * @param {string} [options.class] The class of the image\n * @param {HTMLImageElement['loading']} [options.loading] The loading of the image\n * @param {string} [options.crossorigin] The crossorigin of the image\n * @param {HTMLImageElement['referrerPolicy']} [options.referrerPolicy] The referrerPolicy of the image\n * @param {DependencyList} [useQueryOptions.keys] The dependencies for the hook\n * @param {(data: Data) => void} [useQueryOptions.onSuccess] The callback function to be invoked on success\n * @param {(error: Error) => void} [useQueryOptions.onError] The callback function to be invoked on error\n * @param {number} [useQueryOptions.refetchInterval] The refetch interval\n * @param {boolean | number} [useQueryOptions.retry] The retry count of requests\n * @returns {UseImageReturn} An object with the state of the image\n *\n * @example\n * const { data, isLoading, isError, isSuccess, error, refetch, isRefetching } = useImage('https://example.com/image.png');\n */\nexport const useImage = (\n  src: string,\n  options?: UseImageOptions,\n  useQueryOptions: Omit<\n    UseQueryOptions<HTMLImageElement, HTMLImageElement>,\n    'initialData' | 'placeholderData' | 'select'\n  > = {}\n) =>\n  useQuery(() => loadImage(src, options), {\n    keys: [src, ...(useQueryOptions.keys ?? [])],\n    ...useQueryOptions\n  });\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nexport type LongPressEvents = MouseEvent | TouchEvent;\n\n// * The use long press options type */\nexport interface UseLongPressOptions {\n  // * The threshold time in milliseconds\n  threshold?: number;\n  // * The callback function to be invoked on long press cancel\n  onCancel?: (event: LongPressEvents) => void;\n  // * The callback function to be invoked on long press end\n  onFinish?: (event: LongPressEvents) => void;\n  // * The callback function to be invoked on long press start\n  onStart?: (event: LongPressEvents) => void;\n}\n\nexport interface UseLongPress {\n  (\n    target: HookTarget,\n    callback: (event: LongPressEvents) => void,\n    options?: UseLongPressOptions\n  ): boolean;\n\n  <Target extends Element>(\n    callback: (event: LongPressEvents) => void,\n    options?: UseLongPressOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n    pressed: boolean;\n  };\n}\n\nconst DEFAULT_THRESHOLD_TIME = 400;\n\n/**\n * @name useLongPress\n * @description - Hook that defines the logic when long pressing an element\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to be long pressed\n * @param {(event: LongPressEvents) => void} callback The callback function to be invoked on long press\n * @param {UseLongPressOptions} [options] The options for the long press\n * @returns {boolean} The long pressing state\n *\n * @example\n * const pressed = useLongPress(ref, () => console.log('callback'));\n *\n * @overload\n * @template Target The target element\n * @param {(event: LongPressEvents) => void} callback The callback function to be invoked on long press\n * @param {UseLongPressOptions} [options] The options for the long press\n * @returns {boolean} The long pressing state\n *\n * @example\n * const { ref, pressed } = useLongPress(() => console.log('callback'));\n */\nexport const useLongPress = ((...params: any[]): any => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const callback = (target ? params[1] : params[0]) as (event: LongPressEvents) => void;\n  const options = (target ? params[2] : params[1]) as UseLongPressOptions | undefined;\n\n  const [pressed, setPressed] = useState(false);\n  const timeoutIdRef = useRef<ReturnType<typeof setTimeout>>(undefined);\n  const isPressedRef = useRef(false);\n  const internalRef = useRefState<Element>();\n\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = target ? getElement(target) : internalRef.current;\n    if (!element) return;\n\n    const onStart = (event: LongPressEvents) => {\n      internalOptionsRef.current?.onStart?.(event);\n\n      isPressedRef.current = true;\n      timeoutIdRef.current = setTimeout(() => {\n        internalCallbackRef.current(event);\n        setPressed(true);\n      }, internalOptionsRef.current?.threshold ?? DEFAULT_THRESHOLD_TIME);\n    };\n\n    const onCancel = (event: LongPressEvents) => {\n      setPressed((prevPressed) => {\n        if (prevPressed) {\n          internalOptionsRef.current?.onFinish?.(event);\n        } else if (isPressedRef.current) {\n          internalOptionsRef.current?.onCancel?.(event);\n        }\n\n        return false;\n      });\n\n      isPressedRef.current = false;\n      if (timeoutIdRef.current) clearTimeout(timeoutIdRef.current);\n    };\n\n    element.addEventListener('mousedown', onStart as EventListener);\n    element.addEventListener('touchstart', onStart as EventListener);\n    element.addEventListener('mouseup', onCancel as EventListener);\n    element.addEventListener('touchend', onCancel as EventListener);\n    window.addEventListener('mouseup', onCancel as EventListener);\n    window.addEventListener('touchend', onCancel as EventListener);\n\n    return () => {\n      element.removeEventListener('mousedown', onStart as EventListener);\n      element.removeEventListener('touchstart', onStart as EventListener);\n      element.removeEventListener('mouseup', onCancel as EventListener);\n      element.removeEventListener('touchend', onCancel as EventListener);\n      window.removeEventListener('mouseup', onCancel as EventListener);\n      window.removeEventListener('touchend', onCancel as EventListener);\n\n      if (timeoutIdRef.current) clearTimeout(timeoutIdRef.current);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return pressed;\n  return {\n    ref: internalRef,\n    pressed\n  };\n}) as UseLongPress;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useEvent } from '../useEvent/useEvent';\nimport { useRefState } from '../useRefState/useRefState';\n\nconst DEFAULT_BRUSH_RADIUS = 10;\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\nexport class Pointer implements Point {\n  x: number;\n\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  update(point: Point) {\n    this.x = point.x;\n    this.y = point.y;\n  }\n\n  getDifferenceTo(point: Point) {\n    return new Pointer(this.x - point.x, this.y - point.y);\n  }\n\n  getDistanceTo(point: Point) {\n    const diff = this.getDifferenceTo(point);\n    return Math.sqrt(diff.x ** 2 + diff.y ** 2);\n  }\n\n  getAngleTo(point: Point) {\n    const diff = this.getDifferenceTo(point);\n    return Math.atan2(diff.y, diff.x);\n  }\n\n  equalsTo(point: Point) {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  moveByAngle(\n    // The angle in radians\n    angle: number,\n    // How much the point should be moved\n    distance: number\n  ) {\n    // Rotate the angle based on the browser coordinate system ([0,0] in the top left)\n    const angleRotated = angle + Math.PI / 2;\n\n    this.x += Math.sin(angleRotated) * distance;\n    this.y -= Math.cos(angleRotated) * distance;\n\n    return this;\n  }\n}\n\nexport class Paint {\n  pointer: Pointer;\n\n  brush: Pointer;\n\n  radius: number;\n\n  smooth: boolean = false;\n\n  points: Point[] = [];\n\n  lines: { points: Point[]; color: string; radius: number; opacity: number }[] = [];\n\n  constructor({ x, y, radius, smooth }: { x: number; y: number; radius: number; smooth: boolean }) {\n    this.smooth = smooth;\n    this.pointer = new Pointer(x, y);\n    this.brush = new Pointer(x, y);\n    this.radius = radius;\n    this.points = [];\n    this.lines = [];\n  }\n\n  getBrushCoordinates() {\n    return {\n      x: this.brush.x,\n      y: this.brush.y\n    };\n  }\n\n  getPointerCoordinates() {\n    return {\n      x: this.pointer.x,\n      y: this.pointer.y\n    };\n  }\n\n  update(point: Point) {\n    if (this.pointer.equalsTo(point)) return false;\n    this.pointer.update(point);\n\n    if (!this.smooth) {\n      this.brush.update(point);\n      this.points.push(this.getBrushCoordinates());\n      return true;\n    }\n\n    const distance = this.pointer.getDistanceTo(this.brush);\n    const angle = this.pointer.getAngleTo(this.brush);\n    const isOutside = Math.round((distance - this.radius) * 10) / 10 > 0;\n\n    if (isOutside) {\n      const angleRotated = angle + Math.PI / 2;\n      this.brush.update({\n        x: this.brush.x + Math.sin(angleRotated) * (distance - this.radius),\n        y: this.brush.y - Math.cos(angleRotated) * (distance - this.radius)\n      });\n      this.points.push(this.getBrushCoordinates());\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport interface UsePaintOptions {\n  /** Brush color */\n  color?: string;\n  /** Initial lines */\n  initialLines?: Paint['lines'];\n  /** Brush opacity */\n  opacity?: number;\n  /** Brush radius */\n  radius?: number;\n  /** Smooth brush movement */\n  smooth?: boolean;\n  /** Callback when the mouse is down */\n  onMouseDown?: (event: MouseEvent, paint: Paint) => void;\n  /** Callback when the mouse is moved */\n  onMouseMove?: (event: MouseEvent, paint: Paint) => void;\n  /** Callback when the mouse is up */\n  onMouseUp?: (event: MouseEvent, paint: Paint) => void;\n}\n\nexport interface UsePaintReturn {\n  drawing: boolean;\n  lines: Paint['lines'];\n  clear: () => void;\n  draw: (points: Point[], color: string, opacity: number, radius: number) => void;\n  undo: () => void;\n}\n\nexport interface UsePaint {\n  (target: HookTarget, options?: UsePaintOptions): UsePaintReturn;\n\n  <Target extends HTMLCanvasElement>(\n    options?: UsePaintOptions,\n    target?: never\n  ): UsePaintReturn & { ref: StateRef<Target> };\n}\n\n/**\n * @name usePaint\n * @description - Hook that allows you to draw in a specific area\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to be painted\n * @param {UsePaintOptions} [options] The options to be used\n * @returns {UsePaintReturn} An object containing the current pencil options and functions to interact with the paint\n *\n * @example\n * const drawing = usePaint(canvasRef);\n *\n * @overload\n * @param {UsePaintOptions} [options] The options to be used\n * @returns {UsePaintReturn & { ref: StateRef<HTMLCanvasElement> }} An object containing the current pencil options and functions to interact with the paint\n *\n * @example\n * const { ref, drawing } = usePaint();\n */\nexport const usePaint = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = ((target ? params[1] : params[0]) as UsePaintOptions) ?? {};\n\n  const color = options?.color ?? 'black';\n  const opacity = options?.opacity ?? 1;\n  const radius = options?.radius ?? DEFAULT_BRUSH_RADIUS;\n\n  const paintRef = useRef<Paint>(\n    new Paint({\n      x: 0,\n      y: 0,\n      radius: options?.radius ?? DEFAULT_BRUSH_RADIUS,\n      smooth: options?.smooth ?? false\n    })\n  );\n  const [drawing, setIsDrawing] = useState(false);\n  const internalRef = useRefState<HTMLCanvasElement>();\n  const contextRef = useRef<CanvasRenderingContext2D | null>(null);\n\n  const draw = (points: Point[], color: string, opacity: number, radius: number) => {\n    if (!contextRef.current) return;\n\n    contextRef.current.globalAlpha = opacity;\n    contextRef.current.strokeStyle = color;\n    contextRef.current.lineWidth = radius * 2;\n    contextRef.current.lineCap = 'round';\n    contextRef.current.lineJoin = 'round';\n\n    let p1 = points[0];\n    let p2 = points[1];\n\n    contextRef.current.beginPath();\n\n    for (let i = 1; i < points.length; i += 1) {\n      const midPoint = {\n        x: p1.x + (p2.x - p1.x) / 2,\n        y: p1.y + (p2.y - p1.y) / 2\n      };\n      contextRef.current.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n      p1 = points[i];\n      p2 = points[i + 1];\n    }\n    contextRef.current.lineTo(p1.x, p1.y);\n    contextRef.current.stroke();\n  };\n\n  const clearCanvas = () => {\n    if (!contextRef.current) return;\n    contextRef.current.clearRect(\n      0,\n      0,\n      contextRef.current.canvas.width,\n      contextRef.current.canvas.height\n    );\n  };\n\n  const onMouseMove = useEvent((event: MouseEvent) => {\n    if (!drawing) return;\n    options?.onMouseMove?.(event, paintRef.current);\n\n    const point = { x: event.offsetX, y: event.offsetY };\n\n    const isUpdated = paintRef.current.update(point);\n\n    if (!isUpdated) return;\n    if (!contextRef.current) return;\n    clearCanvas();\n    contextRef.current.clearRect(\n      0,\n      0,\n      contextRef.current.canvas.width,\n      contextRef.current.canvas.height\n    );\n\n    // const brush = paintRef.current.getBrushCoordinates();\n    // // Draw brush point\n    // contextRef.current.beginPath();\n    // contextRef.current.fillStyle = 'red';\n    // contextRef.current.arc(brush.x, brush.y, radius, 0, Math.PI * 2, true);\n    // contextRef.current.fill();\n\n    // // Draw the lazy radius.\n    // contextRef.current.beginPath();\n    // contextRef.current.strokeStyle = '#ccc';\n    // contextRef.current.arc(brush.x, brush.y, radius * 2, 0, Math.PI * 2, true);\n    // contextRef.current.stroke();\n\n    paintRef.current.lines.forEach(({ points, color, opacity, radius }) =>\n      draw(points, color, opacity, radius)\n    );\n    draw(paintRef.current.points, color, opacity, radius);\n  });\n\n  const onMouseDown = useEvent((event: MouseEvent) => {\n    if (!contextRef.current) return;\n\n    const point = { x: event.offsetX, y: event.offsetY };\n    paintRef.current.brush.update(point);\n    paintRef.current.points.push(point);\n    draw(paintRef.current.points, color, opacity, radius);\n\n    options?.onMouseDown?.(event, paintRef.current);\n    setIsDrawing(true);\n  });\n\n  const onMouseUp = useEvent((event: MouseEvent) => {\n    if (!contextRef.current) return;\n\n    if (paintRef.current.points.length) {\n      paintRef.current.lines.push({\n        points: paintRef.current.points,\n        color,\n        opacity,\n        radius\n      });\n      paintRef.current.points = [];\n    }\n\n    options?.onMouseUp?.(event, paintRef.current);\n    setIsDrawing(false);\n  });\n\n  const clear = () => {\n    if (!contextRef.current) return;\n    clearCanvas();\n    paintRef.current.lines = [];\n    paintRef.current.points = [];\n  };\n\n  const undo = () => {\n    if (!contextRef.current) return;\n    clearCanvas();\n\n    paintRef.current.lines.pop();\n    paintRef.current.lines.forEach(({ points, color, opacity, radius }) =>\n      draw(points, color, opacity, radius)\n    );\n  };\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as HTMLCanvasElement;\n    if (!element) return;\n    contextRef.current = element.getContext('2d');\n\n    if (options?.initialLines) {\n      paintRef.current.lines = options.initialLines;\n      options.initialLines.forEach(({ points, color, opacity, radius }) =>\n        draw(points, color, opacity, radius)\n      );\n    }\n\n    element.addEventListener('mousedown', onMouseDown);\n    element.addEventListener('mousemove', onMouseMove);\n    element.addEventListener('mouseup', onMouseUp);\n\n    return () => {\n      if (!element) return;\n      element.removeEventListener('mousedown', onMouseDown);\n      element.removeEventListener('mousemove', onMouseMove);\n      element.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return { drawing, clear, undo, draw, lines: paintRef.current.lines };\n  return {\n    ref: internalRef,\n    drawing,\n    clear,\n    undo,\n    draw,\n    lines: paintRef.current.lines\n  };\n}) as UsePaint;\n", "import type { ComponentProps } from 'react';\n\nimport { useEffect, useState } from 'react';\n\n/** The use script status */\nexport type UseScriptStatus = 'error' | 'loading' | 'ready' | 'unknown';\nexport const SCRIPT_STATUS_ATTRIBUTE_NAME = 'script-status';\n\n/** The use script options extends from attributes script tag */\nexport interface UseScriptOptions extends ComponentProps<'script'> {\n  /** Whether to remove the script on unmount */\n  removeOnUnmount?: boolean;\n}\n\n/**\n * @name useScript\n * @description - Hook that manages a script with onLoad, onError, and removeOnUnmount functionalities\n * @category Elements\n *\n * @param {string} src The source of the script\n * @param {UseScriptOptions} [options] The options of the script extends from attributes script tag\n * @param {boolean} [options.removeOnUnmount=true] Whether to remove the script on unmount\n * @param {boolean} [options.async=true] Whether to load the script asynchronously\n * @returns {UseScriptStatus} The status of the script\n *\n * @example\n * const status = useScript('https://example.com/script.js');\n */\nexport const useScript = (src: string, options: UseScriptOptions = {}) => {\n  const [status, setStatus] = useState<UseScriptStatus>(() => {\n    const script = document.querySelector(`script[src=\"${src}\"]`) as HTMLScriptElement;\n    const scriptStatus = script?.getAttribute(SCRIPT_STATUS_ATTRIBUTE_NAME) as UseScriptStatus;\n    if (scriptStatus) return scriptStatus;\n    if (script) return 'unknown';\n\n    return 'loading';\n  });\n  const { removeOnUnmount = true, async = true } = options;\n\n  useEffect(() => {\n    const existedScript = document.querySelector(`script[src=\"${src}\"]`) as HTMLScriptElement;\n    const scriptStatus = existedScript?.getAttribute(\n      SCRIPT_STATUS_ATTRIBUTE_NAME\n    ) as UseScriptStatus;\n    if (scriptStatus) return setStatus(scriptStatus);\n    if (existedScript) return setStatus('unknown');\n\n    const script = document.createElement('script');\n    script.src = src;\n    script.async = async;\n\n    for (const [key, value] of Object.entries(options)) {\n      script.setAttribute(key, String(value));\n    }\n\n    script.setAttribute(SCRIPT_STATUS_ATTRIBUTE_NAME, 'loading');\n    document.body.appendChild(script);\n\n    const onLoad = () => {\n      script.setAttribute(SCRIPT_STATUS_ATTRIBUTE_NAME, 'ready');\n      setStatus('ready');\n    };\n\n    const onError = () => {\n      script.setAttribute(SCRIPT_STATUS_ATTRIBUTE_NAME, 'error');\n      setStatus('error');\n    };\n\n    script.addEventListener('load', onLoad);\n    script.addEventListener('error', onError);\n\n    return () => {\n      if (removeOnUnmount) script.remove();\n      script.removeEventListener('load', onLoad);\n      script.removeEventListener('error', onError);\n    };\n  }, [src, removeOnUnmount]);\n\n  return status;\n};\n", "import { useEffect, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use sticky return type */\nexport interface UseStickyReturn {\n  stuck: boolean;\n}\n\n/** The use sticky axis type */\nexport type UseStickyAxis = 'horizontal' | 'vertical';\n\n/** The use sticky options type */\nexport interface UseStickyOptions {\n  axis?: UseStickyAxis;\n  root?: HookTarget;\n}\n\nexport interface UseSticky {\n  (target: HookTarget, options?: UseStickyOptions): boolean;\n\n  <Target extends Element>(\n    options?: UseStickyOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n  } & UseStickyReturn;\n}\n\n/**\n * @name UseSticky\n * @description - Hook that allows you to detect that your sticky component is stuck\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target sticky element\n * @param {UseStickyAxis} [options.axis='vertical'] The axis of motion of the sticky component\n * @param {UseStickyRoot} [options.root=document] The element that contains your sticky component\n * @returns {UseStickyReturn} The state of the sticky\n *\n * @example\n * const stuck  = useSticky(ref);\n *\n * @overload\n * @param {UseStickyAxis} [options.axis='vertical'] The axis of motion of the sticky component\n * @param {UseStickyRoot} [options.root=document] The element that contains your sticky component\n * @returns {{ stickyRef: StateRef<Target> } & UseStickyReturn} The state of the sticky\n *\n * @example\n * const { stuck, ref } = useSticky();\n */\nexport const useSticky = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (target ? params[1] : params[0]) as UseStickyOptions;\n  const axis = options?.axis ?? 'vertical';\n\n  const internalRef = useRefState<Element>();\n  const [stuck, setStuck] = useState(false);\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n\n    if (!element) return;\n\n    const root = (options?.root ? getElement(options.root) : document) as Element;\n    const elementOffsetTop =\n      element.getBoundingClientRect().top + root.scrollTop - root.getBoundingClientRect().top;\n    const elementOffsetLeft =\n      element.getBoundingClientRect().left + root.scrollLeft - root.getBoundingClientRect().left;\n\n    const onSticky = () => {\n      if (axis === 'vertical') {\n        const scrollTop = root.scrollTop;\n        setStuck(scrollTop >= elementOffsetTop);\n      }\n\n      if (axis === 'horizontal') {\n        const scrollLeft = root.scrollLeft;\n        setStuck(scrollLeft >= elementOffsetLeft);\n      }\n    };\n\n    root.addEventListener('scroll', onSticky);\n    window.addEventListener('resize', onSticky);\n    window.addEventListener('orientationchange', onSticky);\n\n    onSticky();\n\n    return () => {\n      root.removeEventListener('scroll', onSticky);\n      window.removeEventListener('resize', onSticky);\n      window.removeEventListener('orientationchange', onSticky);\n    };\n  }, [target, internalRef.state, axis, options?.root]);\n\n  if (target) return stuck;\n  return {\n    stuck,\n    ref: internalRef\n  };\n}) as UseSticky;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use text direction value type */\nexport type UseTextDirectionValue = 'auto' | 'ltr' | 'rtl';\n\n/** The use text direction return type */\nexport interface UseTextDirectionReturn {\n  /** The current direction */\n  value: UseTextDirectionValue;\n  /*** The function to remove the direction */\n  remove: () => void;\n  /*** The function to set the direction */\n  set: (value: UseTextDirectionValue | null) => void;\n}\n\nexport interface UseTextDirection {\n  (target: HookTarget, initialValue?: UseTextDirectionValue): UseTextDirectionReturn;\n\n  <Target extends Element>(\n    initialValue?: UseTextDirectionValue,\n    target?: never\n  ): UseTextDirectionReturn & { ref: StateRef<Target> };\n}\n\n/**\n * @name useTextDirection\n * @description - Hook that can get and set the direction of the element\n * @category Elements\n *\n * @overload\n * @param {HookTarget} [target=document.querySelector('html')] The target element to observe\n * @param {UseTextDirectionValue} [initialValue = 'ltr'] The initial direction of the element\n * @returns {UseTextDirectionReturn} An object containing the current text direction of the element\n *\n * @example\n * const { value, set, remove } = useTextDirection(ref);\n *\n * @overload\n * @template Target The target element type\n * @param {UseTextDirectionValue} [initialValue = 'ltr'] The initial direction of the element\n * @returns { { ref: StateRef<Target> } & UseTextDirectionReturn } An object containing the current text direction of the element\n *\n * @example\n * const { ref, value, set, remove } = useTextDirection();\n */\nexport const useTextDirection = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const initialValue = ((target ? params[1] : params[0]) as UseTextDirectionValue) ?? 'ltr';\n\n  const internalRef = useRefState();\n  const elementRef = useRef<Element>(null);\n\n  const getDirection = () => {\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    return (element?.getAttribute('dir') as UseTextDirectionValue) ?? initialValue;\n  };\n\n  const [value, setValue] = useState<UseTextDirectionValue>(getDirection());\n\n  const remove = () => {\n    if (!elementRef.current) return;\n\n    elementRef.current?.removeAttribute('dir');\n  };\n\n  const set = (value: UseTextDirectionValue) => {\n    if (!elementRef.current) return;\n\n    setValue(value);\n    elementRef.current.setAttribute('dir', value);\n  };\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element =\n      ((target ? getElement(target) : internalRef.current) as Element) ??\n      document.querySelector('html');\n    if (!element) return;\n\n    elementRef.current = element;\n\n    const direction = getDirection();\n    element.setAttribute('dir', direction);\n    setValue(direction);\n\n    const observer = new MutationObserver(getDirection);\n\n    observer.observe(element, { attributes: true });\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [internalRef.state, target]);\n\n  if (target) return { value, set, remove };\n  return {\n    ref: internalRef,\n    value,\n    set,\n    remove\n  };\n}) as UseTextDirection;\n", "import { useEffect } from 'react';\n\n/**\n * @name useFul\n * @description - Hook that can be so useful\n * @category Humor\n *\n * @warning - This hook is a joke. Please do not use it in production code!\n *\n * @template Value The type of the value\n * @param {Value} [value] The value to be returned\n * @returns {Value} The value passed to the hook\n *\n * @example\n * const value = useFul(state);\n */\nexport const useFul = <Value>(value?: Value) => {\n  useEffect(() => {\n    console.warn(\"Warning: You forgot to delete the 'useFul' hook.\");\n  }, []);\n\n  return value;\n};\n", "import { useEffect } from 'react';\n\n/**\n * @name useLess\n * @description - Hook that can be so useless\n * @category Humor\n *\n * @warning - This hook is a joke. Please do not use it in production code!\n *\n * @template Value The type of the value\n * @param {Value} [value] The value to be returned\n * @returns {Value} The value passed to the hook\n *\n * @example\n * const value = useLess(state);\n */\nexport const useLess = <Value>(value?: Value) => {\n  useEffect(() => {\n    console.warn(\"Warning: You forgot to delete the 'useLess' hook.\");\n  }, []);\n\n  return value;\n};\n", "import type { EffectCallback } from 'react';\n\nimport { useEffect, useRef } from 'react';\n\n/**\n * @name useEffectOnce\n * @description - Hook that runs an effect only once. Please do not use it in production code!\n * @category Humor\n *\n * @warning - This hook will run effect only once even in strict mode. Please do not use it in production code!\n *\n * @param {EffectCallback} effect The effect to run\n *\n * @example\n * useOnce(() => console.log('effect once'));\n */\nexport function useOnce(effect: EffectCallback) {\n  const cleanupRef = useRef<ReturnType<EffectCallback>>(undefined);\n  const hasRunRef = useRef(false);\n  const hasRenderedAfterRun = useRef(false);\n\n  if (hasRunRef.current) {\n    hasRenderedAfterRun.current = true;\n  }\n\n  useEffect(() => {\n    if (hasRunRef.current) return;\n\n    hasRunRef.current = true;\n    cleanupRef.current = effect();\n\n    return () => {\n      if (!hasRenderedAfterRun.current) return;\n\n      if (typeof cleanupRef.current === 'function') {\n        cleanupRef.current();\n      }\n    };\n  }, []);\n}\n", "import { useRef } from 'react';\n\n/**\n * @name useIsFirstRender\n * @description - Hook that returns true if the component is first render\n * @category Lifecycle\n *\n * @returns {boolean} True if the component is first render\n *\n * @example\n * const isFirstRender = useIsFirstRender();\n */\nexport const useIsFirstRender = () => {\n  const renderRef = useRef(true);\n\n  if (renderRef.current === true) {\n    renderRef.current = false;\n    return true;\n  }\n\n  return renderRef.current;\n};\n", "import type { DependencyList, EffectCallback } from 'react';\n\nimport { useEffect, useRef } from 'react';\n\nexport const deepEqual = (a: any, b: any): boolean => {\n  if (a === b) return true;\n  if (a == null || b == null) return a === b;\n  if (typeof a !== typeof b) return false;\n  if (typeof a !== 'object') return a === b;\n  if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n  if (Array.isArray(a))\n    return a.length === b.length && a.every((value, index) => deepEqual(value, b[index]));\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n\n  if (keysA.length !== keysB.length) return false;\n\n  for (const key of keysA) {\n    if (!keysB.includes(key)) return false;\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n\n  return true;\n};\n\n/**\n * @name useShallowEffect\n * @description - Hook that executes an effect only when dependencies change shallowly or deeply\n * @category Lifecycle\n *\n * @param {EffectCallback} effect The effect callback\n * @param {DependencyList} [deps] The dependencies list for the effect\n *\n * @example\n * useShallowEffect(() => console.log(\"effect\"), [user]);\n */\nexport const useShallowEffect = (effect: EffectCallback, deps?: DependencyList) => {\n  const depsRef = useRef<DependencyList>(deps);\n\n  if (!depsRef.current || !deepEqual(deps, depsRef.current)) {\n    depsRef.current = deps;\n  }\n\n  useEffect(effect, depsRef.current);\n};\n", "import { useEffect, useRef } from 'react';\n\n/**\n * @name useUnmount\n * @description - Hook that defines the logic when unmounting a component\n * @category Lifecycle\n *\n * @param {() => void} callback The callback function to be invoked on component unmount\n * @returns {void}\n *\n * @example\n * useUnmount(() => console.log('This effect runs on component unmount'));\n */\n\nexport const useUnmount = (callback: () => void) => {\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  useEffect(\n    () => () => {\n      internalCallbackRef.current();\n    },\n    []\n  );\n};\n", "import { useEffect } from 'react';\n\nimport { useRerender } from '../useRerender/useRerender';\n\n/** The breakpoints type */\nexport type Breakpoints<Breakpoint extends string = string> = Record<Breakpoint, number>;\n\n/** The use breakpoints strategy */\nexport type UseBreakpointsStrategy = 'desktop-first' | 'mobile-first';\n\nconst match = (query: string) => window.matchMedia(query).matches;\n\n/** The use breakpoints return type */\nexport type UseBreakpointsReturn<Breakpoint extends string = string> = {\n  /** The function that checks if the current breakpoint is greater than to the given breakpoint */\n  greater: (breakpoint: Breakpoint) => boolean;\n  /** The function that checks if the current breakpoint is greater than or equal to the given breakpoint */\n  greaterOrEqual: (breakpoint: Breakpoint) => boolean;\n  /** The function that checks if the current breakpoint is smaller than to the given breakpoint */\n  smaller: (breakpoint: Breakpoint) => boolean;\n  /** The function that checks if the current breakpoint is smaller than or equal to the given breakpoint */\n  smallerOrEqual: (breakpoint: Breakpoint) => boolean;\n  /** The function that checks if the current breakpoint is between to the given breakpoints */\n  between: (a: Breakpoint, b: Breakpoint) => boolean;\n  /** The function that checks if the current breakpoint is greater than to the given breakpoint */\n  isGreater: (breakpoint: Breakpoint) => boolean;\n  /** The function that checks if the current breakpoint is greater than or equal to the given breakpoint */\n  isGreaterOrEqual: (breakpoint: Breakpoint) => boolean;\n  /** The function that checks if the current breakpoint is smaller than to the given breakpoint */\n  isSmaller: (breakpoint: Breakpoint) => boolean;\n  /** The function that checks if the current breakpoint is smaller than or equal to the given breakpoint */\n  isSmallerOrEqual: (breakpoint: Breakpoint) => boolean;\n  /** The function that checks if the current breakpoint is between to the given breakpoints */\n  isInBetween: (a: Breakpoint, b: Breakpoint) => boolean;\n  /** The function that returns the current breakpoints */\n  current: () => Breakpoint[];\n  /** The function that returns the current active breakpoint */\n  active: () => Breakpoint;\n} & Record<Breakpoint, boolean>;\n\n/**\n * @name useBreakpoints\n * @description - Hook that manages breakpoints\n * @category Browser\n *\n * @template {string} Breakpoint The name of the breakpoint\n * @param {Breakpoints<Breakpoint>} breakpoints The breakpoints to use\n * @param {UseBreakpointsStrategy} [strategy=min-width] The strategy to use for matching\n * @returns {UseBreakpointsReturn<Breakpoint>} An object containing the current breakpoint\n *\n * @example\n * const { greaterOrEqual, smallerOrEqual, current } = useBreakpoints({ mobile: 0, tablet: 640, laptop: 1024, desktop: 1280 });\n */\nexport const useBreakpoints = <Breakpoint extends string>(\n  breakpoints: Breakpoints<Breakpoint>,\n  strategy: UseBreakpointsStrategy = 'mobile-first'\n): UseBreakpointsReturn<Breakpoint> => {\n  const rerender = useRerender();\n\n  const getValue = (breakpoint: Breakpoint, delta?: number) => {\n    if (delta) return `${Number(breakpoints[breakpoint]) + delta}px`;\n    return `${breakpoints[breakpoint]}px`;\n  };\n\n  useEffect(() => {\n    const onResize = () => rerender();\n    window.addEventListener('resize', onResize);\n    return () => {\n      window.removeEventListener('resize', onResize);\n    };\n  }, []);\n\n  const greaterOrEqual = (breakpoint: Breakpoint) => match(`(min-width: ${getValue(breakpoint)})`);\n  const smallerOrEqual = (breakpoint: Breakpoint) => match(`(max-width: ${getValue(breakpoint)})`);\n  const current = () =>\n    Object.keys(breakpoints)\n      .map((breakpoint) => [breakpoint, greaterOrEqual(breakpoint as Breakpoint)])\n      .filter(([, value]) => value)\n      .map(([breakpoint]) => breakpoint) as Breakpoint[];\n  const active = () => {\n    const breakpoints = current();\n    return (breakpoints.length ? breakpoints.at(-1) : undefined) as Breakpoint;\n  };\n\n  const greater = (breakpoint: Breakpoint) => match(`(min-width: ${getValue(breakpoint, 0.1)})`);\n  const smaller = (breakpoint: Breakpoint) => match(`(max-width: ${getValue(breakpoint, -0.1)})`);\n  const between = (a: Breakpoint, b: Breakpoint) =>\n    match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n\n  const breakpointsKeys = (Object.keys(breakpoints) as Breakpoint[]).reduce(\n    (acc, breakpoint) => {\n      const value =\n        strategy === 'mobile-first' ? greaterOrEqual(breakpoint) : smallerOrEqual(breakpoint);\n      acc[breakpoint] = value;\n      return acc;\n    },\n    {} as Record<Breakpoint, boolean>\n  );\n\n  return {\n    current,\n    greaterOrEqual,\n    smallerOrEqual,\n    active,\n    greater,\n    smaller,\n    between,\n    isGreater: greater,\n    isGreaterOrEqual: greaterOrEqual,\n    isSmaller: smaller,\n    isSmallerOrEqual: smallerOrEqual,\n    isInBetween: between,\n    ...breakpointsKeys\n  };\n};\n\n/** Breakpoints from Material UI */\nexport const BREAKPOINTS_MATERIAL_UI = {\n  xs: 0,\n  sm: 600,\n  md: 900,\n  lg: 1200,\n  xl: 1536\n};\n\n/** Breakpoints from Mantine */\nexport const BREAKPOINTS_MANTINE = {\n  xs: 576,\n  sm: 768,\n  md: 992,\n  lg: 1200,\n  xl: 1408\n};\n\n/** Breakpoints from Tailwind */\nexport const BREAKPOINTS_TAILWIND = {\n  sm: 640,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  '2xl': 1536\n};\n\n/**  Breakpoints from Bootstrap V5 */\nexport const BREAKPOINTS_BOOTSTRAP_V5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\n\n/** Breakpoints from Ant Design */\nexport const BREAKPOINTS_ANT_DESIGN = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\n\n/** Breakpoints from Quasar V2 */\nexport const BREAKPOINTS_QUASAR_V2 = {\n  xs: 0,\n  sm: 600,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\n\n/** Sematic Breakpoints */\nexport const BREAKPOINTS_SEMANTIC = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\n\n/**  Breakpoints from Master CSS  */\nexport const BREAKPOINTS_MASTER_CSS = {\n  '3xs': 360,\n  '2xs': 480,\n  xs: 600,\n  sm: 768,\n  md: 1024,\n  lg: 1280,\n  xl: 1440,\n  '2xl': 1600,\n  '3xl': 1920,\n  '4xl': 2560\n};\n\n/** Breakpoints from PrimeFlex */\nexport const BREAKPOINTS_PRIME_FLEX = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\n", "export const throttle = <Params extends any[]>(\n  callback: (...args: Params) => void,\n  delay: number\n): ((...args: Params) => void) => {\n  let isCalled = false;\n  let lastArgs: Params | null = null;\n\n  const timer = () => {\n    if (!lastArgs) {\n      isCalled = false;\n      return;\n    }\n\n    callback.apply(this, lastArgs);\n    lastArgs = null;\n    setTimeout(timer, delay);\n  };\n\n  return function (this: any, ...args: Params) {\n    if (isCalled) {\n      lastArgs = args;\n      return;\n    }\n\n    callback.apply(this, args);\n    isCalled = true;\n    setTimeout(timer, delay);\n  };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\nimport { throttle } from '@/utils/helpers';\n\nexport interface UseDeviceMotionReturn {\n  acceleration: DeviceMotionEventAcceleration;\n  accelerationIncludingGravity: DeviceMotionEventAcceleration;\n  interval: DeviceMotionEvent['interval'];\n  rotationRate: DeviceMotionEventRotationRate;\n}\n\nexport interface UseDeviceMotionParams {\n  /** The delay in milliseconds */\n  delay?: number;\n  /** Whether to enable the hook */\n  enabled?: boolean;\n  /** The callback function to be invoked */\n  callback?: (event: DeviceMotionEvent) => void;\n}\n\n/**\n * @name useDeviceMotion\n * @description - Hook that work with device motion\n * @category Utilities\n *\n * @browserapi DeviceMotionEvent https://developer.mozilla.org/en-US/docs/Web/API/Window/DeviceMotionEvent\n *\n * @param {number} [delay=1000] The delay in milliseconds\n * @param {(event: DeviceMotionEvent) => void} [callback] The callback function to be invoked\n * @param {boolean} [enabled=true] Whether to enable the hook\n * @returns {UseDeviceMotionReturn} The device motion data and interval\n *\n * @example\n * const { interval, rotationRate, acceleration, accelerationIncludingGravity } = useDeviceMotion();\n */\nexport const useDeviceMotion = (params?: UseDeviceMotionParams) => {\n  const enabled = params?.enabled ?? true;\n  const delay = params?.delay ?? 1000;\n  const [value, setValue] = useState<UseDeviceMotionReturn>({\n    interval: 0,\n    rotationRate: { alpha: null, beta: null, gamma: null },\n    acceleration: { x: null, y: null, z: null },\n    accelerationIncludingGravity: { x: null, y: null, z: null }\n  });\n  const internalCallbackRef = useRef(params?.callback);\n  internalCallbackRef.current = params?.callback;\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    const onDeviceMotion = throttle<[DeviceMotionEvent]>((event) => {\n      internalCallbackRef.current?.(event);\n\n      setValue({\n        interval: event.interval,\n        rotationRate: {\n          ...value.rotationRate,\n          ...event.rotationRate\n        },\n        acceleration: {\n          ...value.acceleration,\n          ...event.acceleration\n        },\n        accelerationIncludingGravity: {\n          ...value.accelerationIncludingGravity,\n          ...event.accelerationIncludingGravity\n        }\n      });\n    }, delay);\n\n    window.addEventListener('devicemotion', onDeviceMotion);\n\n    return () => {\n      window.removeEventListener('devicemotion', onDeviceMotion);\n    };\n  }, [delay, enabled]);\n\n  return value;\n};\n", "import { useEffect, useState } from 'react';\n\n/* The use device orientation value type */\nexport interface UseDeviceOrientationValue {\n  /** The current absolute value */\n  absolute: boolean;\n  /** A number representing the motion of the device around the z axis, express in degrees with values ranging from 0 to 360 */\n  alpha: number | null;\n  /** A number representing the motion of the device around the x axis, express in degrees with values ranging from -180 to 180 */\n  beta: number | null;\n  /** A number representing the motion of the device around the y axis, express in degrees with values ranging from -90 to 90 */\n  gamma: number | null;\n}\n\n/* The use device orientation return type */\nexport interface UseDeviceOrientationReturn {\n  /** Whether the device orientation is supported */\n  supported: boolean;\n  /** The current device orientation value */\n  value: UseDeviceOrientationValue;\n}\n\n/**\n * @name useDeviceOrientation\n * @description - Hook that provides the current device orientation\n * @category Sensors\n *\n * @browserapi DeviceOrientationEvent https://developer.mozilla.org/en-US/docs/Web/API/Window/DeviceOrientationEvent\n *\n * @returns {UseDeviceOrientationReturn} The current device orientation\n *\n * @example\n * const { supported, value } = useDeviceOrientation();\n */\nexport const useDeviceOrientation = (): UseDeviceOrientationReturn => {\n  const supported = typeof window !== 'undefined' && 'DeviceOrientationEvent' in window;\n\n  const [value, setValue] = useState<UseDeviceOrientationValue>({\n    alpha: null,\n    beta: null,\n    gamma: null,\n    absolute: false\n  });\n\n  useEffect(() => {\n    if (!supported) return;\n\n    const onDeviceOrientation = (event: DeviceOrientationEvent) =>\n      setValue({\n        alpha: event.alpha,\n        beta: event.beta,\n        gamma: event.gamma,\n        absolute: event.absolute\n      });\n\n    window.addEventListener('deviceorientation', onDeviceOrientation);\n    return () => {\n      window.removeEventListener('deviceorientation', onDeviceOrientation);\n    };\n  }, []);\n\n  return {\n    supported,\n    value\n  };\n};\n", "import { useEffect, useState } from 'react';\n\n/** The use device pixel ratio return type */\nexport interface UseDevicePixelRatioReturn {\n  /** The ratio of the resolution in physical pixels to the resolution in CSS pixels */\n  ratio: number;\n  /** Whether the device pixel ratio is supported*/\n  supported: boolean;\n}\n\n/**\n * @name useDevicePixelRatio\n * @description - Hook that returns the device's pixel ratio\n * @category Utilities\n *\n * @browserapi window.devicePixelRatio https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio\n *\n * @returns {UseDevicePixelRatioReturn} The ratio and supported flag\n *\n * @example\n * const { supported, ratio } = useDevicePixelRatio();\n */\nexport const useDevicePixelRatio = (): UseDevicePixelRatioReturn => {\n  const supported =\n    typeof window !== 'undefined' &&\n    typeof window.matchMedia === 'function' &&\n    typeof window.devicePixelRatio === 'number';\n\n  const [ratio, setRatio] = useState<number>(window.devicePixelRatio ?? 1);\n\n  useEffect(() => {\n    if (!supported) return;\n\n    const onChange = () => setRatio(window.devicePixelRatio);\n\n    const media = window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\n    media.addEventListener('change', onChange);\n    return () => {\n      media.removeEventListener('change', onChange);\n    };\n  }, [ratio]);\n\n  return { supported, ratio };\n};\n", "import { useEffect } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useEvent } from '../useEvent/useEvent';\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use event listener options */\nexport type UseEventListenerOptions = boolean | AddEventListenerOptions;\n\n/** The use event listener return type */\nexport type UseEventListenerReturn<Target extends Element> = StateRef<Target>;\n\nexport interface UseEventListener {\n  <Event extends keyof WindowEventMap = keyof WindowEventMap>(\n    target: HookTarget,\n    event: Event,\n    listener: (this: Window, event: WindowEventMap[Event]) => void,\n    options?: UseEventListenerOptions\n  ): void;\n\n  <Event extends keyof DocumentEventMap = keyof DocumentEventMap>(\n    target: HookTarget,\n    event: Event,\n    listener: (this: Document, event: DocumentEventMap[Event]) => void,\n    options?: UseEventListenerOptions\n  ): void;\n\n  <Event extends keyof HTMLElementEventMap = keyof HTMLElementEventMap>(\n    target: HookTarget,\n    event: Event,\n    listener: (this: Element, event: HTMLElementEventMap[Event]) => void,\n    options?: UseEventListenerOptions\n  ): void;\n\n  <Target extends Element, Event extends keyof HTMLElementEventMap = keyof HTMLElementEventMap>(\n    event: Event,\n    listener: (this: Target, event: HTMLElementEventMap[Event]) => void,\n    options?: UseEventListenerOptions,\n    target?: never\n  ): UseEventListenerReturn<Target>;\n\n  <\n    Target extends Element,\n    Event extends keyof MediaQueryListEventMap = keyof MediaQueryListEventMap\n  >(\n    event: Event,\n    listener: (this: Target, event: MediaQueryListEventMap[Event]) => void,\n    options?: UseEventListenerOptions,\n    target?: never\n  ): UseEventListenerReturn<Target>;\n}\n\n/**\n * @name useEventListener\n * @description - Hook that attaches an event listener to the specified target\n * @category Browser\n *\n * @overload\n * @template Event Key of window event map\n * @param {Window} target The window object to attach the event listener to\n * @param {Event | Event[]} event An array of event types to listen for\n * @param {(this: Window, event: WindowEventMap[Event]) => void} handler The event handler function\n * @param {UseEventListenerOptions} [options] Options for the event listener\n * @returns {void}\n *\n * @example\n * useEventListener(window, 'click', () => console.log('click'));\n *\n * @overload\n * @template Event Key of window event map\n * @param {Document} target The window object to attach the event listener to\n * @param {Event | Event[]} event An array of event types to listen for\n * @param {(this: Document, event: DocumentEventMap[Event]) => void} handler The event handler function\n * @param {UseEventListenerOptions} [options] Options for the event listener\n * @returns {void}\n *\n * @example\n * useEventListener(document, 'click', () => console.log('click'));\n *\n * @overload\n * @template Event Key of window event map\n * @template Target The target element\n * @param {HookTarget} target The target element to attach the event listener to\n * @param {Event | Event[]} event An array of event types to listen for\n * @param {(this: Target, event: HTMLElementEventMap[Event]) => void} handler The event handler function\n * @param {UseEventListenerOptions} [options] Options for the event listener\n * @returns {void}\n *\n * @example\n * useEventListener(ref, 'click', () => console.log('click'));\n *\n * @overload\n * @template Event Key of window event map\n * @template Target The target element\n * @param {Event | Event[]} event An array of event types to listen for\n * @param {(this: Target, event: HTMLElementEventMap[Event] | MediaQueryListEventMap[Event]) => void} handler The event handler function\n * @param {UseEventListenerOptions} [options] Options for the event listener\n * @returns {UseEventListenerReturn<Target>} A reference to the target element\n *\n * @example\n * const ref = useEventListener('click', () => console.log('click'));\n */\nexport const useEventListener = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const event = (target ? params[1] : params[0]) as string;\n  const listener = (target ? params[2] : params[1]) as (...arg: any[]) => undefined | void;\n  const options = (target ? params[3] : params[2]) as UseEventListenerOptions | undefined;\n\n  const internalRef = useRefState(window);\n  const internalListener = useEvent(listener);\n\n  useEffect(() => {\n    const element = target ? getElement(target) : internalRef.current;\n    if (!element) return;\n\n    const callback = (event: Event) => internalListener(event);\n\n    element.addEventListener(event, callback, options);\n    return () => {\n      element.removeEventListener(event, callback, options);\n    };\n  }, [target, internalRef.state, event, options]);\n\n  if (target) return;\n  return internalRef;\n}) as UseEventListener;\n", "import { target } from '@/utils/helpers';\n\nimport type { UseEventListenerOptions } from '../useEventListener/useEventListener';\n\nimport { useEventListener } from '../useEventListener/useEventListener';\n\n/**\n * @name useDocumentEvent\n * @description - Hook attaches an event listener to the document object for the specified event\n * @category Browser\n *\n * @template Event Key of document event map.\n * @param {Event} event The event to listen for.\n * @param {(event: DocumentEventMap[Event]) => void} listener The callback function to be executed when the event is triggered\n * @param {UseEventListenerOptions} [options] The options for the event listener\n * @returns {void}\n *\n * @example\n * useDocumentEvent('click', () => console.log('clicked'));\n */\nexport const useDocumentEvent = <Event extends keyof DocumentEventMap>(\n  event: Event,\n  listener: (this: Document, event: DocumentEventMap[Event]) => any,\n  options?: UseEventListenerOptions\n) => useEventListener(target(document), event, listener, options);\n", "import { useSyncExternalStore } from 'react';\n\nconst getSnapshot = () => document.visibilityState;\nconst getServerSnapshot = () => 'hidden' as const;\nconst subscribe = (callback: () => void) => {\n  document.addEventListener('visibilitychange', callback);\n  return () => {\n    document.removeEventListener('visibilitychange', callback);\n  };\n};\n\n/**\n * @name useDocumentVisibility\n * @description â€“ Hook that provides the current visibility state of the document\n * @category Browser\n *\n * @returns {DocumentVisibilityState} The current visibility state of the document, which can be 'visible' or 'hidden'\n *\n * @example\n * const visibilityState = useDocumentVisibility();\n */\nexport const useDocumentVisibility = () =>\n  useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n", "import { useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect/useIsomorphicLayoutEffect';\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The element size value type */\nexport interface UseElementSizeValue {\n  /** The element's height */\n  height: number;\n  /** The element's width */\n  width: number;\n}\n\n/** The use element size return type */\nexport interface UseElementSizeReturn {\n  value: UseElementSizeValue;\n}\n\nexport interface UseElementSize {\n  (target: HookTarget): UseElementSizeReturn;\n\n  <Target extends Element>(\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n  } & UseElementSizeReturn;\n}\n\n/**\n * @name useElementSize\n * @description - Hook that observes and returns the width and height of element\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to observe\n * @returns {UseElementSizeReturn} An object containing the current width and height of the element\n *\n * @example\n * const { value } = useElementSize(ref);\n *\n * @overload\n * @returns { { ref: StateRef<Target> } & UseElementSizeReturn } An object containing the current width and height of the element\n *\n * @example\n * const { ref, value } = useElementSize();\n */\nexport const useElementSize = ((...params: any[]) => {\n  const target = params[0] as HookTarget | undefined;\n  const [size, setSize] = useState({ width: 0, height: 0 });\n  const internalRef = useRefState<Element>();\n\n  useIsomorphicLayoutEffect(() => {\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n\n    if (!element) return;\n\n    const { width, height } = element.getBoundingClientRect();\n    setSize({\n      width,\n      height\n    });\n\n    const observer = new ResizeObserver(() => {\n      const { width, height } = element.getBoundingClientRect();\n      setSize({ width, height });\n    });\n\n    observer.observe(element);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [internalRef.current, target]);\n\n  if (target) return { value: size };\n  return {\n    ref: internalRef,\n    value: size\n  };\n}) as UseElementSize;\n", "import { useEffect, useRef } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useEvent } from '../useEvent/useEvent';\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use hotkeys params type */\nexport interface UseHotkeysOptions {\n  /** Alias map for hotkeys */\n  alias?: Record<string, string>;\n  /** Enable or disable the event listeners */\n  enabled?: boolean;\n}\n\nexport const isHotkeyMatch = (hotkey: string, keys: UseHotkeysKey[]) =>\n  hotkey\n    .toLowerCase()\n    .split(/[+_,\\-]/g)\n    .map((key) => key.trim())\n    .every((key) =>\n      keys.find(\n        (updatedKey) =>\n          key === updatedKey.code.toLocaleLowerCase() ||\n          key === updatedKey.key.toLocaleLowerCase() ||\n          key === updatedKey.alias.toLocaleLowerCase()\n      )\n    );\n\n/** The hotkeys string type */\nexport type UseHotkeysHotkeys = string;\n\n/** The hotkey key information */\nexport interface UseHotkeysKey {\n  /** The alias for the key */\n  alias: string;\n  /** The key code */\n  code: string;\n  /** The key value */\n  key: string;\n}\n\n/** The use hotkeys target type */\nexport type UseHotkeysTarget = Element | React.RefObject<Element | null | undefined>;\n\nexport interface UseHotkeys {\n  (\n    target: UseHotkeysTarget,\n    hotkeys: UseHotkeysHotkeys,\n    callback: (event: KeyboardEvent) => void,\n    options?: UseHotkeysOptions\n  ): void;\n\n  <Target extends Element>(\n    hotkeys: UseHotkeysHotkeys,\n    callback: (event: KeyboardEvent) => void,\n    options?: UseHotkeysOptions,\n    target?: never\n  ): StateRef<Target>;\n}\n\n/**\n * @name useHotkeys\n * @description - Hook that listens for hotkeys\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} [target=window] The target element to attach the event listener to\n * @param {string} hotkeys The hotkey to listen for\n * @param {(event: KeyboardEvent) => void} callback The callback function to execute when hotkey is pressed\n * @param {Record<string, string>} [options.alias] Alias map for hotkeys\n * @param {boolean} [options.enabled=true] Enable or disable the event listeners\n * @returns {void}\n *\n * @example\n * useHotkeys(ref, 'ctrl+a', () => console.log('hotkey pressed'));\n * @example\n * useHotkeys(ref, 'ctrl+a, ctrl+b', () => console.log('hotkey pressed'));\n *\n * @overload\n * @template Target The target element\n * @param {string} hotkeys The hotkey to listen for\n * @param {(event: KeyboardEvent) => void} callback The callback function to execute when hotkey is pressed\n * @param {Record<string, string>} [options.alias] Alias map for hotkeys\n * @param {boolean} [options.enabled=true] Enable or disable the event listeners\n * @returns {StateRef<Target>} A reference to the target element\n *\n * @example\n * const ref = useHotkeys('ctrl+a', () => console.log('hotkey pressed'));\n * @example\n * const ref = useHotkeys('ctrl+a, ctrl+b', () => console.log('hotkey pressed'));\n */\nexport const useHotkeys = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const hotkeys = (target ? params[1] : params[0]) as UseHotkeysHotkeys;\n  const callback = (target ? params[2] : params[1]) as (event: KeyboardEvent) => void;\n  const options = (target ? params[3] : params[2]) as UseHotkeysOptions | undefined;\n\n  const internalRef = useRefState(window);\n  const keysRef = useRef<UseHotkeysKey[]>([]);\n  const enabled = options?.enabled ?? true;\n\n  const onKeyDown = useEvent((event: KeyboardEvent) => {\n    if (!enabled) return;\n\n    if (keysRef.current.some(({ code }) => code === event.code)) return;\n\n    const alias = options?.alias?.[event.key] ?? event.code;\n    const updatedKeys = [...keysRef.current, { key: event.key, code: event.code, alias }];\n    keysRef.current = updatedKeys;\n\n    const hotkeysList = hotkeys.split(',').map((h) => h.trim());\n    const isMatch = hotkeysList.some((hotkey) => isHotkeyMatch(hotkey, updatedKeys));\n    if (!isMatch) return;\n    event.preventDefault();\n    callback(event);\n  });\n\n  const onKeyUp = useEvent((event: KeyboardEvent) => {\n    if (!enabled) return;\n    keysRef.current = keysRef.current.filter(({ code }) => code !== event.code);\n  });\n\n  useEffect(() => {\n    keysRef.current = [];\n    if (!target && !internalRef.state && !enabled) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    element.addEventListener('keydown', onKeyDown as EventListener);\n    element.addEventListener('keyup', onKeyUp as EventListener);\n\n    return () => {\n      element.removeEventListener('keydown', onKeyDown as EventListener);\n      element.removeEventListener('keyup', onKeyUp as EventListener);\n    };\n  }, [target, internalRef.state, enabled, hotkeys, onKeyDown, onKeyUp]);\n\n  if (target) return;\n  return internalRef;\n}) as UseHotkeys;\n", "import { useEffect, useState } from 'react';\n\nimport { throttle } from '@/utils/helpers';\n\n/** The use idle options type */\nexport interface UseIdleOptions {\n  /** The idle events */\n  events?: Array<keyof DocumentEventMap>;\n  /** The idle state */\n  initialValue?: boolean;\n}\n\nconst IDLE_EVENTS = [\n  'mousemove',\n  'mousedown',\n  'keydown',\n  'touchstart',\n  'wheel',\n  'resize'\n] satisfies Array<keyof DocumentEventMap>;\nconst ONE_MINUTE = 60e3;\n\n/** The use idle return type */\nexport interface UseIdleReturn {\n  /** The idle state */\n  idle: boolean;\n  /** The last active time */\n  lastActive: number;\n}\n\n/**\n * @name useIdle\n * @description - Hook that defines the logic when the user is idle\n * @category Sensors\n *\n * @param {number} [milliseconds=ONE_MINUTE] The idle time in milliseconds\n * @param {boolean} [options.initialState=false] The options for the hook\n * @param {Array<keyof WindowEventMap>} [options.events=IDLE_EVENTS]\n * @returns {UseIdleReturn} An object containing the idle state and the last active time\n *\n * @example\n * const { idle, lastActive } = useIdle();\n */\nexport const useIdle = (\n  milliseconds = ONE_MINUTE,\n  { initialValue = false, events = IDLE_EVENTS }: UseIdleOptions = {}\n): UseIdleReturn => {\n  const [idle, setIdle] = useState(initialValue);\n  const [lastActive, setLastActive] = useState(Date.now());\n\n  useEffect(() => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const onTimeout = () => setIdle(true);\n\n    const onEvent = throttle(() => {\n      setIdle(false);\n      setLastActive(Date.now());\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(onTimeout, milliseconds);\n    }, 500);\n\n    const onVisibilitychange = () => {\n      if (!document.hidden) onEvent();\n    };\n\n    timeoutId = setTimeout(onTimeout, milliseconds);\n\n    events.forEach((event) => window.addEventListener(event, onEvent));\n    document.addEventListener('visibilitychange', onVisibilitychange);\n\n    return () => {\n      events.forEach((event) => window.addEventListener(event, onEvent));\n      document.removeEventListener('visibilitychange', onVisibilitychange);\n      clearTimeout(timeoutId);\n    };\n  }, [milliseconds, events]);\n\n  return { idle, lastActive };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use infinite scroll options type */\nexport interface UseInfiniteScrollOptions {\n  /** The direction to trigger the callback */\n  direction?: 'bottom' | 'left' | 'right' | 'top';\n  /** The distance in pixels to trigger the callback */\n  distance?: number;\n}\n\nexport interface UseInfiniteScroll {\n  (\n    target: HookTarget,\n    callback: (event: Event) => void,\n    options?: UseInfiniteScrollOptions\n  ): boolean;\n\n  <Target extends Element>(\n    callback: (event: Event) => void,\n    options?: UseInfiniteScrollOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n    loading: boolean;\n  };\n}\n\n/**\n * @name useInfiniteScroll\n * @description - Hook that defines the logic for infinite scroll\n * @category Sensors\n *\n * @overload\n * @template Target The target element\n * @param {(event: Event) => void} callback The callback to execute when a click outside the target is detected\n * @param {number} [options.distance=10] The distance in pixels to trigger the callback\n * @param {string} [options.direction='bottom'] The direction to trigger the callback\n * @returns {{ ref: StateRef<Target>, loading: boolean }} An object containing the ref and loading\n *\n * @example\n * const { ref, loading } = useInfiniteScroll(() => console.log('infinite scroll'));\n *\n * @overload\n * @param {HookTarget} target The target element to detect infinite scroll for\n * @param {(event: Event) => void} callback The callback to execute when a click outside the target is detected\n * @param {number} [options.distance=10] The distance in pixels to trigger the callback\n * @param {string} [options.direction='bottom'] The direction to trigger the callback\n * @returns {boolean} A loading indicator of the infinite scroll\n *\n * @example\n * const loading = useInfiniteScroll(ref, () => console.log('infinite scroll'));\n */\nexport const useInfiniteScroll = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const callback = (target ? params[1] : params[0]) as (event: Event) => void;\n  const options = (target ? params[2] : params[1]) as UseInfiniteScrollOptions | undefined;\n\n  const direction = options?.direction ?? 'bottom';\n  const distance = options?.distance ?? 10;\n\n  const [loading, setIsLoading] = useState(false);\n\n  const internalRef = useRefState<Element>();\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n  const internalLoadingRef = useRef(loading);\n  internalLoadingRef.current = loading;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const onLoadMore = async (event: Event) => {\n      if (internalLoadingRef.current) return;\n\n      const { clientHeight, scrollHeight, scrollTop, clientWidth, scrollWidth, scrollLeft } =\n        event.target as Element;\n      const scrollBottom = scrollHeight - (scrollTop + clientHeight);\n      const scrollRight = scrollWidth - (scrollLeft + clientWidth);\n\n      const distances = {\n        bottom: scrollBottom,\n        top: scrollTop,\n        right: scrollRight,\n        left: scrollLeft\n      };\n\n      if (distances[direction] <= distance) {\n        setIsLoading(true);\n        await internalCallbackRef.current(event);\n        setIsLoading(false);\n      }\n    };\n\n    element.addEventListener('scroll', onLoadMore);\n\n    return () => {\n      element.removeEventListener('scroll', onLoadMore);\n    };\n  }, [target, internalRef.state, direction, distance]);\n\n  if (target) return loading;\n  return {\n    ref: internalRef,\n    loading\n  };\n}) as UseInfiniteScroll;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nexport type UseIntersectionObserverCallback = (entry: IntersectionObserverEntry) => void;\n\n/** The intersection observer options type */\nexport interface UseIntersectionObserverOptions extends Omit<IntersectionObserverInit, 'root'> {\n  enabled?: boolean;\n  onChange?: UseIntersectionObserverCallback;\n  root?: HookTarget;\n}\n\n/** The intersection observer return type */\nexport interface UseIntersectionObserverReturn {\n  entry?: IntersectionObserverEntry;\n  inView: boolean;\n}\n\nexport interface UseIntersectionObserver {\n  <Target extends Element>(\n    options?: UseIntersectionObserverOptions,\n    target?: never\n  ): UseIntersectionObserverReturn & { ref: StateRef<Target> };\n\n  (target: HookTarget, options?: UseIntersectionObserverOptions): UseIntersectionObserverReturn;\n\n  <Target extends Element>(\n    callback: UseIntersectionObserverCallback,\n    target?: never\n  ): UseIntersectionObserverReturn & { ref: StateRef<Target> };\n\n  (callback: UseIntersectionObserverCallback, target: HookTarget): UseIntersectionObserverReturn;\n}\n\n/**\n * @name useIntersectionObserver\n * @description - Hook that gives you intersection observer state\n * @category Sensors\n *\n * @browserapi IntersectionObserver https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver\n *\n * @overload\n * @param {HookTarget} target The target element to detect intersection\n * @param {boolean} [options.enabled=true] The IntersectionObserver options\n * @param {((entries: IntersectionObserverEntry[], observer: IntersectionObserver) => void) | undefined} [options.onChange] The callback to execute when intersection is detected\n * @param {HookTarget} [options.root=document] The root element to observe\n * @returns {UseIntersectionObserverReturn} An object containing the state\n *\n * @example\n * const { ref, entry, inView } = useIntersectionObserver();\n *\n * @overload\n * @template Target The target element\n * @param {boolean} [options.enabled=true] The IntersectionObserver options\n * @param {((entries: IntersectionObserverEntry[], observer: IntersectionObserver) => void) | undefined} [options.onChange] The callback to execute when intersection is detected\n * @param {HookTarget} [options.root=document] The root element to observe\n * @returns {UseIntersectionObserverReturn & { ref: StateRef<Target> }} A React ref to attach to the target element\n *\n * @example\n * const { entry, inView } = useIntersectionObserver(ref);\n *\n * @overload\n * @template Target The target element\n * @param {UseIntersectionObserverCallback} callback The callback to execute when intersection is detected\n * @returns {UseIntersectionObserverReturn & { ref: StateRef<Target> }} A React ref to attach to the target element\n *\n * @example\n * const { ref, entry, inView } = useIntersectionObserver(() => console.log('callback'));\n *\n * @overload\n * @param {UseIntersectionObserverCallback} callback The callback to execute when intersection is detected\n * @param {HookTarget} target The target element to detect intersection\n * @returns {UseIntersectionObserverReturn} An object containing the state\n *\n * @example\n * const { entry, inView } = useIntersectionObserver(() => console.log('callback'), ref);\n */\nexport const useIntersectionObserver = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { onChange: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { onChange: params[0] }\n  ) as UseIntersectionObserverOptions | undefined;\n\n  const callback = options?.onChange;\n  const enabled = options?.enabled ?? true;\n\n  const [entry, setEntry] = useState<IntersectionObserverEntry>();\n\n  const internalRef = useRefState<Element>();\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  useEffect(() => {\n    if (!enabled || (!target && !internalRef.state)) return;\n\n    const element = target ? getElement(target) : internalRef.current;\n    if (!element) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setEntry(entry);\n        internalCallbackRef.current?.(entry);\n      },\n      {\n        ...options,\n        root: options?.root ? (getElement(options.root) as Document | Element) : document\n      }\n    );\n\n    observer.observe(element as Element);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [target, internalRef.state, options?.rootMargin, options?.threshold, options?.root, enabled]);\n\n  if (target) return { entry, inView: !!entry?.isIntersecting };\n  return {\n    ref: internalRef,\n    entry,\n    inView: !!entry?.isIntersecting\n  };\n}) as UseIntersectionObserver;\n", "import { useEffect, useRef } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use keyboard event handler type */\nexport type KeyboardEventHandler = (event: KeyboardEvent) => void;\n\n/** The use keyboard event options type */\nexport interface UseKeyboardEventOptions {\n  /** The callback function to be invoked on key down */\n  onKeyDown?: KeyboardEventHandler;\n  /** The callback function to be invoked on key up */\n  onKeyUp?: KeyboardEventHandler;\n}\n\nexport interface UseKeyboard {\n  (target: HookTarget, callback: KeyboardEventHandler): void;\n\n  (target: HookTarget, options: UseKeyboardEventOptions): void;\n\n  <Target extends HTMLElement>(\n    callback: KeyboardEventHandler,\n    target?: never\n  ): { ref: StateRef<Target> };\n\n  <Target extends HTMLElement>(\n    options: UseKeyboardEventOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n  };\n}\n\n/**\n * @name useKeyboard\n * @description - Hook that helps to listen for keyboard events\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} target The target to attach the event listeners to\n * @param {KeyboardEventHandler} callback The callback function to be invoked on key down\n * @returns {void}\n *\n * @example\n * useKeyboard(ref, (event) => console.log('key down'));\n *\n * @overload\n * @param {HookTarget} target The target to attach the event listeners to\n * @param {UseKeyboardEventOptions} [options] The keyboard event options\n * @returns {void}\n *\n * @example\n * useKeyboard(ref, { onKeyDown: (event) => console.log('key down'), onKeyUp: (event) => console.log('key up') });\n *\n * @overload\n * @template Target The target element type\n * @param {KeyboardEventHandler} callback The callback function to be invoked on key down\n * @returns {{ ref: StateRef<Target> }} An object containing the ref\n *\n * @example\n * const ref = useKeyboard((event) => console.log('key down'));\n *\n * @overload\n * @template Target The target element type\n * @param {UseKeyboardEventOptions} [options] The keyboard event options\n * @returns {{ ref: StateRef<Target> }} An object containing the ref\n *\n * @example\n * const ref = useKeyboard({ onKeyDown: (event) => console.log('key down'), onKeyUp: (event) => console.log('key up') });\n */\nexport const useKeyboard = ((...params: any[]) => {\n  const target = isTarget(params[0]) ? params[0] : undefined;\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { onKeyDown: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { onKeyDown: params[0] }\n  ) as UseKeyboardEventOptions;\n\n  const internalRef = useRefState(window);\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as HTMLElement;\n    if (!element) return;\n\n    const onKeyDown = (event: Event) =>\n      internalOptionsRef.current?.onKeyDown?.(event as KeyboardEvent);\n    const onKeyUp = (event: Event) => internalOptionsRef.current?.onKeyUp?.(event as KeyboardEvent);\n\n    element.addEventListener('keydown', onKeyDown);\n    element.addEventListener('keyup', onKeyUp);\n\n    return () => {\n      element.removeEventListener('keydown', onKeyDown);\n      element.removeEventListener('keyup', onKeyUp);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return;\n  return internalRef;\n}) as UseKeyboard;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The key or keys to listen for */\nexport type UseKeyPressKey = string | string[];\n\n/** The callback function to be invoked when key is pressed */\nexport type UseKeyPressCallback = (pressed: boolean, event: KeyboardEvent) => void;\n\nexport interface UseKeyPress {\n  (target: HookTarget | Window, key: UseKeyPressKey, callback?: UseKeyPressCallback): boolean;\n\n  <Target extends Element>(\n    key: UseKeyPressKey,\n    callback?: UseKeyPressCallback,\n    target?: never\n  ): { pressed: boolean; ref: StateRef<Target> };\n}\n\n/**\n * @name useKeyPress\n * @description - Hook that listens for key press events\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} [target=window] The target to attach the event listeners to\n * @param {UseKeyPressKey} key The key or keys to listen for\n * @param {(pressed: boolean, event: KeyboardEvent) => void} [callback] Callback function invoked when key is pressed\n * @returns {boolean} The pressed state of the key\n *\n * @example\n * const isKeyPressed = useKeyPress(ref, 'a');\n *\n * @overload\n * @template Target The target element type\n * @param {UseKeyPressKey} key The key or keys to listen for\n * @param {(pressed: boolean, event: KeyboardEvent) => void} [callback] Callback function invoked when key is pressed\n * @returns {{ pressed: boolean; ref: StateRef<Target> }} An object containing the pressed state and ref\n *\n * @example\n * const { pressed, ref } = useKeyPress('a');\n */\nexport const useKeyPress = ((...params: any[]) => {\n  const target = isTarget(params[0]) ? params[0] : undefined;\n  const key = (target ? params[1] : params[0]) as UseKeyPressKey;\n  const callback = (target ? params[2] : params[1]) as UseKeyPressCallback | undefined;\n\n  const [pressed, setPressed] = useState(false);\n  const internalRef = useRefState(window);\n\n  const keyRef = useRef(key);\n  keyRef.current = key;\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const onKeyDown = (event: Event) => {\n      const keyboardEvent = event as KeyboardEvent;\n      if (\n        Array.isArray(keyRef.current)\n          ? keyRef.current.includes(keyboardEvent.key)\n          : keyboardEvent.key === keyRef.current\n      ) {\n        setPressed(true);\n        internalCallbackRef.current?.(true, keyboardEvent);\n      }\n    };\n\n    const onKeyUp = (event: Event) => {\n      const keyboardEvent = event as KeyboardEvent;\n      if (\n        Array.isArray(keyRef.current)\n          ? keyRef.current.includes(keyboardEvent.key)\n          : keyboardEvent.key === keyRef.current\n      ) {\n        setPressed(false);\n        internalCallbackRef.current?.(false, keyboardEvent);\n      }\n    };\n\n    element.addEventListener('keydown', onKeyDown);\n    element.addEventListener('keyup', onKeyUp);\n\n    return () => {\n      element.removeEventListener('keydown', onKeyDown);\n      element.removeEventListener('keyup', onKeyUp);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return pressed;\n  return { pressed, ref: internalRef };\n}) as UseKeyPress;\n", "import { useEffect, useRef } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The key or keys to listen for */\nexport type UseKeyPressEventKey = string | string[];\n\n/** The use key press event options type */\nexport interface UseKeyPressEventOptions {\n  /** Whether the event should be captured */\n  capture?: boolean;\n  /** Whether the event listener should only be triggered once */\n  once?: boolean;\n  /** Whether the event listener should be passive */\n  passive?: boolean;\n}\n\nexport interface UseKeyPressEvent {\n  (\n    target: HookTarget | Window,\n    key: UseKeyPressEventKey,\n    listener: (event: KeyboardEvent) => void,\n    options?: UseKeyPressEventOptions\n  ): void;\n\n  <Target extends Element>(\n    key: UseKeyPressEventKey,\n    listener: (event: KeyboardEvent) => void,\n    options?: UseKeyPressEventOptions,\n    target?: never\n  ): { ref: StateRef<Target> };\n}\n\n/**\n * @name useKeyPressEvent\n * @description - Hook that listens for key press events on specified targets\n * @category Sensors\n *\n * @overload\n * @param {UseKeyPressEventKey} key The key or array of keys to listen for.\n * @param {HookTarget | Window} target The target to attach the event listener to.\n * @param {(event: KeyboardEvent) => void} listener The callback function to be executed when the specified key or keys are pressed.\n * @param {UseKeyPressEventOptions} [options] The options for the event listener.\n * @returns {void}\n *\n * @example\n * useKeyPressEvent(ref, 'Enter', () => console.log('pressed'));\n *\n * @overload\n * @template Target extends Element\n * @param {UseKeyPressEventKey} key The key or array of keys to listen for.\n * @param {(event: KeyboardEvent) => void} listener The callback function to be executed when the specified key or keys are pressed.\n * @param {UseKeyPressEventOptions} [options] The options for the event listener.\n * @returns {{ ref: StateRef<Target> }} An object containing the ref\n *\n * @example\n * const ref = useKeyPressEvent('Enter', (event) => console.log('pressed'));\n */\nexport const useKeyPressEvent = ((...params: any[]) => {\n  const target = isTarget(params[0]) ? params[0] : undefined;\n  const key = (target ? params[1] : params[0]) as UseKeyPressEventKey;\n  const listener = (target ? params[2] : params[1]) as (event: KeyboardEvent) => void;\n  const options = (target ? params[3] : params[2]) as UseKeyPressEventOptions | undefined;\n\n  const internalRef = useRefState(window);\n\n  const keyRef = useRef(key);\n  keyRef.current = key;\n  const listenerRef = useRef(listener);\n  listenerRef.current = listener;\n\n  useEffect(() => {\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const onKeyDown = (event: Event) => {\n      const keyboardEvent = event as KeyboardEvent;\n      const keys = Array.isArray(keyRef.current) ? keyRef.current : [keyRef.current];\n      if (keys.includes(keyboardEvent.key)) {\n        listenerRef.current(keyboardEvent);\n      }\n    };\n\n    element.addEventListener('keydown', onKeyDown, {\n      capture: options?.capture,\n      passive: options?.passive,\n      once: options?.once\n    });\n\n    return () => {\n      element.removeEventListener('keydown', onKeyDown, {\n        capture: options?.capture\n      });\n    };\n  }, [target, internalRef.state, options?.capture, options?.passive, options?.once]);\n\n  if (target) return;\n  return internalRef;\n}) as UseKeyPressEvent;\n", "import { useEffect, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use keys pressed options type */\nexport interface UseKeysPressedOptions {\n  /** Enable or disable the event listeners */\n  enabled?: boolean;\n}\n\nexport interface UseKeysPressed {\n  (\n    target: HookTarget | Window,\n    options?: UseKeysPressedOptions\n  ): Array<{\n    key: string;\n    code: string;\n  }>;\n\n  <Target extends Element>(\n    options?: UseKeysPressedOptions\n  ): {\n    value: Array<{ key: string; code: string }>;\n    ref: StateRef<Target>;\n  };\n}\n\n/**\n * Hook that tracks which keyboard keys are currently pressed\n *\n * @name useKeysPressed\n * @description Tracks all currently pressed keyboard keys and their codes\n * @category Sensors\n *\n * @overload\n * @param {HookTarget | Window} target DOM element or ref to attach keyboard listeners to\n * @param {UseKeysPressedOptions} [options.enabled=true] Enable or disable the event listeners\n * @returns {Array<{ key: string; code: string }>} Array of currently pressed keys with their key and code values\n *\n * @example\n * const pressedKeys = useKeysPressed(ref);\n *\n * @overload\n * @template Target - Type of the target DOM element\n * @param {UseKeysPressedOptions} [options] - Optional configuration options\n * @returns {{ keys: Array<{ key: string; code: string }>; ref: StateRef<Target> }} Object containing pressed keys array and ref to attach to a DOM element\n *\n * @example\n * const { value, ref } = useKeysPressed();\n */\nexport const useKeysPressed = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (target ? params[1] : params[0]) as UseKeysPressedOptions | undefined;\n\n  const enabled = options?.enabled ?? true;\n  const [value, setValue] = useState<{ key: string; code: string }[]>([]);\n  const internalRef = useRefState(window);\n\n  useEffect(() => {\n    if (!enabled) return;\n    setValue([]);\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const onKeyDown = (event: Event) => {\n      const keyboardEvent = event as KeyboardEvent;\n      setValue((prevValue) => {\n        if (prevValue.some(({ code }) => code === keyboardEvent.code)) return prevValue;\n        return [...prevValue, { key: keyboardEvent.key, code: keyboardEvent.code }];\n      });\n    };\n\n    const onKeyUp = (event: Event) => {\n      const keyboardEvent = event as KeyboardEvent;\n      setValue((prevValue) => prevValue.filter(({ code }) => code !== keyboardEvent.code));\n    };\n\n    element.addEventListener('keydown', onKeyDown);\n    element.addEventListener('keyup', onKeyUp);\n\n    return () => {\n      element.removeEventListener('keydown', onKeyDown);\n      element.removeEventListener('keyup', onKeyUp);\n    };\n  }, [enabled, internalRef.state, target]);\n\n  if (target) return value;\n  return { value, ref: internalRef };\n}) as UseKeysPressed;\n", "import { useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect/useIsomorphicLayoutEffect';\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use lock scroll options type */\nexport interface UseLockScrollOptions {\n  /** Enable or disable scroll locking. Default: true */\n  enabled?: boolean;\n}\n\n/** The use lock scroll return type */\nexport interface UseLockScrollReturn<Target extends Element> {\n  /** The ref to attach to the element */\n  ref: StateRef<Target>;\n  /** The value of the lock state */\n  value: boolean;\n  /** Lock the scroll */\n  lock: () => void;\n  /** Toggle the scroll lock */\n  toggle: () => void;\n  /** Unlock the scroll */\n  unlock: () => void;\n}\n\nexport interface UseLockScroll {\n  (target: HookTarget, options?: UseLockScrollOptions): UseLockScrollReturn<Element>;\n\n  <Target extends Element>(\n    options?: UseLockScrollOptions,\n    target?: never\n  ): UseLockScrollReturn<Target> & { ref: StateRef<Target> };\n}\n\n/**\n * @name useLockScroll\n * @description - Hook that locks scroll on an element or document body\n * @category Elements\n *\n *\n * @overload\n * @param {HookTarget} [target=document.body] The target element to lock scroll on\n * @param {UseLockScrollOptions} [options] The options for scroll locking\n * @returns {void}\n *\n * @example\n * const { lock, unlock, value, toggle } = useLockScroll(ref);\n *\n * @overload\n * @template Target The target element\n * @param {UseLockScrollOptions} [options] The options for scroll locking\n * @returns {StateRef<Target>} Ref to attach to element, or locks body scroll by default\n *\n * @example\n * const { ref, lock, unlock, value, toggle } = useLockScroll();\n */\nexport const useLockScroll = ((...params: any[]): any => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (target ? params[1] : params[0]) as UseLockScrollOptions | undefined;\n\n  const enabled = options?.enabled ?? true;\n  const [locked, setLocked] = useState(enabled);\n\n  const internalRef = useRefState<Element>();\n\n  const elementRef = useRef<Element>(null);\n\n  useIsomorphicLayoutEffect(() => {\n    const element =\n      ((target ? getElement(target) : internalRef.current) as Element) ?? document.body;\n\n    if (!(element instanceof HTMLElement)) return;\n\n    elementRef.current = element;\n\n    if (!enabled) return;\n\n    const originalStyle = window.getComputedStyle(element).overflow;\n    (elementRef.current as any).__originalOverflow = originalStyle;\n    element.style.overflow = 'hidden';\n\n    return () => {\n      element.style.overflow = originalStyle;\n      elementRef.current = null;\n    };\n  }, [target, internalRef.state, enabled]);\n\n  const lock = () => {\n    if (!elementRef.current) return;\n    const element = elementRef.current as HTMLElement;\n    (elementRef.current as any).__originalOverflow = window.getComputedStyle(element).overflow;\n    element.style.overflow = 'hidden';\n    setLocked(true);\n  };\n\n  const unlock = () => {\n    console.log('unlock', (elementRef.current as any).__originalOverflow);\n    if (!elementRef.current) return;\n    const element = elementRef.current as HTMLElement;\n    element.style.overflow = (elementRef.current as any).__originalOverflow;\n    setLocked(false);\n  };\n\n  const toggle = () => {\n    console.log('toggle', locked, locked ? 'unlock' : 'lock');\n    if (locked) return unlock();\n    lock();\n  };\n\n  if (target)\n    return {\n      value: locked,\n      lock,\n      unlock,\n      toggle\n    };\n  return {\n    ref: internalRef,\n    value: locked,\n    lock,\n    unlock,\n    toggle\n  };\n}) as UseLockScroll;\n", "import { useEffect, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use measure return type */\nexport type UseMeasureReturn = Pick<\n  DOMRectReadOnly,\n  'bottom' | 'height' | 'left' | 'right' | 'top' | 'width' | 'x' | 'y'\n>;\n\nexport interface UseMeasure {\n  (target: HookTarget): UseMeasureReturn;\n\n  <Target extends Element>(\n    target?: never\n  ): UseMeasureReturn & {\n    ref: StateRef<Target>;\n  };\n}\n\n/**\n * @name useMeasure\n * @description - Hook to measure the size and position of an element\n * @category Browser\n *\n * @overload\n * @param {HookTarget} target The element to measure\n * @returns {UseMeasureReturn} The element's size and position\n *\n * @example\n * const { x, y, width, height, top, left, bottom, right } = useMeasure(ref);\n *\n * @overload\n * @template Target The element to measure\n * @returns {UseMeasureReturn & { ref: StateRef<Target> }} The element's size and position\n *\n * @example\n * const { ref, x, y, width, height, top, left, bottom, right } = useMeasure();\n */\nexport const useMeasure = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n\n  const internalRef = useRefState<Element>();\n  const [rect, setRect] = useState({\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0\n  });\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      const entry = entries[0];\n      if (!entry) return;\n\n      const { x, y, width, height, top, left, bottom, right } = entry.contentRect;\n      setRect({ x, y, width, height, top, left, bottom, right });\n    });\n\n    resizeObserver.observe(element);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return rect;\n  return { ref: internalRef, ...rect };\n}) as UseMeasure;\n", "import { useCallback, useSyncExternalStore } from 'react';\n\nconst getServerSnapshot = () => false;\n\n/**\n * @name useMediaQuery\n * @description - Hook that manages a media query\n * @category Browser\n *\n * @browserapi window.matchMedia https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia\n *\n * @param {string} query The media query string\n * @returns {boolean} A boolean indicating if the media query matches\n *\n * @example\n * const matches = useMediaQuery('(max-width: 768px)');\n */\nexport const useMediaQuery = (query: string) => {\n  const subscribe = useCallback(\n    (callback: () => void) => {\n      const matchMedia = window.matchMedia(query);\n\n      matchMedia.addEventListener('change', callback);\n      return () => {\n        matchMedia.removeEventListener('change', callback);\n      };\n    },\n    [query]\n  );\n\n  const getSnapshot = () => window.matchMedia(query).matches;\n\n  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n};\n", "import { useEffect, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use mouse return type */\nexport interface UseMouseReturn {\n  /** The current mouse client x position */\n  clientX: number;\n  /** The current mouse client y position */\n  clientY: number;\n  /** The current element position x */\n  elementPositionX: number;\n  /** The current element position y */\n  elementPositionY: number;\n  /** The current element x position */\n  elementX: number;\n  /** The current element y position */\n  elementY: number;\n  /** The current mouse x position */\n  x: number;\n  /** The current mouse y position */\n  y: number;\n}\n\nexport interface UseMouse {\n  (target: HookTarget): UseMouseReturn;\n\n  <Target extends Element>(\n    target?: never\n  ): UseMouseReturn & {\n    ref: StateRef<Target>;\n  };\n\n  (target?: Window): UseMouseReturn;\n}\n\n/**\n * @name useMouse\n * @description - Hook that manages a mouse position\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} [target=window] The target element to manage the mouse position for\n * @returns {UseMouseReturn} An object with the current mouse position\n *\n * @example\n * const { x, y, clientX, clientY, elementX, elementY, elementPositionX, elementPositionY } = useMouse(ref);\n *\n * @overload\n * @template Target The target element\n * @returns {UseMouseReturn & { ref: StateRef<Target> }} An object with the current mouse position and a ref\n *\n * @example\n * const { ref, x, y, clientX, clientY, elementX, elementY, elementPositionX, elementPositionY } = useMouse();\n */\nexport const useMouse = ((...params: any[]) => {\n  const target = isTarget(params[0]) ? params[0] : undefined;\n\n  const [value, setValue] = useState<UseMouseReturn>({\n    x: 0,\n    y: 0,\n    elementX: 0,\n    elementY: 0,\n    elementPositionX: 0,\n    elementPositionY: 0,\n    clientX: 0,\n    clientY: 0\n  });\n\n  const internalRef = useRefState<Element>();\n\n  useEffect(() => {\n    const onMouseMove = (event: MouseEvent) => {\n      const element = (target ? getElement(target) : internalRef.current) as Element | undefined;\n\n      const updatedValue = {\n        x: event.pageX,\n        y: event.pageY,\n        clientX: event.clientX,\n        clientY: event.clientY\n      } as typeof value;\n\n      if (element) {\n        const { left, top } = element.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        updatedValue.elementX = elementX;\n        updatedValue.elementY = elementY;\n        updatedValue.elementPositionX = elementPositionX;\n        updatedValue.elementPositionY = elementPositionY;\n\n        setValue((prevValue) => ({\n          ...prevValue,\n          ...updatedValue\n        }));\n      } else {\n        updatedValue.elementX = event.pageX;\n        updatedValue.elementY = event.pageY;\n        updatedValue.elementPositionX = 0;\n        updatedValue.elementPositionY = 0;\n\n        setValue((prevValue) => ({\n          ...prevValue,\n          ...updatedValue\n        }));\n      }\n    };\n\n    const onScroll = () => {\n      setValue((prevValue) => ({\n        ...prevValue,\n        x: prevValue.x + window.scrollX - prevValue.elementPositionX,\n        y: prevValue.y + window.scrollY - prevValue.elementPositionY,\n        elementPositionX: window.scrollX,\n        elementPositionY: window.scrollY\n      }));\n    };\n\n    document.addEventListener('scroll', onScroll, { passive: true });\n    document.addEventListener('mousemove', onMouseMove);\n    return () => {\n      document.removeEventListener('scroll', onScroll);\n      document.removeEventListener('mousemove', onMouseMove);\n    };\n  }, [internalRef.state, target]);\n\n  if (target) return value;\n  return {\n    ref: internalRef,\n    ...value\n  };\n}) as UseMouse;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The mutation observer target element type */\nexport type UseMutationObserverTarget = HookTarget;\n\n/** The mutation observer return type */\nexport interface UseMutationObserverReturn {\n  /** The mutation observer instance */\n  observer: MutationObserver;\n  /** The mutation observer entries */\n  stop: () => void;\n}\n\n/** The mutation observer options type */\nexport interface UseMutationObserverOptions extends MutationObserverInit {\n  /** The enabled state of the mutation observer */\n  enabled?: boolean;\n}\n\nexport interface UseMutationObserver {\n  (\n    target: HookTarget,\n    callback: MutationCallback,\n    options?: UseMutationObserverOptions\n  ): UseMutationObserverReturn;\n\n  <Target extends Element>(\n    callback: MutationCallback,\n    options?: UseMutationObserverOptions,\n    target?: never\n  ): UseMutationObserverReturn & { ref: StateRef<Target> };\n}\n\n/**\n * @name useMutationObserver\n * @description - Hook that gives you mutation observer state\n * @category Sensors\n *\n * @overload\n * @template Target The target element\n * @param {MutationCallback} callback The callback to execute when mutation is detected\n * @param {boolean} [options.enabled=true] The enabled state of the mutation observer\n * @param {boolean} [options.attributes] Set to true if mutations to target's attributes are to be observed\n * @param {boolean} [options.characterData] Set to true if mutations to target's data are to be observed\n * @param {boolean} [options.childList] Set to true if mutations to target's children are to be observed\n * @param {boolean} [options.subtree]  Set to true if mutations to not just target, but also target's descendants are to be observed\n * @param {boolean} [options.characterDataOldValue] Set to true if characterData is set to true or omitted and target's data before the mutation needs to be recorded\n * @param {boolean} [options.attributeOldValue]  Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted\n * @param {string[]} [options.attributeFilter] Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted\n * @returns {UseMutationObserverReturn & { ref: StateRef<Target> }} An object containing the mutation observer state\n *\n * @example\n * const { ref, observer, stop } = useMutationObserver(() => console.log('callback'))\n *\n * @overload\n * @param {HookTarget} target The target element to observe\n * @param {MutationCallback} callback The callback to execute when mutation is detected\n * @param {boolean} [options.enabled=true] The enabled state of the mutation observer\n * @param {boolean} [options.attributes] Set to true if mutations to target's attributes are to be observed\n * @param {boolean} [options.characterData] Set to true if mutations to target's data are to be observed\n * @param {boolean} [options.childList] Set to true if mutations to target's children are to be observed\n * @param {boolean} [options.subtree]  Set to true if mutations to not just target, but also target's descendants are to be observed\n * @param {boolean} [options.characterDataOldValue] Set to true if characterData is set to true or omitted and target's data before the mutation needs to be recorded\n * @param {boolean} [options.attributeOldValue]  Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted\n * @param {string[]} [options.attributeFilter] Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted\n * @returns {UseMutationObserverReturn} An object containing the mutation observer state\n *\n * @example\n * const { observer, stop } = useMutationObserver(ref, () => console.log('callback'))\n */\nexport const useMutationObserver = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const callback = (target ? params[1] : params[0]) as MutationCallback;\n  const options = (target ? params[2] : params[1]) as UseMutationObserverOptions | undefined;\n\n  const [observer, setObserver] = useState<MutationObserver>();\n  const enabled = options?.enabled ?? true;\n\n  const internalRef = useRefState<Element>(window.document.documentElement);\n  const internalCallbackRef = useRef<MutationCallback>(callback);\n  internalCallbackRef.current = callback;\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  useEffect(() => {\n    if (!enabled || (!target && !internalRef.state)) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const observer = new MutationObserver(internalCallbackRef.current);\n    setObserver(observer);\n    observer.observe(element, internalOptionsRef.current);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [target, internalRef.state]);\n\n  const stop = () => observer?.disconnect();\n\n  if (target) return { stop, observer };\n  return {\n    ref: internalRef,\n    stop,\n    observer\n  };\n}) as UseMutationObserver;\n", "import { useEffect, useState } from 'react';\n\ndeclare global {\n  interface ScreenOrientation {\n    lock: (orientation: OrientationLockType) => Promise<void>;\n  }\n}\n\n/* The use device orientation value type */\nexport interface UseOrientationValue {\n  /** The current angle */\n  angle: number;\n  /** The current orientation type */\n  orientationType: OrientationType;\n}\n\n/* The screen lock orientation type */\nexport type OrientationLockType =\n  | 'any'\n  | 'landscape-primary'\n  | 'landscape-secondary'\n  | 'landscape'\n  | 'natural'\n  | 'portrait-primary'\n  | 'portrait-secondary'\n  | 'portrait';\n\n/* The use device orientation return type */\nexport interface useOrientationReturn {\n  /** Whether the screen orientation is supported */\n  supported: boolean;\n  /** The current screen orientation value */\n  value: UseOrientationValue;\n  /** Lock the screen orientation */\n  lock: (orientation: OrientationLockType) => void;\n  /** Unlock the screen orientation */\n  unlock: () => void;\n}\n\n/**\n * @name useOrientation\n * @description - Hook that provides the current screen orientation\n * @category Sensors\n *\n * @browserapi screen.orientation https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation\n *\n * @returns {useOrientationReturn} The current screen orientation\n *\n * @example\n * const { supported, value, lock, unlock } = useOrientation();\n */\nexport const useOrientation = (): useOrientationReturn => {\n  const supported =\n    typeof window !== 'undefined' && 'screen' in window && 'orientation' in window.screen;\n  const orientation = (supported ? window.screen.orientation : {}) as ScreenOrientation;\n\n  const [value, setValue] = useState<UseOrientationValue>(() => {\n    return {\n      angle: orientation?.angle ?? 0,\n      orientationType: orientation?.type\n    };\n  });\n\n  useEffect(() => {\n    if (!supported) return;\n\n    const onOrientationChange = () =>\n      setValue({\n        angle: orientation.angle,\n        orientationType: orientation.type\n      });\n\n    window.addEventListener('orientationchange', onOrientationChange);\n    return () => {\n      window.removeEventListener('orientationchange', onOrientationChange);\n    };\n  });\n\n  const lock = (type: OrientationLockType) => {\n    if (supported && typeof orientation.lock === 'function') return orientation.lock(type);\n  };\n\n  const unlock = () => {\n    if (supported && typeof orientation.unlock === 'function') orientation.unlock();\n  };\n\n  return {\n    supported,\n    value,\n    lock,\n    unlock\n  };\n};\n", "import { useEffect, useState } from 'react';\n\nimport { useEvent } from '../useEvent/useEvent';\n\n/**\n * @name usePageLeave\n * @description - Hook what calls given function when mouse leaves the page\n * @category Sensors\n *\n * @param {() => void} [callback] The callback function what calls then mouse leaves the page\n * @returns {boolean} A boolean which determines if the mouse left the page\n *\n * @example\n * const isLeft = usePageLeave(() => console.log('on leave'))\n */\nexport const usePageLeave = (callback?: () => void) => {\n  const [isLeft, setIsLeft] = useState(false);\n\n  const onMouse = useEvent(() => {\n    if (isLeft) return setIsLeft(false);\n    callback?.();\n    setIsLeft(true);\n  });\n\n  useEffect(() => {\n    document.addEventListener('mouseleave', onMouse, { passive: true });\n    document.addEventListener('mouseenter', onMouse, { passive: true });\n\n    return () => {\n      document.removeEventListener('mouseenter', onMouse);\n      document.removeEventListener('mouseleave', onMouse);\n    };\n  }, []);\n\n  return isLeft;\n};\n", "import { useEffect, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useDeviceOrientation } from '../useDeviceOrientation/useDeviceOrientation';\nimport { useOrientation } from '../useOrientation/useOrientation';\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use parallax value type */\nexport interface UseParallaxValue {\n  /** Roll value. Scaled to `-0.5 ~ 0.5` */\n  roll: number;\n  /** Sensor source, can be `mouse` or `deviceOrientation` */\n  source: 'deviceOrientation' | 'mouse';\n  /** Tilt value. Scaled to `-0.5 ~ 0.5` */\n  tilt: number;\n}\n\n/** The use parallax options type */\nexport interface UseParallaxOptions {\n  /** Device orientation roll adjust function */\n  deviceOrientationRollAdjust?: (value: number) => number;\n  /** Device orientation tilt adjust function */\n  deviceOrientationTiltAdjust?: (value: number) => number;\n  /** Mouse roll adjust function */\n  mouseRollAdjust?: (value: number) => number;\n  /** Mouse tilt adjust function */\n  mouseTiltAdjust?: (value: number) => number;\n}\n\ninterface UseParallaxReturn {\n  value: UseParallaxValue;\n}\n\nexport interface UseParallax {\n  (target: HookTarget, options?: UseParallaxOptions): UseParallaxReturn;\n\n  <Target extends Element>(\n    options?: UseParallaxOptions,\n    target?: never\n  ): UseParallaxReturn & {\n    ref: StateRef<Target>;\n  };\n}\n\n/**\n * @name useParallax\n * @description - Hook to help create parallax effect\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} target The target element for the parallax effect\n * @param {UseParallaxOptions} options The options for the parallax effect\n * @returns {UseParallaxReturn} An object of parallax values\n *\n * @example\n * const { value } = useParallax(ref);\n *\n * @overload\n * @template Target The target element for the parallax effect\n * @param {UseParallaxOptions} options The options for the parallax effect\n * @returns {UseParallaxReturn & { ref: StateRef<Target> }} An object of parallax values\n *\n * @example\n * const { ref, value } = useParallax();\n */\nexport const useParallax = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (params[1] ? params[1] : params[0]) as UseParallaxOptions | undefined;\n\n  const internalRef = useRefState<Element>();\n\n  const screenOrientation = useOrientation();\n  const deviceOrientation = useDeviceOrientation();\n\n  const {\n    deviceOrientationRollAdjust = (value) => value,\n    deviceOrientationTiltAdjust = (value) => value,\n    mouseRollAdjust = (value) => value,\n    mouseTiltAdjust = (value) => value\n  } = (options ?? {}) as UseParallaxOptions;\n\n  const [value, setValue] = useState({\n    roll: 0,\n    tilt: 0,\n    source: 'mouse'\n  });\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const onMouseMove = (event: MouseEvent) => {\n      const { left, top } = element.getBoundingClientRect();\n      const elementPositionX = left + window.scrollX;\n      const elementPositionY = top + window.scrollY;\n\n      const getSource = () => {\n        const isDeviceOrientation =\n          deviceOrientation.supported &&\n          (deviceOrientation.value.alpha || deviceOrientation.value.gamma);\n\n        if (isDeviceOrientation) return 'deviceOrientation';\n        return 'mouse';\n      };\n\n      const getRoll = () => {\n        const source = getSource();\n        if (source === 'deviceOrientation') {\n          let value: number;\n          switch (screenOrientation.value.orientationType) {\n            case 'landscape-primary':\n              value = deviceOrientation.value.gamma! / 90;\n              break;\n            case 'landscape-secondary':\n              value = -deviceOrientation.value.gamma! / 90;\n              break;\n            case 'portrait-primary':\n              value = -deviceOrientation.value.beta! / 90;\n              break;\n            case 'portrait-secondary':\n              value = deviceOrientation.value.beta! / 90;\n              break;\n            default:\n              value = -deviceOrientation.value.beta! / 90;\n          }\n          return deviceOrientationRollAdjust(value);\n        } else {\n          const y = event.pageY - elementPositionY;\n          const height = element.getBoundingClientRect().height;\n          const value = -(y - height / 2) / height;\n          return mouseRollAdjust(value);\n        }\n      };\n\n      const getTilt = () => {\n        const source = getSource();\n        if (source === 'deviceOrientation') {\n          let value: number;\n          switch (screenOrientation.value.orientationType) {\n            case 'landscape-primary':\n              value = deviceOrientation.value.beta! / 90;\n              break;\n            case 'landscape-secondary':\n              value = -deviceOrientation.value.beta! / 90;\n              break;\n            case 'portrait-primary':\n              value = deviceOrientation.value.gamma! / 90;\n              break;\n            case 'portrait-secondary':\n              value = -deviceOrientation.value.gamma! / 90;\n              break;\n            default:\n              value = deviceOrientation.value.gamma! / 90;\n          }\n          return deviceOrientationTiltAdjust(value);\n        } else {\n          const x = event.pageX - elementPositionX;\n          const width = element.getBoundingClientRect().width;\n          const value = (x - width / 2) / width;\n          return mouseTiltAdjust(value);\n        }\n      };\n\n      const source = getSource();\n      const roll = getRoll();\n      const tilt = getTilt();\n\n      setValue({\n        roll,\n        source,\n        tilt\n      });\n    };\n\n    document.addEventListener('mousemove', onMouseMove);\n    return () => {\n      document.removeEventListener('mousemove', onMouseMove);\n    };\n  }, [\n    target,\n    internalRef.state,\n    screenOrientation.value.angle,\n    screenOrientation.value.orientationType,\n    deviceOrientation.value.gamma,\n    deviceOrientation.value.beta,\n    deviceOrientation.value.alpha,\n    deviceOrientation.value.absolute\n  ]);\n\n  if (target) return { value };\n\n  return {\n    ref: internalRef,\n    value\n  };\n}) as UseParallax;\n", "import { useEffect, useRef, useState } from 'react';\n\n/** The use performance observer options type */\nexport type UsePerformanceObserverOptions = PerformanceObserverInit & {\n  /** Whether to start the observer immediately */\n  immediate?: boolean;\n};\n\n/**\n * @name usePerformanceObserver\n * @description - Hook that allows you to observe performance entries\n * @category Sensors\n *\n * @browserapi PerformanceObserver https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\n *\n * @param {UsePerformanceObserverOptions} options The options for the performance observer\n * @param {PerformanceObserverCallback} callback The function to handle performance entries\n * @returns {object} An object containing the observer's support status and methods to start and stop the observer\n *\n * @example\n * const { supported, entries, start, stop } = usePerformanceObserver();\n */\nexport const usePerformanceObserver = (\n  options: UsePerformanceObserverOptions,\n  callback?: PerformanceObserverCallback\n) => {\n  const supported = typeof window !== 'undefined' && typeof PerformanceObserver !== 'undefined';\n  const [entries, setEntries] = useState<PerformanceEntry[]>([]);\n\n  const observerRef = useRef<PerformanceObserver | null>(null);\n  const internalCallback = useRef<PerformanceObserverCallback | null>(callback);\n  internalCallback.current = callback;\n\n  const start = () => {\n    if (!supported) return;\n    const observer = new PerformanceObserver((entryList, observer) => {\n      setEntries(entryList.getEntries());\n      internalCallback.current?.(entryList, observer);\n    });\n    observer.observe(options);\n    observerRef.current = observer;\n  };\n\n  const stop = () => {\n    if (!supported) return;\n    observerRef.current?.disconnect();\n    observerRef.current = null;\n  };\n\n  useEffect(() => {\n    if (!supported) return;\n    if (options.immediate) start();\n\n    return () => {\n      stop();\n    };\n  }, []);\n\n  return { supported, entries, start, stop };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The resize observer options type */\nexport interface UseResizeObserverOptions extends ResizeObserverOptions {\n  /** The enabled state */\n  enabled?: boolean;\n  /** The resize observer callback */\n  onChange?: (entries: ResizeObserverEntry[], observer: ResizeObserver) => void;\n}\n\n/** The resize observer return type */\nexport interface UseResizeObserverReturn {\n  /** The resize observer entries */\n  entries: ResizeObserverEntry[];\n}\n\nexport interface UseResizeObserver {\n  (target: HookTarget, options?: UseResizeObserverOptions): UseResizeObserverReturn;\n\n  <Target extends Element>(\n    options?: UseResizeObserverOptions,\n    target?: never\n  ): UseResizeObserverReturn & { ref: StateRef<Target> };\n}\n\n/**\n *  @name useResizeObserver\n *  @description - Hook that gives you resize observer state\n *  @category Sensors\n *\n *  @browserapi ResizeObserver https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\n *\n *  @overload\n *  @template Target The target element\n *  @param {boolean} [options.enabled=true] The IntersectionObserver options\n *  @param {boolean} [options.box] The IntersectionObserver options\n *  @param {(entries: ResizeObserverEntry[], observer: ResizeObserver) => void} [options.onChange] The callback to execute when resize is detected\n *  @returns {UseResizeObserverReturn & { ref: StateRef<Target> }} An object containing the resize observer state\n *\n *  @example\n *  const { ref, entries } = useResizeObserver();\n *\n *  @overload\n *  @template Target The target element\n *  @param {HookTarget} target The target element to observe\n *  @param {boolean} [options.enabled=true] The IntersectionObserver options\n *  @param {boolean} [options.box] The IntersectionObserver options\n *  @param {(entries: ResizeObserverEntry[], observer: ResizeObserver) => void} [options.onChange] The callback to execute when resize is detected\n *  @returns {UseResizeObserverReturn} An object containing the resize observer state\n *\n *  @example\n *  const { entries } = useResizeObserver(ref);\n */\nexport const useResizeObserver = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (target ? params[1] : params[0]) as UseResizeObserverOptions | undefined;\n  const enabled = options?.enabled ?? true;\n\n  const [entries, setEntries] = useState<ResizeObserverEntry[]>([]);\n\n  const internalRef = useRefState<Element>();\n  const internalOnChangeRef = useRef<UseResizeObserverOptions['onChange']>(options?.onChange);\n  internalOnChangeRef.current = options?.onChange;\n\n  useEffect(() => {\n    if (!enabled || (!target && !internalRef.state)) return;\n\n    const element = target ? getElement(target) : internalRef.current;\n    if (!element) return;\n\n    const observer = new ResizeObserver((entries) => {\n      setEntries(entries);\n      internalOnChangeRef.current?.(entries, observer);\n    });\n    observer.observe(element as Element, options);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [target, internalRef.state, options?.box, enabled]);\n\n  if (target) return { entries };\n  return {\n    ref: internalRef,\n    entries\n  };\n}) as UseResizeObserver;\n", "import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\n\nexport interface UseScrollOptions {\n  /** The on scroll callback */\n  onScroll?: (params: UseScrollCallbackParams, event: Event) => void;\n\n  /** The on end scroll callback */\n  onStop?: (event: Event) => void;\n\n  /** Offset arrived states by x pixels. */\n  offset?: {\n    left?: number;\n    right?: number;\n    top?: number;\n    bottom?: number;\n  };\n}\n\nexport interface UseScrollCallbackParams {\n  /** The element x position */\n  x: number;\n  /** The element y position */\n  y: number;\n  /** State of scroll arrived */\n  arrived: {\n    left: boolean;\n    right: boolean;\n    top: boolean;\n    bottom: boolean;\n  };\n  /** State of scroll direction */\n  directions: {\n    left: boolean;\n    right: boolean;\n    top: boolean;\n    bottom: boolean;\n  };\n}\n\nexport interface UseScroll {\n  (target: HookTarget, callback?: (params: UseScrollCallbackParams, event: Event) => void): boolean;\n\n  (target: HookTarget, options?: UseScrollOptions): boolean;\n\n  <Target extends Element>(\n    callback?: (params: UseScrollCallbackParams, event: Event) => void,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n    scrolling: boolean;\n  };\n\n  <Target extends Element>(\n    options?: UseScrollOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n    scrolling: boolean;\n  };\n}\n\n/**\n * @name useScroll\n * @description - Hook that allows you to control scroll a element\n * @category Sensors\n *\n * @overload\n * @template Target The target element\n * @param {ScrollBehavior} [options.behavior=auto] The behavior of scrolling\n * @param {number} [options.offset.left=0] The left offset for arrived states\n * @param {number} [options.offset.right=0]  The right offset for arrived states\n * @param {number} [options.offset.top=0] The top offset for arrived states\n * @param {number} [options.offset.bottom=0] The bottom offset for arrived states\n * @param {(params: UseScrollCallbackParams, event: Event) => void} [options.onScroll] The callback function to be invoked on scroll\n * @param {(event: Event) => void} [options.onStop] The callback function to be invoked on scroll end\n * @returns {boolean} The state of scrolling\n *\n * @example\n * const scrolling = useScroll(ref, options);\n *\n * @overload\n * @template Target The target element\n * @param {(params: UseScrollCallbackParams, event: Event) => void} [callback] The callback function to be invoked on scroll\n * @returns {boolean} The state of scrolling\n *\n * @example\n * const scrolling = useScroll(ref, () => console.log('callback'));\n *\n * @overload\n * @template Target The target element\n * @param {Target} target The target element to scroll\n * @param {ScrollBehavior} [options.behavior=auto] The behavior of scrolling\n * @param {number} [options.offset.left=0] The left offset for arrived states\n * @param {number} [options.offset.right=0]  The right offset for arrived states\n * @param {number} [options.offset.top=0] The top offset for arrived states\n * @param {number} [options.offset.bottom=0] The bottom offset for arrived states\n * @param {(params: UseScrollCallbackParams, event: Event) => void} [options.onScroll] The callback function to be invoked on scroll\n * @param {(event: Event) => void} [options.onStop] The callback function to be invoked on scroll end\n * @returns {[StateRef<Target>, boolean]} The state of scrolling\n *\n * @example\n * const { ref, scrolling } = useScroll(options);\n *\n * @overload\n * @template Target The target element\n * @param {Target} target The target element to scroll\n * @param {(params: UseScrollCallbackParams, event: Event) => void} [callback] The callback function to be invoked on scroll\n * @returns {[StateRef<Target>, boolean]} The state of scrolling\n *\n * @example\n * const { ref, scrolling } = useScroll(() => console.log('callback'));\n */\nexport const useScroll = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { onScroll: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { onScroll: params[0] }\n  ) as UseScrollOptions | undefined;\n\n  const internalRef = useRefState<Element>();\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  const [scrolling, setScrolling] = useState(false);\n  const scrollPositionRef = useRef({ x: 0, y: 0 });\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n\n    if (!element) return;\n\n    const onScrollEnd = (event: Event) => {\n      setScrolling(false);\n      options?.onStop?.(event);\n    };\n\n    const onScroll = (event: Event) => {\n      setScrolling(true);\n      const target = (\n        event.target === document ? (event.target as Document).documentElement : event.target\n      ) as HTMLElement;\n\n      const { display, flexDirection, direction } = target.style;\n      const directionMultiplier = direction === 'rtl' ? -1 : 1;\n\n      const scrollLeft = target.scrollLeft;\n      let scrollTop = target.scrollTop;\n      if (target instanceof Document && !scrollTop) scrollTop = window.document.body.scrollTop;\n\n      const offset = internalOptionsRef.current?.offset;\n      const left = scrollLeft * directionMultiplier <= (offset?.left ?? 0);\n      const right =\n        scrollLeft * directionMultiplier + target.clientWidth >=\n        target.scrollWidth - (offset?.right ?? 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n      const top = scrollTop <= (offset?.top ?? 0);\n      const bottom =\n        scrollTop + target.clientHeight >=\n        target.scrollHeight - (offset?.bottom ?? 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n\n      const isColumnReverse = display === 'flex' && flexDirection === 'column-reverse';\n      const isRowReverse = display === 'flex' && flexDirection === 'column-reverse';\n\n      const params = {\n        x: scrollLeft,\n        y: scrollTop,\n        directions: {\n          left: scrollLeft < scrollPositionRef.current.x,\n          right: scrollLeft > scrollPositionRef.current.x,\n          top: scrollTop < scrollPositionRef.current.y,\n          bottom: scrollTop > scrollPositionRef.current.y\n        },\n        arrived: {\n          left: isRowReverse ? right : left,\n          right: isRowReverse ? left : right,\n          top: isColumnReverse ? bottom : top,\n          bottom: isColumnReverse ? top : bottom\n        }\n      };\n\n      scrollPositionRef.current = { x: scrollLeft, y: scrollTop };\n      internalOptionsRef.current?.onScroll?.(params, event);\n    };\n\n    element.addEventListener('scroll', onScroll);\n    element.addEventListener('scrollend', onScrollEnd);\n\n    return () => {\n      element.removeEventListener('scroll', onScroll);\n      element.removeEventListener('scrollend', onScrollEnd);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return scrolling;\n  return {\n    ref: internalRef,\n    scrolling\n  };\n}) as UseScroll;\n", "import { useEffect } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The scroll into view options type */\nexport interface UseScrollIntoViewOptions extends ScrollIntoViewOptions {\n  /** Whether to enable the scroll into view */\n  enabled?: boolean;\n}\n\n/** The scroll into view return type */\nexport interface UseScrollIntoViewReturn {\n  /** Function to scroll element into view */\n  trigger: (params?: {\n    behavior?: ScrollBehavior;\n    block?: ScrollLogicalPosition;\n    inline?: ScrollLogicalPosition;\n  }) => void;\n}\n\nexport interface UseScrollIntoView {\n  <Target extends Element>(\n    options?: UseScrollIntoViewOptions,\n    target?: never\n  ): UseScrollIntoViewReturn & { ref: StateRef<Target> };\n\n  (target: HookTarget, options?: UseScrollIntoViewOptions): UseScrollIntoViewReturn;\n}\n\n/**\n * @name useScrollIntoView\n * @description - Hook that provides functionality to scroll an element into view\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} target The target element to scroll into view\n * @param {ScrollBehavior} [options.behavior='smooth'] The scrolling behavior\n * @param {ScrollLogicalPosition} [options.block='start'] The vertical alignment\n * @param {ScrollLogicalPosition} [options.inline='nearest'] The horizontal alignment\n * @returns {UseScrollIntoViewReturn} Object containing scroll function\n *\n * @example\n * const { trigger } = useScrollIntoView(ref);\n *\n * @overload\n * @template Target The target element\n * @param {ScrollBehavior} [options.behavior='smooth'] The scrolling behavior\n * @param {ScrollLogicalPosition} [options.block='start'] The vertical alignment\n * @param {ScrollLogicalPosition} [options.inline='nearest'] The horizontal alignment\n * @returns {UseScrollIntoViewReturn & { ref: StateRef<Target> }} Object containing scroll function and ref\n *\n * @example\n * const { ref, trigger } = useScrollIntoView<HTMLDivElement>();\n */\nexport const useScrollIntoView = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (target ? params[1] : params[0]) as UseScrollIntoViewOptions | undefined;\n\n  const internalRef = useRefState<Element>();\n  const {\n    behavior = 'smooth',\n    block = 'start',\n    inline = 'nearest',\n    enabled = true\n  } = options ?? {};\n\n  useEffect(() => {\n    if (!enabled) return;\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    element.scrollIntoView({\n      behavior,\n      block,\n      inline\n    });\n  }, [target, internalRef.state, enabled]);\n\n  const trigger = (params?: {\n    behavior?: ScrollBehavior;\n    block?: ScrollLogicalPosition;\n    inline?: ScrollLogicalPosition;\n  }) => {\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const { behavior, block, inline } = params ?? {};\n\n    element.scrollIntoView({\n      behavior,\n      block,\n      inline\n    });\n  };\n\n  if (target) return { trigger };\n  return { ref: internalRef, trigger };\n}) as UseScrollIntoView;\n", "import { useLayoutEffect } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use scroll to options type */\nexport interface UseScrollToOptions {\n  /** The scrolling behavior */\n  behavior?: ScrollBehavior;\n  /** Whether to enable the scroll to */\n  enabled?: boolean;\n  /** The horizontal position to scroll to */\n  x: number;\n  /** The vertical position to scroll to */\n  y: number;\n}\n\n/** The use scroll to return type */\nexport interface UseScrollToReturn {\n  /** The state of scrolling */\n  trigger: (params?: { x: number; y: number; behavior?: ScrollBehavior }) => void;\n}\n\nexport interface UseScrollTo {\n  <Target extends Element>(\n    options?: UseScrollToOptions,\n    target?: never\n  ): UseScrollToReturn & { ref: StateRef<Target> };\n\n  (target: HookTarget, options?: UseScrollToOptions): UseScrollToReturn;\n}\n\n/**\n * @name useScrollTo\n * @description - Hook for scrolling to a specific element\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} target The target element for scrolling to\n * @param {UseScrollToOptions} [options] The scroll options\n * @returns {UseScrollToReturn} The scroll trigger function\n *\n * @example\n * const trigger = useScrollTo(ref, options);\n *\n * @overload\n * @template Target The target element\n * @param {UseScrollToOptions} [options] The scroll options\n * @returns {UseScrollToReturn & { ref: StateRef<Target> }} The scroll trigger function and ref\n *\n * @example\n * const { ref, trigger } = useScrollTo(options);\n */\nexport const useScrollTo = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (target ? params[1] : params[0]) as UseScrollToOptions | undefined;\n  const { x, y, behavior = 'auto', enabled = true } = options ?? {};\n  const internalRef = useRefState<Element>();\n\n  useLayoutEffect(() => {\n    if (!enabled) return;\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    element.scrollTo({ top: y, left: x, behavior });\n  }, [target, internalRef.state]);\n\n  const trigger = (params?: { x: number; y: number; behavior?: ScrollBehavior }) => {\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n    const { x, y, behavior } = params ?? {};\n\n    element.scrollTo({ left: x, top: y, behavior });\n  };\n\n  if (target) return { trigger };\n  return { ref: internalRef, trigger };\n}) as UseScrollTo;\n", "import { useEffect, useState } from 'react';\n\nimport { useRerender } from '../useRerender/useRerender';\n\nexport const getRangesSelection = (selection: Selection) => {\n  const rangeCount = selection.rangeCount ?? 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n};\n\n/** The use text selection return type */\nexport interface UseTextSelectionReturn {\n  /** The current selection ranges */\n  ranges: Range[];\n  /** The current selection rects */\n  rects: DOMRect[];\n  /** The current selection */\n  selection: Selection | null;\n  /** The current selection text */\n  text: string;\n}\n\n/**\n * @name useTextSelection\n * @description - Hook that manages the text selection\n * @category Sensors\n *\n * @browserapi document.getSelection https://developer.mozilla.org/en-US/docs/Web/API/Document/getSelection\n *\n * @returns {UseTextSelectionReturn} An object containing the current text selection\n *\n * @example\n * const selection = useTextSelection();\n */\nexport const useTextSelection = (): UseTextSelectionReturn => {\n  const rerender = useRerender();\n  const [selection, setSelection] = useState<Selection | null>(\n    typeof document !== 'undefined' ? document.getSelection() : null\n  );\n\n  useEffect(() => {\n    const onSelectionChange = () => {\n      setSelection(document.getSelection());\n      rerender();\n    };\n\n    document.addEventListener('selectionchange', onSelectionChange);\n    return () => document.removeEventListener('selectionchange', onSelectionChange);\n  }, []);\n\n  const text = selection?.toString() ?? '';\n  const ranges = selection ? getRangesSelection(selection) : [];\n  const rects = ranges.map((range) => range.getBoundingClientRect());\n\n  return {\n    text,\n    ranges,\n    rects,\n    selection\n  };\n};\n", "import { target } from '@/utils/helpers';\n\nimport type { UseEventListenerOptions } from '../useEventListener/useEventListener';\n\nimport { useEventListener } from '../useEventListener/useEventListener';\n\n/**\n * @name useWindowEvent\n * @description - Hook attaches an event listener to the window object for the specified event\n * @category Sensors\n *\n * @template Event Key of window event map.\n * @param {Event} event The event to listen for.\n * @param {(event: WindowEventMap[Event]) => void} listener The callback function to be executed when the event is triggered\n * @param {UseEventListenerOptions} [options] The options for the event listener\n * @returns {void}\n *\n * @example\n * useWindowEvent('click', () => console.log('clicked'));\n */\nexport const useWindowEvent = <Event extends keyof WindowEventMap>(\n  event: Event,\n  listener: (this: Window, event: WindowEventMap[Event]) => any,\n  options?: UseEventListenerOptions\n) => useEventListener(target(window), event, listener, options);\n", "import { useEffect, useState } from 'react';\n\n/**\n * @name useWindowFocus\n * @description - Hook that provides the current focus state of the window\n * @category Elements\n *\n * @returns {boolean} The current focus state of the window\n *\n * @example\n * const focused = useWindowFocus();\n *\n * @see {@link https://siberiacancode.github.io/reactuse/functions/hooks/useWindowFocus.html}\n */\nexport const useWindowFocus = () => {\n  const [focused, setFocused] = useState(false);\n\n  useEffect(() => {\n    const onFocus = () => setFocused(true);\n    const onBlur = () => setFocused(false);\n\n    window.addEventListener('focus', onFocus);\n    window.addEventListener('blur', onBlur);\n\n    return () => {\n      window.removeEventListener('focus', onFocus);\n      window.removeEventListener('blur', onBlur);\n    };\n  });\n\n  return focused;\n};\n", "import { useEffect, useState } from 'react';\n\nexport interface ScrollPosition {\n  x: number;\n  y: number;\n}\n\nexport const scrollTo = ({\n  x,\n  y,\n  behavior = 'smooth'\n}: Partial<ScrollPosition & ScrollOptions>) => {\n  const scrollOptions: ScrollToOptions = { behavior };\n  if (typeof x === 'number') scrollOptions.left = x;\n  if (typeof y === 'number') scrollOptions.top = y;\n  window.scrollTo(scrollOptions);\n};\n\n/**\n * @name useWindowScroll\n * @description - Hook that manages the window scroll position\n * @category Sensors\n *\n * @returns {UseWindowScrollReturn} An object containing the current window scroll position\n *\n * @example\n * const { value, scrollTo } = useWindowScroll();\n */\nexport const useWindowScroll = () => {\n  const [value, setValue] = useState<ScrollPosition>({\n    x: typeof window !== 'undefined' ? window.scrollX : Number.POSITIVE_INFINITY,\n    y: typeof window !== 'undefined' ? window.scrollY : Number.POSITIVE_INFINITY\n  });\n\n  useEffect(() => {\n    const onChange = () => setValue({ x: window.scrollX, y: window.scrollY });\n    window.addEventListener('scroll', onChange);\n    window.addEventListener('resize', onChange);\n    return () => {\n      window.removeEventListener('scroll', onChange);\n      window.removeEventListener('resize', onChange);\n    };\n  }, []);\n\n  return { value, scrollTo };\n};\n", "import { useEffect, useState } from 'react';\n\n/** The use window size return type */\ninterface UseWindowSizeParams {\n  /** Whether to include the scrollbar in the window size calculation */\n  includeScrollbar?: boolean;\n}\n\n/** The use window size return type */\nexport interface UseWindowSizeReturn {\n  /** The current window height */\n  height: number;\n  /** The current window width */\n  width: number;\n}\n\n/**\n * @name useWindowSize\n * @description - Hook that manages a window size\n * @category Elements\n *\n * @param {number} [params.initialWidth=Number.POSITIVE_INFINITY] The initial window width\n * @param {number} [params.initialHeight=Number.POSITIVE_INFINITY] The initial window height\n * @returns {UseWindowSizeReturn} An object containing the current window width and height\n *\n * @example\n * const { width, height } = useWindowSize();\n */\nexport const useWindowSize = (params?: UseWindowSizeParams) => {\n  const includeScrollbar = params?.includeScrollbar ?? true;\n  const [size, setSize] = useState(() => {\n    if (typeof window === 'undefined') {\n      return {\n        width: Number.POSITIVE_INFINITY,\n        height: Number.POSITIVE_INFINITY\n      };\n    }\n\n    return {\n      width: includeScrollbar ? window.innerWidth : window.document.documentElement.clientWidth,\n      height: includeScrollbar ? window.innerHeight : window.document.documentElement.clientHeight\n    };\n  });\n\n  useEffect(() => {\n    const onResize = () => {\n      if (includeScrollbar) {\n        setSize({\n          width: window.innerWidth,\n          height: window.innerHeight\n        });\n      } else {\n        setSize({\n          width: window.document.documentElement.clientWidth,\n          height: window.document.documentElement.clientHeight\n        });\n      }\n    };\n\n    window.addEventListener('resize', onResize);\n    return () => {\n      window.removeEventListener('resize', onResize);\n    };\n  }, [params?.includeScrollbar]);\n\n  return size;\n};\n", "import { useState } from 'react';\n\n/** The use boolean return type */\nexport type UseBooleanReturn = [\n  /** The current boolean state value */\n  value: boolean,\n  /** Function to toggle the boolean state */\n  toggle: (value?: boolean) => void\n];\n\n/**\n * @name useBoolean\n * @description - Hook provides opportunity to manage boolean state\n * @category State\n *\n * @param {boolean} [initialValue=false] The initial boolean value\n * @returns {UseBooleanReturn} An object containing the boolean state value and utility functions to manipulate the state\n *\n * @example\n * const [on, toggle] = useBoolean()\n */\nexport const useBoolean = (initialValue = false): UseBooleanReturn => {\n  const [value, setValue] = useState(initialValue);\n  const toggle = (value?: boolean) => setValue((prevValue) => value ?? !prevValue);\n\n  return [value, toggle];\n};\n", "import { useEffect, useState } from 'react';\n\nexport const getCookies = () =>\n  Object.fromEntries(\n    document.cookie.split('; ').map((cookie) => {\n      const [key, ...value] = cookie.split('=');\n      const decodedValue = decodeURIComponent(value.join('='));\n      return [key, decodedValue];\n    })\n  );\n\nexport interface RemoveCookieParams {\n  domain?: string;\n  expires?: Date;\n  maxAge?: number;\n  path?: string;\n  sameSite?: 'Lax' | 'None' | 'Strict';\n  secure?: boolean;\n}\n\nexport const removeCookie = (key: string, options: RemoveCookieParams = {}) => {\n  document.cookie = `${encodeURIComponent(key)}=; expires=Thu, 01 Jan 1970 00:00:00 GMT${\n    options.path ? `; path=${options.path}` : ''\n  }${options.domain ? `; domain=${options.domain}` : ''}${\n    options.maxAge ? `; max-age=0` : ''\n  }${options.expires ? `; expires=Thu, 01 Jan 1970 00:00:00 GMT` : ''}${\n    options.secure ? `; secure` : ''\n  }${options.sameSite ? `; samesite=${options.sameSite}` : ''}`;\n};\n\nexport interface SetCookieParams {\n  domain?: string;\n  expires?: Date;\n  httpOnly?: boolean;\n  maxAge?: number;\n  path?: string;\n  sameSite?: 'Lax' | 'None' | 'Strict';\n  secure?: boolean;\n}\n\nexport const setCookie = (key: string, value: string, options: SetCookieParams = {}) => {\n  const cookie = [`${encodeURIComponent(key)}=${encodeURIComponent(value)}`];\n\n  if (options.path) cookie.push(`path=${options.path}`);\n  if (options.domain) cookie.push(`domain=${options.domain}`);\n  if (typeof options.maxAge === 'number') cookie.push(`max-age=${options.maxAge}`);\n  if (options.expires) cookie.push(`expires=${options.expires.toUTCString()}`);\n  if (options.secure) cookie.push(`secure`);\n  if (options.httpOnly) cookie.push(`httpOnly`);\n  if (options.sameSite) cookie.push(`samesite=${options.sameSite}`);\n\n  document.cookie = cookie.join('; ');\n};\n\n/* The use cookie initial value type */\nexport type UseCookieInitialValue<Value> = (() => Value) | Value;\n\n/* The use cookie options type */\nexport interface UseCookieOptions<Value> {\n  /* The domain of the cookie */\n  domain?: string;\n  /* The expiration date of the cookie */\n  expires?: Date;\n  /* Whether the cookie is httpOnly */\n  httpOnly?: boolean;\n  /* The initial value of the storage */\n  initialValue?: UseCookieInitialValue<Value>;\n  /* The maximum age of the cookie */\n  maxAge?: number;\n  /* The path of the cookie */\n  path?: string;\n  /* The sameSite of the cookie */\n  sameSite?: 'Lax' | 'None' | 'Strict';\n  /* Whether the cookie is secure */\n  secure?: boolean;\n  /* The deserializer function to be invoked */\n  deserializer?: (value: string) => Value;\n  /* The serializer function to be invoked */\n  serializer?: (value: Value) => string;\n}\n\n/* The use cookie return type */\nexport interface UseCookieReturn<Value> {\n  /* The value of the cookie */\n  value: Value;\n  /* The remove function */\n  remove: (options?: RemoveCookieParams) => void;\n  /* The set function */\n  set: (value: Value, options?: SetCookieParams) => void;\n}\n\nexport const COOKIE_EVENT = 'reactuse-cookie';\n\nexport const dispatchCookieEvent = () => window.dispatchEvent(new Event(COOKIE_EVENT));\n\nexport const setCookieItem = (key: string, value: string, options?: SetCookieParams) => {\n  setCookie(key, value, options);\n  dispatchCookieEvent();\n};\n\nexport const removeCookieItem = (key: string, options?: RemoveCookieParams) => {\n  removeCookie(key, options);\n  dispatchCookieEvent();\n};\n\nexport const getCookie = (key: string): string | undefined => {\n  const cookies = getCookies();\n  return cookies[key];\n};\n\nexport interface UseCookie {\n  <Value>(\n    key: string,\n    options: UseCookieOptions<Value> & {\n      initialValue: UseCookieInitialValue<Value>;\n    }\n  ): UseCookieReturn<Value>;\n\n  <Value>(key: string, options?: UseCookieOptions<Value>): UseCookieReturn<Value | undefined>;\n\n  <Value>(key: string, initialValue: UseCookieInitialValue<Value>): UseCookieReturn<Value>;\n\n  <Value>(key: string): UseCookieReturn<Value | undefined>;\n}\n\n/**\n * @name useCookie\n * @description - Hook that manages cookie value\n * @category State\n *\n * @overload\n * @template Value The type of the cookie value\n * @param {string} key The key of the cookie\n * @param {UseCookieInitialValue<Value>} [initialValue] The initial value of the cookie\n * @returns {UseCookieReturn<Value>} The value and the set function\n *\n * @overload\n * @template Value The type of the cookie value\n * @param {string} key The key of the cookie\n * @param {UseCookieOptions<Value>} options The options object\n * @param {UseCookieInitialValue<Value>} [options.initialValue] The initial value of the cookie\n * @param {(value: string) => Value} [options.deserializer] The deserializer function to be invoked\n * @param {(value: Value) => string} [options.serializer] The serializer function to be invoked\n * @returns {UseCookieReturn<Value | undefined>} The value and the set function\n *\n * @example\n * const { value, set, remove } = useCookie('key', 'value');\n */\nexport const useCookie = (<Value>(key: string, params?: any) => {\n  const options = (\n    typeof params === 'object' &&\n    params &&\n    ('serializer' in params || 'deserializer' in params || 'initialValue' in params)\n      ? params\n      : undefined\n  ) as UseCookieOptions<Value>;\n  const initialValue = (options ? options?.initialValue : params) as UseCookieInitialValue<Value>;\n\n  if (typeof document === 'undefined')\n    return {\n      value: typeof initialValue === 'function' ? (initialValue as () => Value)() : initialValue\n    } as UseCookieReturn<Value>;\n\n  const serializer = (value: Value) => {\n    if (options?.serializer) return options.serializer(value);\n    if (typeof value === 'string') return value;\n    return JSON.stringify(value);\n  };\n\n  const deserializer = (value: string) => {\n    if (options?.deserializer) return options.deserializer(value);\n    if (value === 'undefined') return undefined as unknown as Value;\n\n    try {\n      return JSON.parse(value) as Value;\n    } catch {\n      return value as Value;\n    }\n  };\n\n  const [value, setValue] = useState<Value | undefined>(() => {\n    const cookieValue = getCookie(key);\n    if (cookieValue === undefined && initialValue !== undefined) {\n      const value =\n        typeof initialValue === 'function' ? (initialValue as () => Value)() : initialValue;\n      setCookieItem(key, serializer(value), options);\n      return value;\n    }\n    return cookieValue ? deserializer(cookieValue) : undefined;\n  });\n\n  useEffect(() => {\n    const onChange = () => {\n      const cookieValue = getCookie(key);\n      setValue(cookieValue ? deserializer(cookieValue) : undefined);\n    };\n    window.addEventListener(COOKIE_EVENT, onChange);\n    return () => window.removeEventListener(COOKIE_EVENT, onChange);\n  }, [key]);\n\n  const set = (value: Value, params?: SetCookieParams) =>\n    setCookieItem(key, serializer(value), { ...options, ...params });\n  const remove = (params?: RemoveCookieParams) => removeCookieItem(key, { ...options, ...params });\n\n  return { value, set, remove };\n}) as UseCookie;\n", "import { useEffect, useState } from 'react';\n\nimport type { RemoveCookieParams, SetCookieParams } from '../useCookie/useCookie';\n\nimport {\n  COOKIE_EVENT,\n  dispatchCookieEvent,\n  removeCookie,\n  removeCookieItem,\n  setCookieItem\n} from '../useCookie/useCookie';\n\n/** The cookies params type */\nexport type CookieParams = Record<string, any>;\n\n/* The use cookies options type */\nexport interface UseCookiesOptions<Value> {\n  /* The deserializer function to be invoked */\n  deserializer?: (value: string) => Value[keyof Value];\n  /* The serializer function to be invoked */\n  serializer?: (value: Value[keyof Value]) => string;\n}\n\nexport const clearCookies = () => {\n  document.cookie.split('; ').forEach((cookie) => {\n    const [name] = cookie.split('=');\n    removeCookie(name);\n  });\n};\n\nconst clearCookieItems = () => {\n  clearCookies();\n  dispatchCookieEvent();\n};\n\n/**\n * @name useCookies\n * @description - Hook that manages cookie values\n * @category State\n *\n * @overload\n * @template {object} Value The type of the cookie values\n * @returns {UseCookieReturn<Value>} The value and the set function\n *\n * @example\n * const { value, set, remove, getAll, clear } = useCookies();\n */\nexport const useCookies = <Value extends CookieParams>(options?: UseCookiesOptions<Value>) => {\n  const serializer = (value: Value[keyof Value]) => {\n    if (options?.serializer) return options.serializer(value);\n    if (typeof value === 'string') return value;\n    return JSON.stringify(value);\n  };\n\n  const deserializer = (value: string) => {\n    if (options?.deserializer) return options.deserializer(value);\n    if (value === 'undefined') return undefined as unknown as Value[keyof Value];\n\n    try {\n      return JSON.parse(value) as Value;\n    } catch {\n      return value as Value[keyof Value];\n    }\n  };\n\n  const getParsedCookies = () => {\n    if (!document.cookie) return {};\n\n    return Object.fromEntries(\n      document.cookie\n        .split('; ')\n        .map((cookie) => {\n          const [key, ...value] = cookie.split('=');\n          if (!key || !value.length) return [];\n          const decodedValue = decodeURIComponent(value.join('='));\n          return [key, deserializer(decodedValue)];\n        })\n        .filter((entry) => entry.length)\n    );\n  };\n\n  const [value, setValue] = useState(() => {\n    if (typeof window === 'undefined') return {} as Value;\n    return getParsedCookies() as Value;\n  });\n\n  useEffect(() => {\n    const onChange = () => setValue(getParsedCookies() as Value);\n\n    window.addEventListener(COOKIE_EVENT, onChange);\n    return () => {\n      window.removeEventListener(COOKIE_EVENT, onChange);\n    };\n  }, []);\n\n  const set = <Key extends keyof Value>(key: Key, value: Value[Key], options?: SetCookieParams) =>\n    setCookieItem(key as string, serializer(value), options);\n\n  const remove = <Key extends keyof Value>(key: Key, options?: RemoveCookieParams) =>\n    removeCookieItem(key as string, options);\n  const getAll = () => getParsedCookies();\n  const clear = () => clearCookieItems();\n\n  return { value, set, remove, getAll, clear };\n};\n", "import type { Dispatch, SetStateAction } from 'react';\n\nimport { useState } from 'react';\n\n/** The use counter options */\nexport interface UseCounterOptions {\n  /** The max of count value */\n  max?: number;\n  /** The min of count value */\n  min?: number;\n}\n\n/** The use counter return type */\nexport interface UseCounterReturn {\n  /** Function to set a specific value to the counter */\n  set: Dispatch<SetStateAction<number>>;\n  /** The current count value */\n  value: number;\n  /** Function to decrement the counter */\n  dec: (value?: number) => void;\n  /** Function to increment the counter */\n  inc: (value?: number) => void;\n  /** Function to reset the counter to its initial value. */\n  reset: () => void;\n}\n\nexport interface UseCounter {\n  (initialValue?: number, options?: UseCounterOptions): UseCounterReturn;\n\n  (options: UseCounterOptions & { initialValue?: number }, initialValue?: never): UseCounterReturn;\n}\n\n/**\n * @name useCounter\n * @description - Hook that manages a counter\n * @category State\n *\n * @overload\n * @param {number} [initialValue=0] The initial number value\n * @param {number} [options.min=Number.NEGATIVE_INFINITY] The min of count value\n * @param {number} [options.max=Number.POSITIVE_INFINITY] The max of count value\n * @returns {UseCounterReturn} An object containing the current count and functions to interact with the counter\n\n * @overload\n * @param {number} [params.initialValue=0] The initial number value\n * @param {number} [params.min=Number.NEGATIVE_INFINITY] The min of count value\n * @param {number} [params.max=Number.POSITIVE_INFINITY] The max of count value\n * @returns {UseCounterReturn} An object containing the current count and functions to interact with the counter\n *\n * @example\n * const { count, dec, inc, reset, set } = useCounter(5);\n *\n * @example\n * const { count, dec, inc, reset, set } = useCounter({ initialValue: 5, min: 0, max: 10 });\n */\nexport const useCounter = ((...params: any[]) => {\n  const initialValue =\n    typeof params[0] === 'number'\n      ? params[0]\n      : (params[0] as UseCounterOptions & { initialValue?: number })?.initialValue;\n  const { max = Number.POSITIVE_INFINITY, min = Number.NEGATIVE_INFINITY } =\n    typeof params[0] === 'number'\n      ? ((params[1] ?? {}) as UseCounterOptions)\n      : ((params[0] ?? {}) as UseCounterOptions & { initialValue?: number });\n\n  const [value, setValue] = useState(initialValue ?? 0);\n\n  const inc = (value: number = 1) => {\n    setValue((prevValue) => {\n      if (typeof max === 'number' && prevValue === max) return prevValue;\n      return Math.max(Math.min(max, prevValue + value), min);\n    });\n  };\n\n  const dec = (value: number = 1) => {\n    setValue((prevValue) => {\n      if (typeof min === 'number' && prevValue === min) return prevValue;\n      return Math.min(Math.max(min, prevValue - value), max);\n    });\n  };\n\n  const reset = () => {\n    const value = initialValue ?? 0;\n    if (typeof max === 'number' && value > max) return setValue(max);\n    if (typeof min === 'number' && value < min) return setValue(min);\n    setValue(value);\n  };\n\n  const set = (value: SetStateAction<number>) => {\n    setValue((prevValue) => {\n      const updatedCount = Math.max(\n        min,\n        Math.min(max, typeof value === 'number' ? value : value(prevValue))\n      );\n\n      return updatedCount;\n    });\n  };\n\n  return { value, set, inc, dec, reset };\n}) as UseCounter;\n", "import { useState } from 'react';\n\n/**\n * @name useDefault\n * @description - Hook that returns the default value\n * @category State\n *\n * @template Value The type of the value\n * @param {Value} initialValue The initial value\n * @param {Value} defaultValue The default value\n * @returns {[Value, (value: Value) => void]} An array containing the current value and a function to set the value\n *\n * @example\n * const [value, setValue] = useDefault(initialValue, defaultValue);\n */\nexport const useDefault = <Value>(initialValue: (() => Value) | Value, defaultValue: Value) => {\n  const [value, setValue] = useState<Value | null | undefined>(initialValue);\n  return [value === undefined || value === null ? defaultValue : value, setValue] as const;\n};\n", "import { useState } from 'react';\n\n/** The use disclosure options type */\nexport interface UseDisclosureOptions {\n  /** The callback function to be invoked on close */\n  onClose?: () => void;\n  /** The callback function to be invoked on open */\n  onOpen?: () => void;\n}\n\n/** The use disclosure return type */\nexport interface UseDisclosureReturn {\n  /** The opened value */\n  opened: boolean;\n  /** Function to close the modal */\n  close: () => void;\n  /** Function to open the modal */\n  open: () => void;\n  /** Function to toggle the modal */\n  toggle: () => void;\n}\n\n/**\n * @name useDisclosure\n * @description - Hook that allows you to open and close a modal\n * @category State\n *\n * @param {boolean} [initialValue=false] The initial value of the component\n * @param {() => void} [options.onOpen] The callback function to be invoked on open\n * @param {() => void} [options.onClose] The callback function to be invoked on close\n * @returns {UseDisclosureReturn} An object with the opened, open, close, and toggle properties\n *\n * @example\n * const { opened, open, close, toggle } = useDisclosure();\n */\nexport const useDisclosure = (\n  initialValue = false,\n  options?: UseDisclosureOptions\n): UseDisclosureReturn => {\n  const [opened, setOpened] = useState(initialValue);\n\n  const open = () =>\n    setOpened((opened) => {\n      if (!opened) {\n        options?.onOpen?.();\n        return true;\n      }\n      return opened;\n    });\n\n  const close = () =>\n    setOpened((opened) => {\n      if (opened) {\n        options?.onClose?.();\n        return false;\n      }\n      return opened;\n    });\n\n  const toggle = () => (opened ? close() : open());\n\n  return { opened, open, close, toggle };\n};\n", "import { useRef, useState } from 'react';\n\nimport { useRerender } from '../useRerender/useRerender';\n\n/** The use field params type */\nexport interface UseFieldParams<Value> {\n  /** The auto focus */\n  autoFocus?: boolean;\n  /** The initial touched */\n  initialTouched?: boolean;\n  /** The initial value */\n  initialValue?: Value;\n  /** The validate on blur */\n  validateOnBlur?: boolean;\n  /** The validate on mount */\n  validateOnChange?: boolean;\n  /** The validate on mount */\n  validateOnMount?: boolean;\n}\n\n/** The use field register params type */\nexport interface UseFieldRegisterParams {\n  /** The required validation */\n  required?: string;\n  /** The custom validation */\n  validate?: (value: string) => Promise<string | true>;\n  /** The min value validation */\n  max?: {\n    value: number;\n    message: string;\n  };\n  /** The max length validation */\n  maxLength?: {\n    value: number;\n    message: string;\n  };\n  /** The max value validation */\n  min?: {\n    value: number;\n    message: string;\n  };\n  /** The min length validation */\n  minLength?: {\n    value: number;\n    message: string;\n  };\n  /** The pattern validation */\n  pattern?: {\n    value: RegExp;\n    message: string;\n  };\n}\n\n/** The use field return type */\nexport interface UseFieldReturn<Value> {\n  /** The dirty state */\n  dirty: boolean;\n  /** The error state */\n  error?: string;\n  /** The set error function */\n  touched: boolean;\n  /** The set error function */\n  clearError: () => void;\n  /** The focus function */\n  focus: () => void;\n  /** The get value function */\n  getValue: () => Value;\n  /** The register function */\n  register: (params?: UseFieldRegisterParams) => {\n    onBlur: () => void;\n    onChange: () => void;\n    ref: (\n      node: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | null | undefined\n    ) => void;\n  };\n  /** The reset function */\n  reset: () => void;\n  /** The set error function */\n  setError: (error: string) => void;\n  /** The  set value function */\n  setValue: (value: Value) => void;\n  /** The watch function */\n  watch: () => Value;\n}\n\n/**\n * @name useField\n * @description - Hook to manage a form field\n * @category State\n *\n * @template Value The input value\n * @template Type The input value type\n * @param {Value} [params.initialValue] Initial value\n * @param {boolean} [params.initialTouched=false] Initial touched state\n * @param {boolean} [params.autoFocus=false] Auto focus\n * @param {boolean} [params.validateOnChange=false] Validate on change\n * @param {boolean} [params.validateOnBlur=false] Validate on blur\n * @param {boolean} [params.validateOnMount=false] Validate on mount\n * @returns {UseFieldReturn<Value>} An object containing input information\n *\n * @example\n * const { register, getValue, setValue, reset, dirty, error, setError, clearError, touched, focus, watch } = useField();\n */\nexport const useField = <\n  Value extends boolean | number | string = string,\n  Type = Value extends string ? string : Value extends boolean ? boolean : number\n>(\n  params?: UseFieldParams<Value>\n): UseFieldReturn<Type> => {\n  const initialValue = (params?.initialValue ?? '') as Value;\n\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const watchingRef = useRef(false);\n  const rerender = useRerender();\n\n  const [dirty, setDirty] = useState(false);\n  const [touched, setTouched] = useState(params?.initialTouched ?? false);\n  const [error, setError] = useState<string | undefined>(undefined);\n\n  const getValue = () => {\n    if (inputRef.current?.type === 'radio' || inputRef.current?.type === 'checkbox')\n      return inputRef.current.checked as Type;\n    return (inputRef.current?.value ?? initialValue) as Type;\n  };\n\n  const setValue = (value: Type) => {\n    if (inputRef.current?.type === 'radio' || inputRef.current?.type === 'checkbox') {\n      inputRef.current.checked = value as boolean;\n      if (watchingRef.current) return rerender();\n      return;\n    }\n\n    inputRef.current!.value = value as string;\n    if (watchingRef.current) return rerender();\n  };\n\n  const reset = () => {\n    setValue(initialValue as unknown as Type);\n    setDirty(false);\n    setTouched(false);\n    setError(undefined);\n  };\n\n  const focus = () => inputRef.current!.focus();\n\n  const validate = (params: UseFieldRegisterParams) => {\n    if (params.required && !inputRef.current!.value) {\n      return setError(params.required);\n    }\n\n    if (params.minLength && inputRef.current!.value.length < params.minLength.value) {\n      return setError(params.minLength.message);\n    }\n\n    if (params.maxLength && inputRef.current!.value.length > params.maxLength.value) {\n      return setError(params.maxLength.message);\n    }\n\n    if (params.min && Number(inputRef.current!.value) < params.min.value) {\n      return setError(params.min.message);\n    }\n\n    if (params.max && Number(inputRef.current!.value) > params.max.value) {\n      return setError(params.max.message);\n    }\n\n    if (params.pattern && !params.pattern.value.test(inputRef.current!.value)) {\n      return setError(params.pattern.message);\n    }\n\n    if (params.validate) {\n      const error = params.validate(inputRef.current!.value);\n      if (typeof error === 'string') return setError(error);\n    }\n\n    setError(undefined);\n  };\n\n  const register = (registerParams?: UseFieldRegisterParams) => ({\n    ref: (node: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | null | undefined) => {\n      if (!inputRef.current && node) {\n        if (params?.autoFocus) node.focus();\n        inputRef.current = node as HTMLInputElement;\n        if (inputRef.current.type === 'radio') {\n          inputRef.current.defaultChecked = params?.initialValue === node.value;\n          return;\n        }\n        if (inputRef.current.type === 'checkbox') {\n          inputRef.current.defaultChecked = !!params?.initialValue;\n          return;\n        }\n        inputRef.current.defaultValue = String(initialValue);\n\n        if (registerParams && params?.validateOnMount) validate(registerParams);\n      }\n    },\n    onChange: async () => {\n      if (watchingRef.current) return rerender();\n      if (inputRef.current!.value !== initialValue) setDirty(true);\n      if (dirty && inputRef.current!.value === initialValue) setDirty(false);\n      if (registerParams && params?.validateOnChange) await validate(registerParams);\n      if (registerParams && params?.validateOnBlur) setError(undefined);\n    },\n    onBlur: async () => {\n      if (registerParams && params?.validateOnBlur) await validate(registerParams);\n      setTouched(true);\n    }\n  });\n\n  const watch = () => {\n    watchingRef.current = true;\n    return getValue();\n  };\n\n  const clearError = () => setError(undefined);\n\n  return {\n    register,\n    dirty,\n    touched,\n    error,\n    setError,\n    clearError,\n    getValue,\n    setValue,\n    reset,\n    watch,\n    focus\n  };\n};\n", "import { useEffect, useState } from 'react';\n\nconst getHash = () => decodeURIComponent(window.location.hash.replace('#', ''));\n\n/** The use hash return type */\ntype UseHashReturn = [string, (value: string) => void];\n\n/**\n * @name useHash\n * @description - Hook that manages the hash value\n * @category State\n *\n * @param {string} [initialValue] The initial hash value if no hash exists\n * @returns {UseHashReturn} An array containing the hash value and a function to set the hash value\n *\n * @example\n * const [hash, setHash] = useHash(\"initial\");\n */\nexport const useHash = (\n  initialValue = '',\n  mode: 'initial' | 'replace' = 'replace'\n): UseHashReturn => {\n  const [hash, setHash] = useState(() => {\n    if (typeof window === 'undefined') return initialValue;\n    return getHash() || initialValue;\n  });\n\n  const set = (value: string) => {\n    window.location.hash = value;\n    setHash(value);\n  };\n\n  useEffect(() => {\n    if (mode === 'replace') window.location.hash = hash;\n\n    const onHashChange = () => setHash(getHash());\n    window.addEventListener('hashchange', onHashChange);\n    return () => {\n      window.removeEventListener('hashchange', onHashChange);\n    };\n  }, []);\n\n  return [hash, set] as const;\n};\n", "import { useState } from 'react';\n\n/** The use list return type */\nexport interface UseListReturn<Item> {\n  /** The current list of items */\n  value: Item[];\n  /** Clears the list */\n  clear: () => void;\n  /** Inserts an item at the specified index */\n  insertAt: (insertAtIndex: number, item: Item) => void;\n  /** Adds an item to the list */\n  push: (item: Item) => void;\n  /** Removes an item from the list */\n  removeAt: (removeAtIndex: number) => void;\n  /** Sets the list of items */\n  set: (list: Item[]) => void;\n  /** Updates an item at the specified index */\n  updateAt: (updateAtIndex: number, item: Item) => void;\n}\n\n/**\n * @name useList\n * @description - Hook that provides state and helper methods to manage a list of items\n * @category State\n *\n * @template Item The type of the item\n * @param {Item[] | (() => Item[])} initialList The initial list of items\n * @returns {UseListReturn} An object containing the current list and functions to interact with the list\n *\n * @example\n * const { value, set, push, removeAt, insertAt, updateAt, clear } = useList();\n */\nexport const useList = <Item>(initialList: Item[] = []) => {\n  const [list, setList] = useState(initialList);\n\n  const push = (item: Item) => setList((prevList) => [...prevList, item]);\n\n  const removeAt = (removeAtIndex: number) =>\n    setList((prevList) => [\n      ...prevList.slice(0, removeAtIndex),\n      ...prevList.slice(removeAtIndex + 1)\n    ]);\n\n  const insertAt = (insertAtIndex: number, item: Item) =>\n    setList((l) => [...l.slice(0, insertAtIndex), item, ...l.slice(insertAtIndex)]);\n\n  const updateAt = (updateAtIndex: number, item: Item) =>\n    setList((prevList) =>\n      prevList.map((element, index) => (index === updateAtIndex ? item : element))\n    );\n\n  const clear = () => setList([]);\n\n  const reset = () => setList(initialList);\n\n  return {\n    value: list,\n    set: setList,\n    push,\n    removeAt,\n    insertAt,\n    updateAt,\n    clear,\n    reset\n  };\n};\n", "import { useEffect, useState } from 'react';\n\n/* The use storage initial value type */\nexport type UseStorageInitialValue<Value> = (() => Value) | Value;\n\n/* The use storage options type */\nexport interface UseStorageOptions<Value> {\n  /* The initial value of the storage */\n  initialValue?: UseStorageInitialValue<Value>;\n  /* The storage to be used */\n  storage?: Storage;\n  /* The deserializer function to be invoked */\n  deserializer?: (value: string) => Value;\n  /* The serializer function to be invoked */\n  serializer?: (value: Value) => string;\n}\n\n/* The use storage return type */\nexport interface UseStorageReturn<Value> {\n  /* The value of the storage */\n  value: Value;\n  /* The error state of the storage */\n  remove: () => void;\n  /* The loading state of the storage */\n  set: (value: Value) => void;\n}\n\nexport interface UseStorage {\n  <Value>(key: string, options?: UseStorageOptions<Value>): UseStorageReturn<Value | undefined>;\n\n  <Value>(\n    key: string,\n    initialValue?: UseStorageInitialValue<Value>\n  ): UseStorageReturn<Value | undefined>;\n}\n\nexport const STORAGE_EVENT = 'reactuse-storage';\n\nexport const dispatchStorageEvent = (params: Partial<StorageEvent>) =>\n  window.dispatchEvent(new StorageEvent(STORAGE_EVENT, params));\n\nconst setStorageItem = (storage: Storage, key: string, value: string) => {\n  const oldValue = storage.getItem(key);\n\n  storage.setItem(key, value);\n  dispatchStorageEvent({\n    key,\n    oldValue,\n    newValue: value,\n    storageArea: storage\n  });\n};\n\nconst removeStorageItem = (storage: Storage, key: string) => {\n  const oldValue = storage.getItem(key);\n\n  storage.removeItem(key);\n  dispatchStorageEvent({ key, oldValue, newValue: null, storageArea: storage });\n};\n\nconst getStorageItem = (storage: Storage, key: string) => {\n  const value = storage.getItem(key);\n  if (!value) return undefined;\n  return value;\n};\n\n/**\n * @name useStorage\n * @description - Hook that manages storage value\n * @category State\n *\n * @overload\n * @param {string} key The key of the storage\n * @param {UseStorageInitialValue<Value>} [initialValue] The initial value of the storage\n * @returns {UseStorageReturn<Value>} The value and the set function\n *\n * @overload\n * @param {string} key The key of the storage\n * @param {(value: Value) => string} [params.serializer] The serializer function\n * @param {(value: string) => Value} [params.deserializer] The deserializer function\n * @param {Storage} [params.storage] The storage\n * @param {UseStorageInitialValue<Value>} [params.initialValue] The initial value of the storage\n * @returns {UseStorageReturn<Value>} The value and the set function\n *\n * @example\n * const { value, set, remove } = useStorage('key', 'value');\n */\nexport const useStorage = (<Value>(key: string, params?: any): UseStorageReturn<Value> => {\n  const options = (\n    typeof params === 'object' &&\n    params &&\n    ('serializer' in params ||\n      'deserializer' in params ||\n      'initialValue' in params ||\n      'storage' in params)\n      ? params\n      : undefined\n  ) as UseStorageOptions<Value>;\n\n  const initialValue = (options ? options?.initialValue : params) as UseStorageInitialValue<Value>;\n\n  if (typeof window === 'undefined') {\n    const value = typeof initialValue === 'function' ? (initialValue as () => any)() : initialValue;\n    return {\n      value,\n      set: () => {},\n      remove: () => {}\n    };\n  }\n\n  const serializer = (value: Value) => {\n    if (options?.serializer) return options.serializer(value);\n    if (typeof value === 'string') return value;\n    return JSON.stringify(value);\n  };\n\n  const storage = options?.storage ?? window?.localStorage;\n\n  const set = (value: Value) => setStorageItem(storage, key, serializer(value));\n  const remove = () => removeStorageItem(storage, key);\n\n  const deserializer = (value: string) => {\n    if (options?.deserializer) return options.deserializer(value);\n    if (value === 'undefined') return undefined as unknown as Value;\n\n    try {\n      return JSON.parse(value) as Value;\n    } catch {\n      return value as Value;\n    }\n  };\n\n  const [value, setValue] = useState<Value | undefined>(() => {\n    const storageValue = getStorageItem(storage, key);\n    if (storageValue === undefined && initialValue !== undefined) {\n      const value =\n        typeof initialValue === 'function' ? (initialValue as () => Value)() : initialValue;\n      setStorageItem(storage, key, serializer(value));\n      return value;\n    }\n    return storageValue ? deserializer(storageValue) : undefined;\n  });\n\n  useEffect(() => {\n    const onChange = () => {\n      const storageValue = getStorageItem(storage, key);\n      setValue(storageValue ? deserializer(storageValue) : undefined);\n    };\n    window.addEventListener(STORAGE_EVENT, onChange);\n    return () => window.removeEventListener(STORAGE_EVENT, onChange);\n  }, [key]);\n\n  return {\n    value: value as Value,\n    set,\n    remove\n  };\n}) as UseStorage;\n", "import type { UseStorageInitialValue, UseStorageOptions } from '../useStorage/useStorage';\n\nimport { useStorage } from '../useStorage/useStorage';\n\n/**\n * @name useLocalStorage\n * @description - Hook that manages local storage value\n * @category State\n *\n * @browserapi localStorage https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage\n *\n * @template Value The type of the value\n * @param {string} key The key of the storage\n * @param {UseStorageInitialValue<Value>} [initialValue] The initial value of the storage\n * @param {UseStorageOptions<Value>} [options] The options of the storage\n *\n * @example\n * const { value, set, remove } = useLocalStorage('key', 'value');\n */\nexport const useLocalStorage = <Value>(\n  key: string,\n  initialValue?: UseStorageInitialValue<Value>,\n  options?: Omit<UseStorageOptions<Value>, 'initialValue' | 'storage'>\n) =>\n  useStorage(key, {\n    ...options,\n    initialValue,\n    storage: typeof window !== 'undefined' ? window.localStorage : undefined\n  });\n", "import { useState } from 'react';\n\n/** The use map return type */\nexport interface UseMapReturn<Key, Value> {\n  /** The size of the map */\n  size: number;\n  /** The current map */\n  value: Map<Key, Value>;\n  /** Function to clear the map */\n  clear: () => void;\n  /** Function to check if a value exists in the map */\n  has: (key: Key) => boolean;\n  /** Function to remove a value from the map */\n  remove: (key: Key) => void;\n  /** Function to toggle a value in the map */\n  reset: () => void;\n  /** Function to add a value to the map */\n  set: (key: Key, value: Value) => void;\n}\n\n/**\n * @name useMap\n * @description - Hook that manages a map structure\n * @category State\n *\n * @template Value The type of the value\n * @param {Value[]} [values] The initial array of the map\n * @returns {UseMapReturn<Key, Value>} An object containing the current map and functions to interact with the map\n *\n * @example\n * const { value, set, remove, clear, reset, size, has } = useMap([1, 'one'], [2, 'two']);\n */\nexport const useMap = <Key, Value>(values?: [Key, Value][]): UseMapReturn<Key, Value> => {\n  const [map, setMap] = useState(new Map(values));\n\n  const set = (key: Key, value: Value) => setMap((prevMap) => new Map(prevMap).set(key, value));\n  const remove = (key: Key) =>\n    setMap((prevMap) => {\n      if (!prevMap.has(key)) return prevMap;\n      const newMap = new Map(prevMap);\n      newMap.delete(key);\n      return newMap;\n    });\n  const clear = () => setMap(new Map());\n  const reset = () => setMap(new Map(values));\n  const has = (key: Key) => map.has(key);\n\n  return {\n    value: map,\n    size: map.size,\n    set,\n    has,\n    remove,\n    clear,\n    reset\n  };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\n/** The use offset pagination return type */\nexport interface UseOffsetPaginationOptions {\n  /** The initial page number */\n  initialPage?: number;\n  /** The number of items per page */\n  pageSize?: number;\n  /** The total number of items */\n  total?: number;\n  /** The callback function to be invoked when page changes */\n  onPageChange?: ({ page, pageSize }: { page: number; pageSize: number }) => void;\n  /** The callback function to be invoked when page count changes */\n  onPageCountChange?: ({ page, pageSize }: { page: number; pageSize: number }) => void;\n  /** The callback function to be invoked when page size changes */\n  onPageSizeChange?: ({ page, pageSize }: { page: number; pageSize: number }) => void;\n}\n\n/** The use offset pagination return type */\nexport interface UseOffsetPaginationReturn {\n  /** The number of items per page */\n  currentPageSize: number;\n  /** Whether the current page is the first page */\n  isFirstPage: boolean;\n  /** Whether the current page is the last page */\n  isLastPage: boolean;\n  /** The current page number */\n  page: number;\n  /** The total number of pages */\n  pageCount: number;\n  /** The callback function to go to the next page */\n  next: () => void;\n  /** The callback function to go to the previous page */\n  prev: () => void;\n  /** The callback function to set the current page */\n  set: (page: number) => void;\n}\n\n/**\n * @name useOffsetPagination\n * @description - Hook that defines the logic when pagination\n * @category State\n *\n * @param {UseOffsetPaginationOptions} options - The options for the hook\n * @param {number} [options.total] - The total number of items\n * @param {number} [options.pageSize] - The number of items per page\n * @param {number} [options.initialPage] - The current page\n * @param {({ page, pageSize }: { page: number; pageSize: number }) => void} [options.onPageChange] - The callback function to be invoked when page changes\n * @param {({ page, pageSize }: { page: number; pageSize: number }) => void} [options.onPageCountChange] - The callback function to be invoked when page count changes\n * @param {({ page, pageSize }: { page: number; pageSize: number }) => void} [options.onPageSizeChange] - The callback function to be invoked when page size changes\n * @returns {UseOffsetPaginationReturn} - The state of the hook\n *\n * @example\n * const { currentPage, currentPageSize, pageCount, isFirstPage, isLastPage, prev, next } = useOffsetPagination({\n *  total: 100,\n *  pageSize: 10,\n *  page: 1,\n *  onPageChange: (page) => {},\n *  onPageCountChange: (pageCount) => {},\n *  onPageSizeChange: (pageSize) => {}\n * });\n */\nexport const useOffsetPagination = ({\n  total = Number.POSITIVE_INFINITY,\n  pageSize = 10,\n  initialPage = 1,\n  onPageChange = () => {},\n  onPageCountChange = () => {},\n  onPageSizeChange = () => {}\n}: UseOffsetPaginationOptions = {}): UseOffsetPaginationReturn => {\n  const [page, setPage] = useState(initialPage);\n\n  const onPageChangeRef = useRef(onPageChange);\n  const onPageCountChangeRef = useRef(onPageCountChange);\n  const onPageSizeChangeRef = useRef(onPageSizeChange);\n\n  onPageChangeRef.current = onPageChange;\n  onPageCountChangeRef.current = onPageCountChange;\n  onPageSizeChangeRef.current = onPageSizeChange;\n\n  const pageCount = Math.max(1, Math.ceil(total / pageSize));\n\n  const isFirstPage = page === 1;\n  const isLastPage = page === pageCount;\n\n  const next = () => {\n    if (isLastPage) return onPageChange({ page: pageCount, pageSize });\n\n    setPage((prevPage) => {\n      const page = prevPage + 1;\n      onPageChange({ page, pageSize });\n      return page;\n    });\n  };\n\n  const prev = () => {\n    if (isFirstPage) return onPageChange({ page: 1, pageSize });\n\n    setPage((prevPage) => {\n      const page = prevPage - 1;\n      onPageChange({ page, pageSize });\n      return page;\n    });\n  };\n\n  const set = (page: number) => {\n    setPage(page);\n    onPageChange({ page, pageSize });\n  };\n\n  useEffect(() => {\n    onPageCountChangeRef.current({ page, pageSize });\n  }, [pageCount]);\n\n  useEffect(() => {\n    onPageSizeChangeRef.current({ page, pageSize });\n  }, [pageSize]);\n\n  return {\n    page,\n    set,\n    currentPageSize: pageSize,\n    isFirstPage,\n    isLastPage,\n    pageCount,\n    next,\n    prev\n  };\n};\n", "import { useState } from 'react';\nimport { flushSync } from 'react-dom';\n\n/** The use queue return type */\nexport interface UseQueueReturn<Value> {\n  /** Get the first element of the queue */\n  first: Value;\n  /** Get the last element of the queue */\n  last: Value;\n  /** The current queue */\n  queue: Value[];\n  /** Get the size of the queue */\n  size: number;\n  /** Add an element to the queue */\n  add: (element: Value) => void;\n  /** Clear the queue */\n  clear: () => void;\n  /** Remove an element from the queue */\n  remove: () => Value;\n}\n\n/**\n * @name useQueue\n * @description - Hook that manages a queue\n * @category State\n *\n * @template Value The type of the value\n * @param {Value[]} [initialValue=[]] The initial value of the queue\n * @returns {UseQueueReturn} An object containing the current queue and functions to interact with the queue\n *\n * @example\n * const { queue, add, remove, clear, first, last, size } = useQueue([1, 2, 3]);\n */\nexport const useQueue = <Value>(initialValue: Value[] = []): UseQueueReturn<Value> => {\n  const [queue, setQueue] = useState(initialValue);\n\n  const add = (element: Value) => setQueue((queue) => [...queue, element]);\n  const clear = () => setQueue([]);\n  const remove = () => {\n    let removed;\n    flushSync(() => {\n      setQueue(([first, ...rest]) => {\n        removed = first;\n        return rest;\n      });\n    });\n\n    return removed as Value;\n  };\n\n  return {\n    add,\n    remove,\n    clear,\n    first: queue[0],\n    last: queue[queue.length - 1],\n    size: queue.length,\n    queue\n  };\n};\n", "import { useRef, useState } from 'react';\n\nimport { useUnmount } from '../useUnmount/useUnmount';\n\n/* The use raf value params type */\nexport type UseRafStateReturn<Value> = [Value, (value: Value) => void];\n\n/**\n * @name useRafState\n * @description - Hook that returns the value and a function to set the value\n * @category State\n *\n * @template Value The type of the value\n * @param {Value} initialValue The initial value\n * @returns {UseRafStateReturn<Value>} An array containing the value and a function to set the value\n *\n * @example\n * const [value, setValue] = useRafState(initialValue);\n */\nexport const useRafState = <Value>(initialValue: (() => Value) | Value) => {\n  const rafIdRef = useRef(0);\n  const [value, setValue] = useState(initialValue);\n\n  const set = (value: Value) => {\n    cancelAnimationFrame(rafIdRef.current);\n    rafIdRef.current = requestAnimationFrame(() => setValue(value));\n  };\n\n  useUnmount(() => cancelAnimationFrame(rafIdRef.current));\n\n  return [value, set] as const;\n};\n", "import type { UseStorageInitialValue, UseStorageOptions } from '../useStorage/useStorage';\n\nimport { useStorage } from '../useStorage/useStorage';\n\n/**\n * @name useSessionStorage\n * @description - Hook that manages session storage value\n * @category State\n *\n * @browserapi sessionStorage https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage\n *\n * @template Value The type of the value\n * @param {string} key The key of the storage\n * @param {UseStorageInitialValue<Value>} [initialValue] The initial value of the storage\n * @param {UseStorageOptions<Value>} [options] The options of the storage\n *\n * @example\n * const { value, set, remove } = useSessionStorage('key', 'value');\n */\nexport const useSessionStorage = <Value>(\n  key: string,\n  initialValue?: UseStorageInitialValue<Value>,\n  options?: Omit<UseStorageOptions<Value>, 'initialValue' | 'storage'>\n) =>\n  useStorage(key, {\n    ...options,\n    initialValue,\n    storage: typeof window !== 'undefined' ? window.sessionStorage : undefined\n  });\n", "import { useState } from 'react';\n\n/** The use set return type */\ninterface UseSetReturn<Value> {\n  /** The size of the set */\n  size: number;\n  /** The current set */\n  value: Set<Value>;\n  /** Function to add a value to the set */\n  add: (value: Value) => void;\n  /** Function to clear the set */\n  clear: () => void;\n  /** Function to get the symmetric difference of two sets */\n  difference: (other: Set<Value>) => void;\n  /** Function to check if a value exists in the set */\n  has: (value: Value) => boolean;\n  /** Function to get the difference of two sets */\n  intersection: (other: Set<Value>) => void;\n  /** Function to remove a value from the set */\n  remove: (value: Value) => void;\n  /** Function to toggle a value in the set */\n  reset: () => void;\n  /** Function to get the symmetric difference of two sets */\n  symmetricDifference: (other: Set<Value>) => void;\n  /** Function to toggle a value in the set */\n  toggle: (value: Value) => void;\n  /** Function to get the union of two sets */\n  union: (other: Set<Value>) => void;\n}\n\n/**\n * @name useSet\n * @description - Hook that manages a set structure\n * @category State\n *\n * @template Value The type of the value\n * @param {Value[]} [values] The initial array of the set\n * @returns {UseSetReturn<Value>} An object containing the current set and functions to interact with the set\n *\n * @example\n * const { value, add, remove, clear, reset, toggle, union, intersection, difference, symmetricDifference, size, has } = useSet([1, 2, 3]);\n */\nexport const useSet = <Value>(values?: Value[]): UseSetReturn<Value> => {\n  const [set, setSet] = useState(new Set(values));\n\n  const add = (value: Value) => setSet((prevSet) => new Set(prevSet).add(value));\n  const remove = (value: Value) =>\n    setSet((prevSet) => {\n      if (!prevSet.has(value)) return prevSet;\n      const newSet = new Set(prevSet);\n      newSet.delete(value);\n      return newSet;\n    });\n  const clear = () => setSet(new Set());\n  const reset = () => setSet(new Set(values));\n  const toggle = (value: Value) =>\n    setSet((prevSet) => {\n      if (!prevSet.has(value)) return new Set(prevSet).add(value);\n      const newSet = new Set(prevSet);\n      newSet.delete(value);\n      return newSet;\n    });\n  const union = (other: Set<Value>) => setSet(set.union(other));\n  const difference = (other: Set<Value>) => setSet(set.difference(other));\n  const symmetricDifference = (other: Set<Value>) => setSet(set.symmetricDifference(other));\n  const intersection = (other: Set<Value>) => setSet(set.intersection(other));\n  const has = (value: Value) => set.has(value);\n\n  return {\n    value: set,\n    size: set.size,\n    has,\n    add,\n    remove,\n    clear,\n    reset,\n    toggle,\n    union,\n    difference,\n    symmetricDifference,\n    intersection\n  };\n};\n", "import { useReducer } from 'react';\n\n/** The use state history hook return type */\ninterface UseStateHistoryReturn<Value> {\n  /** True if a redo operation can be performed */\n  canRedo: boolean;\n  /** True if an undo operation can be performed */\n  canUndo: boolean;\n  /** All history values */\n  history: Value[];\n  /** Current index in history */\n  index: number;\n  /** Current value */\n  value: Value;\n  /** Go back specified number of steps in history (default: 1) */\n  back: (steps?: number) => void;\n  /** Go forward specified number of steps in history (default: 1) */\n  forward: (steps?: number) => void;\n  /** Redo the last change */\n  redo: () => void;\n  /** Reset history to initial state */\n  reset: () => void;\n  /** Set a new value */\n  set: (value: Value) => void;\n  /** Undo the last change */\n  undo: () => void;\n}\n\nexport type StateHistoryAction<Value> =\n  | { type: 'BACK'; payload: { steps: number } }\n  | { type: 'FORWARD'; payload: { steps: number } }\n  | { type: 'REDO' }\n  | { type: 'RESET'; payload: { initialValue: Value; capacity: number } }\n  | { type: 'SET'; payload: { value: Value; capacity: number } }\n  | { type: 'UNDO' };\n\nexport interface StateHistory<Value> {\n  currentIndex: number;\n  history: Value[];\n  redoStack: Value[][];\n  undoStack: Value[][];\n}\n\nexport const stateHistoryReducer = <Value>(\n  state: StateHistory<Value>,\n  action: StateHistoryAction<Value>\n): StateHistory<Value> => {\n  switch (action.type) {\n    case 'SET': {\n      const { value, capacity } = action.payload;\n\n      const newHistory = [...state.history.slice(0, state.currentIndex + 1), value];\n      if (newHistory.length > capacity) {\n        newHistory.shift();\n      }\n\n      const newUndoStack = [state.history, ...state.undoStack];\n      if (newUndoStack.length > capacity) {\n        newUndoStack.pop();\n      }\n\n      return {\n        history: newHistory,\n        currentIndex: newHistory.length - 1,\n        undoStack: newUndoStack,\n        redoStack: []\n      };\n    }\n\n    case 'UNDO': {\n      if (state.undoStack.length === 0) return state;\n\n      return {\n        history: state.undoStack[0],\n        currentIndex: state.undoStack[0].length - 1,\n        undoStack: state.undoStack.slice(1),\n        redoStack: [state.history, ...state.redoStack]\n      };\n    }\n\n    case 'REDO': {\n      if (state.redoStack.length === 0) return state;\n\n      return {\n        history: state.redoStack[0],\n        currentIndex: state.redoStack[0].length - 1,\n        undoStack: [state.history, ...state.undoStack],\n        redoStack: state.redoStack.slice(1)\n      };\n    }\n\n    case 'BACK': {\n      const { steps } = action.payload;\n      return {\n        ...state,\n        currentIndex: Math.max(0, state.currentIndex - steps)\n      };\n    }\n\n    case 'FORWARD': {\n      const { steps } = action.payload;\n      return {\n        ...state,\n        currentIndex: Math.min(state.currentIndex + steps, state.history.length - 1)\n      };\n    }\n\n    case 'RESET': {\n      const { initialValue, capacity } = action.payload;\n      if (state.history.length === 1) return state;\n\n      const newUndoStack = [state.history, ...state.undoStack];\n      if (newUndoStack.length > capacity) {\n        newUndoStack.pop();\n      }\n\n      return {\n        history: [initialValue],\n        currentIndex: 0,\n        undoStack: newUndoStack,\n        redoStack: []\n      };\n    }\n\n    default:\n      throw new Error('Unsupported action type');\n  }\n};\n\n/**\n * @name useStateHistory\n * @description - Hook that manages state with history functionality\n * @category State\n *\n * @param {Value} initialValue - The initial value to start the history with\n * @param {number} [capacity=10] - Maximum number of history entries and undo actions to keep\n * @returns {UseStateHistoryReturn<Value>} Object containing current value, history array and control methods\n *\n * @example\n * const { value, history, index, set, back, forward, reset, undo, redo, canUndo, canRedo } = useStateHistory(0);\n */\nexport const useStateHistory = <Value>(\n  initialValue: Value,\n  capacity = 10\n): UseStateHistoryReturn<Value> => {\n  const [state, dispatch] = useReducer(stateHistoryReducer<Value>, {\n    history: [initialValue],\n    currentIndex: 0,\n    undoStack: [],\n    redoStack: []\n  });\n\n  const value = state.history[state.currentIndex];\n  const canUndo = state.undoStack.length > 0;\n  const canRedo = state.redoStack.length > 0;\n\n  const set = (value: Value) =>\n    dispatch({\n      type: 'SET',\n      payload: { value, capacity }\n    });\n\n  const undo = () => dispatch({ type: 'UNDO' });\n\n  const redo = () => dispatch({ type: 'REDO' });\n\n  const back = (steps = 1) => dispatch({ type: 'BACK', payload: { steps } });\n\n  const forward = (steps = 1) => dispatch({ type: 'FORWARD', payload: { steps } });\n\n  const reset = () => dispatch({ type: 'RESET', payload: { initialValue, capacity } });\n\n  return {\n    history: state.history,\n    value,\n    set,\n    index: state.currentIndex,\n    back,\n    forward,\n    reset,\n    undo,\n    redo,\n    canUndo,\n    canRedo\n  };\n};\n", "import { useRef, useState } from 'react';\n\n/** The use step params type */\nexport interface UseStepParams {\n  /** Initial value for step */\n  initial: number;\n  /** Maximum value for step */\n  max: number;\n}\n\n/** The use step return type */\nexport interface UseStepReturn {\n  /** Counts of steps */\n  counts: number;\n  /** Current value of step */\n  currentStep: number;\n  /** Boolean value if current step is first */\n  isFirst: boolean;\n  /** Boolean value if current step is last */\n  isLast: boolean;\n  /** Go to back step */\n  back: () => void;\n  /** Go to next step */\n  next: () => void;\n  /** Reset current step to initial value */\n  reset: () => void;\n  /** Go to custom step */\n  set: (value: number | 'first' | 'last') => void;\n}\n\nconst FIRST_STEP_VALUE = 1;\n\n/**\n * @name useStep\n * @description - Hook that create stepper\n * @category State\n *\n * @overload\n * @param {number} max Maximum number of steps\n * @returns {UseStepReturn} An object contains variables and functions to change the step\n *\n * @example\n * const stepper = useStep(5);\n *\n * @overload\n * @param {number} params.max Maximum number of steps\n * @param {number} params.initial Initial value for step\n * @returns {UseStepReturn} An object contains variables and functions to change the step\n *\n * @example\n * const stepper = useStep({ initial: 2, max: 5 });\n */\nexport const useStep = (params: number | UseStepParams): UseStepReturn => {\n  const max = typeof params === 'object' ? params.max : params;\n  const initial = typeof params === 'object' ? params.initial : FIRST_STEP_VALUE;\n\n  const initialStep = useRef(\n    initial > max || initial < FIRST_STEP_VALUE ? FIRST_STEP_VALUE : initial\n  );\n  const [currentStep, setCurrentStep] = useState(initial);\n\n  const isFirst = currentStep === FIRST_STEP_VALUE;\n  const isLast = currentStep === max;\n\n  const next = () => {\n    if (isLast) return;\n    setCurrentStep((prevStep) => prevStep + 1);\n  };\n\n  const back = () => {\n    if (isFirst) return;\n    setCurrentStep((prevStep) => prevStep - 1);\n  };\n\n  const reset = () => setCurrentStep(initialStep.current);\n\n  const set = (value: number | 'first' | 'last') => {\n    if (value === 'first') return setCurrentStep(initialStep.current);\n    if (value === 'last') return setCurrentStep(max);\n    if (value >= max) return setCurrentStep(max);\n    if (value <= FIRST_STEP_VALUE) return setCurrentStep(FIRST_STEP_VALUE);\n    setCurrentStep(value);\n  };\n\n  return {\n    counts: max,\n    currentStep,\n    isFirst,\n    isLast,\n    next,\n    back,\n    reset,\n    set\n  };\n};\n", "import type { SetStateAction } from 'react';\n\nimport { useReducer } from 'react';\n\n/** The use toggle return type */\nexport type UseToggleReturn<Value> = readonly [Value, (value?: Value) => void];\n\n/**\n * @name useToggle\n * @description - Hook that create toggle\n * @category State\n *\n * @template Value The type of the value\n * @param {Value[]} [values=[false, true]] The values to toggle\n *\n * @example\n * const [on, toggle] = useToggle();\n *\n * @example\n * const [value, toggle] = useToggle(['light', 'dark'] as const);\n */\nexport const useToggle = <Value = boolean>(values: readonly Value[] = [false, true] as any) => {\n  const [[option], toggle] = useReducer((state: Value[], action: SetStateAction<Value>) => {\n    const value =\n      typeof action === 'function' ? (action as (prevState: Value) => Value)(state[0]) : action;\n    const index = Math.abs(state.indexOf(value));\n    return state.slice(index).concat(state.slice(0, index));\n  }, values as Value[]);\n\n  return [option, toggle as (value?: SetStateAction<Value>) => void] as const;\n};\n", "import { useEffect, useState } from 'react';\n\n/** The url search params mode type */\nexport type UrlSearchParamMode = 'hash-params' | 'hash' | 'history';\n\n/** The use url search param options type */\nexport interface UseUrlSearchParamOptions<Value> {\n  /** The initial value of the search param */\n  initialValue?: Value;\n  /** The mode to use for writing to the URL */\n  mode?: UrlSearchParamMode;\n  /** The mode to use for writing to the URL */\n  write?: 'push' | 'replace';\n  /** The deserializer function to be invoked */\n  deserializer?: (value: string) => Value;\n  /** The serializer function to be invoked */\n  serializer?: (value: Value) => string;\n}\n\n/** The use url search params set options type */\nexport interface UseUrlSearchParamsActionOptions {\n  /** The mode to use for writing to the URL */\n  write?: 'push' | 'replace';\n}\n\n/** The use url search param return type */\nexport interface UseUrlSearchParamReturn<Value> {\n  /** Current search param value */\n  value: Value | undefined;\n  /** Function to remove the search param */\n  remove: (options?: UseUrlSearchParamsActionOptions) => void;\n  /** Function to update search param */\n  set: (value: Value, options?: UseUrlSearchParamsActionOptions) => void;\n}\n\nexport const URL_SEARCH_PARAMS_EVENT = 'reactuse-url-search-params-event';\n\nexport const getUrlSearchParams = (mode: UrlSearchParamMode = 'history') => {\n  const { search, hash } = window.location;\n\n  let path = '';\n\n  if (mode === 'history') path = search;\n  if (mode === 'hash-params') path = hash.replace(/^#/, '');\n  if (mode === 'hash') {\n    const index = hash.indexOf('?');\n    path = ~index ? hash.slice(index) : '';\n  }\n\n  return new URLSearchParams(path);\n};\n\nexport const createQueryString = (searchParams: URLSearchParams, mode: UrlSearchParamMode) => {\n  const searchParamsString = searchParams.toString();\n  const { search, hash } = window.location;\n\n  if (mode === 'history') return `${searchParamsString ? `?${searchParamsString}` : ''}${hash}`;\n  if (mode === 'hash-params')\n    return `${search}${searchParamsString ? `#${searchParamsString}` : ''}`;\n  if (mode === 'hash') {\n    const index = hash.indexOf('?');\n    const base = index > -1 ? hash.slice(0, index) : hash;\n    return `${search}${base}${searchParamsString ? `?${searchParamsString}` : ''}`;\n  }\n\n  throw new Error('Invalid mode');\n};\n\nexport const dispatchUrlSearchParamsEvent = () =>\n  window.dispatchEvent(new Event(URL_SEARCH_PARAMS_EVENT));\n\nexport interface UseUrlSearchParam {\n  <Value>(\n    key: string,\n    options: UseUrlSearchParamOptions<Value> & { initialValue: Value }\n  ): UseUrlSearchParamReturn<Value>;\n\n  <Value>(\n    key: string,\n    options?: UseUrlSearchParamOptions<Value>\n  ): UseUrlSearchParamReturn<Value | undefined>;\n\n  <Value>(key: string, initialValue: Value): UseUrlSearchParamReturn<Value>;\n\n  <Value>(key: string): UseUrlSearchParamReturn<Value | undefined>;\n}\n\n/**\n * @name useUrlSearchParam\n * @description - Hook that provides reactive URLSearchParams for a single key\n * @category State\n *\n * @overload\n * @template Value The type of the url param values\n * @param {string} key The key of the url param\n * @param {UseUrlSearchParamOptions<Value> & { initialValue: Value }} options The options object with required initialValue\n * @param {Value} options.initialValue The initial value for the url param\n * @param {UrlSearchParamsMode} [options.mode='history'] The mode to use for the URL ('history' | 'hash-params' | 'hash')\n * @param {'push' | 'replace'} [options.write='replace'] The mode to use for writing to the URL\n * @param {(value: Value) => string} [options.serializer] Custom serializer function to convert value to string\n * @param {(value: string) => Value} [options.deserializer] Custom deserializer function to convert string to value\n * @returns {UseUrlSearchParamReturn<Value>} The object with value and function for change value\n *\n * @example\n * const { value, set } = useUrlSearchParam('page', { initialValue: 1 });\n *\n * @overload\n * @template Value The type of the url param values\n * @param {string} key The key of the url param\n * @param {Value} [initialValue] The initial value for the url param\n * @returns {UseUrlSearchParamReturn<Value>} The object with value and function for change value\n *\n * @example\n * const { value, set } = useUrlSearchParam('page', 1);\n */\nexport const useUrlSearchParam = (<Value>(key: string, params?: any) => {\n  const options = (\n    typeof params === 'object' &&\n    params &&\n    ('serializer' in params ||\n      'deserializer' in params ||\n      'initialValue' in params ||\n      'mode' in params ||\n      'write' in params)\n      ? params\n      : undefined\n  ) as UseUrlSearchParamOptions<Value>;\n\n  const initialValue = (options ? options?.initialValue : params) as Value;\n  const { mode = 'history', write: writeMode = 'replace' } = options ?? {};\n\n  if (typeof window === 'undefined') {\n    return {\n      value: initialValue,\n      remove: () => {},\n      set: () => {}\n    } as UseUrlSearchParamReturn<Value>;\n  }\n\n  const serializer = (value: Value) => {\n    if (options?.serializer) return options.serializer(value);\n    if (typeof value === 'string') return value;\n\n    return JSON.stringify(value);\n  };\n\n  const deserializer = (value: string) => {\n    if (options?.deserializer) return options.deserializer(value);\n    if (value === 'undefined' || value === 'null') return undefined as unknown as Value;\n\n    try {\n      return JSON.parse(value) as Value;\n    } catch {\n      return value as Value;\n    }\n  };\n\n  const setUrlSearchParam = (\n    key: string,\n    value: Value | undefined,\n    mode: UrlSearchParamMode,\n    write: 'push' | 'replace' = 'replace'\n  ) => {\n    const searchParams = getUrlSearchParams(mode);\n    const serializedValue =\n      value !== undefined ? (serializer ? serializer(value) : String(value)) : '';\n\n    if (value === undefined) {\n      searchParams.delete(key);\n    } else {\n      searchParams.set(key, serializedValue);\n    }\n\n    const query = createQueryString(searchParams, mode);\n    if (write === 'replace') window.history.replaceState({}, '', query);\n    if (write === 'push') window.history.pushState({}, '', query);\n\n    dispatchUrlSearchParamsEvent();\n  };\n\n  const [value, setValue] = useState<Value | undefined>(() => {\n    const searchParams = getUrlSearchParams(mode);\n    const currentValue = searchParams.get(key);\n\n    if (currentValue === null && initialValue !== undefined) {\n      setUrlSearchParam(key, initialValue, mode, writeMode);\n      return initialValue;\n    }\n\n    return currentValue ? deserializer(currentValue) : undefined;\n  });\n\n  const set = (value: Value, options?: UseUrlSearchParamsActionOptions) => {\n    setUrlSearchParam(key, value, mode, options?.write ?? writeMode);\n    setValue(value);\n  };\n\n  const remove = (options?: UseUrlSearchParamsActionOptions) => {\n    setUrlSearchParam(key, undefined, mode, options?.write ?? writeMode);\n    setValue(undefined);\n  };\n\n  useEffect(() => {\n    const onParamsChange = () => {\n      const searchParams = getUrlSearchParams(mode);\n      const newValue = searchParams.get(key);\n      setValue(newValue ? deserializer(newValue) : undefined);\n    };\n\n    window.addEventListener(URL_SEARCH_PARAMS_EVENT, onParamsChange);\n    window.addEventListener('popstate', onParamsChange);\n    if (mode !== 'history') {\n      window.addEventListener('hashchange', onParamsChange);\n    }\n\n    return () => {\n      window.removeEventListener(URL_SEARCH_PARAMS_EVENT, onParamsChange);\n      window.removeEventListener('popstate', onParamsChange);\n      if (mode !== 'history') {\n        window.removeEventListener('hashchange', onParamsChange);\n      }\n    };\n  }, [key, mode]);\n\n  return {\n    value,\n    remove,\n    set\n  };\n}) as UseUrlSearchParam;\n", "import { useEffect, useState } from 'react';\n\nimport {\n  createQueryString,\n  dispatchUrlSearchParamsEvent,\n  getUrlSearchParams,\n  URL_SEARCH_PARAMS_EVENT\n} from '../useUrlSearchParam/useUrlSearchParam';\n\n/** The url params type */\nexport type UrlParams = Record<string, any>;\n\n/** The url search params mod */\nexport type UrlSearchParamsMode = 'hash-params' | 'hash' | 'history';\n\n/** The use url search params set options type */\nexport interface UseUrlSearchParamsSetOptions {\n  /** The mode to use for writing to the URL */\n  write?: 'push' | 'replace';\n}\n\n/* The use search params initial value type */\nexport type UseUrlSearchParamsInitialValue<Value> = (() => Value) | Value;\n\n/** The use url search params options type */\nexport interface UseUrlSearchParamsOptions<Value> {\n  /* The initial value of the url search params */\n  initialValue?: UseUrlSearchParamsInitialValue<string | URLSearchParams | Value>;\n  /** The mode to use for writing to the URL */\n  mode?: UrlSearchParamsMode;\n  /** The mode to use for writing to the URL  */\n  write?: 'push' | 'replace';\n  /* The deserializer function to be invoked */\n  deserializer?: (value: string) => Value[keyof Value];\n  /* The serializer function to be invoked */\n  serializer?: (value: Value[keyof Value]) => string;\n}\n\n/** The use url search params return type */\nexport interface UseUrlSearchParamsReturn<Value> {\n  /** The value of the url search params */\n  value: Value;\n  /** The set function */\n  set: (value: Partial<Value>, options?: UseUrlSearchParamsSetOptions) => void;\n}\n\nexport interface UseUrlSearchParams {\n  <Value>(\n    key: string,\n    options: UseUrlSearchParamsOptions<Value> & {\n      initialValue: UseUrlSearchParamsInitialValue<Value>;\n    }\n  ): UseUrlSearchParamsReturn<Value>;\n\n  <Value>(options?: UseUrlSearchParamsOptions<Value>): UseUrlSearchParamsReturn<Value | undefined>;\n\n  <Value>(initialValue: UseUrlSearchParamsInitialValue<Value>): UseUrlSearchParamsReturn<Value>;\n\n  <Value>(key: string): UseUrlSearchParamsReturn<Value | undefined>;\n}\n\n/**\n * @name useUrlSearchParams\n * @description - Hook that provides reactive URLSearchParams\n * @category State\n *\n * @overload\n * @template Value The type of the url param values\n * @param {UseUrlSearchParamsOptions<Value> & { initialValue: UseUrlSearchParamsInitialValue<Value> }} options The options object with required initialValue\n * @param {UseUrlSearchParamsInitialValue<Value>} [options.initialValue] The initial value for the url params\n * @param {UrlSearchParamsMode} [options.mode='history'] The mode to use for the URL ('history' | 'hash-params' | 'hash')\n * @param {'push' | 'replace'} [options.write='replace'] The mode to use for writing to the URL\n * @param {(value: Value[keyof Value]) => string} [options.serializer] Custom serializer function to convert value to string\n * @param {(value: string) => Value[keyof Value]} [options.deserializer] Custom deserializer function to convert string to value\n * @returns {UseUrlSearchParamsReturn<Value>} The object with value and function for change value\n *\n * @example\n * const { value, set } = useUrlSearchParams({ initialValue: { page: 1 } });\n *\n * @overload\n * @template Value The type of the url param values\n * @param {UseUrlSearchParamsInitialValue<Value>} [initialValue] The initial value for the url params\n * @returns {UseUrlSearchParamsReturn<Value>} The object with value and function for change value\n *\n * @example\n * const { value, set } = useUrlSearchParams({ page: 1 });\n */\nexport const useUrlSearchParams = (<Value extends UrlParams>(\n  params: any\n): UseUrlSearchParamsReturn<Value> => {\n  const options = (\n    typeof params === 'object' &&\n    params &&\n    ('serializer' in params ||\n      'deserializer' in params ||\n      'initialValue' in params ||\n      'mode' in params ||\n      'write' in params)\n      ? params\n      : undefined\n  ) as UseUrlSearchParamsOptions<Value>;\n  const initialValue = (\n    options ? options?.initialValue : params\n  ) as UseUrlSearchParamsInitialValue<Value>;\n\n  const { mode = 'history', write: writeMode = 'replace' } = options;\n\n  const serializer = (value: Value[keyof Value]) => {\n    if (options?.serializer) return options.serializer(value);\n    if (typeof value === 'string') return value;\n    return JSON.stringify(value);\n  };\n\n  const deserializer = (value: string) => {\n    if (options?.deserializer) return options.deserializer(value);\n    if (value === 'undefined') return undefined as unknown as Value[keyof Value];\n\n    try {\n      return JSON.parse(value) as Value;\n    } catch {\n      return value as Value[keyof Value];\n    }\n  };\n\n  const setUrlSearchParams = <Value extends UrlParams>(\n    mode: UrlSearchParamsMode,\n    value: Partial<Value>,\n    write: 'push' | 'replace' = 'replace'\n  ) => {\n    const urlSearchParams = new URLSearchParams();\n\n    Object.entries(value).forEach(([key, param]) => {\n      if (Array.isArray(param)) {\n        param.forEach((value) => urlSearchParams.set(key, serializer(value)));\n      } else {\n        urlSearchParams.set(key, serializer(param));\n      }\n    });\n\n    const query = createQueryString(urlSearchParams, mode);\n    if (write === 'replace') window.history.replaceState({}, '', query);\n    if (write === 'push') window.history.pushState({}, '', query);\n\n    return urlSearchParams;\n  };\n\n  const getParsedUrlSearchParams = (searchParams: string | UrlParams | URLSearchParams) => {\n    if (typeof searchParams === 'string') {\n      return getParsedUrlSearchParams(new URLSearchParams(searchParams));\n    }\n\n    if (searchParams instanceof URLSearchParams) {\n      return Array.from(searchParams.entries()).reduce(\n        (acc, [key, value]) => {\n          acc[key] = deserializer(value);\n          return acc;\n        },\n        {} as Record<string, any>\n      );\n    }\n\n    return searchParams;\n  };\n\n  const [value, setValue] = useState<Value>(() => {\n    if (typeof window === 'undefined') return (initialValue ?? {}) as Value;\n\n    const urlSearchParams = getUrlSearchParams(mode);\n    const value = {\n      ...(initialValue && getParsedUrlSearchParams(initialValue)),\n      ...getParsedUrlSearchParams(urlSearchParams)\n    } as Value;\n\n    setUrlSearchParams(mode, value, writeMode);\n\n    return value;\n  });\n\n  const set = (params: Partial<Value>, options?: UseUrlSearchParamsSetOptions) => {\n    const searchParams = setUrlSearchParams(\n      mode,\n      { ...value, ...params },\n      options?.write ?? writeMode\n    );\n    setValue(getParsedUrlSearchParams(searchParams) as Value);\n    dispatchUrlSearchParamsEvent();\n  };\n\n  useEffect(() => {\n    const onParamsChange = () => {\n      const searchParams = getUrlSearchParams(mode);\n      setValue(getParsedUrlSearchParams(searchParams) as Value);\n    };\n\n    window.addEventListener(URL_SEARCH_PARAMS_EVENT, onParamsChange);\n    window.addEventListener('popstate', onParamsChange);\n    if (mode !== 'history') window.addEventListener('hashchange', onParamsChange);\n\n    return () => {\n      window.removeEventListener(URL_SEARCH_PARAMS_EVENT, onParamsChange);\n      window.removeEventListener('popstate', onParamsChange);\n      if (mode !== 'history') window.removeEventListener('hashchange', onParamsChange);\n    };\n  }, [mode]);\n\n  return {\n    value,\n    set\n  };\n}) as UseUrlSearchParams;\n\nexport { createQueryString, dispatchUrlSearchParamsEvent, getUrlSearchParams };\n", "import { useState } from 'react';\n\nexport interface WizardItem<WizardStepId> {\n  id: WizardStepId;\n  nodes?: WizardStepId[];\n}\n\n/**\n * @name useWizard\n * @description - Hook that manages a wizard\n * @category State\n *\n * @param {WizardItem<WizardStepId>[]} map The map of the wizard\n * @param {WizardStepId} [initialStepId] The initial step id\n * @returns {UseWizardReturn<WizardStepId>} An object containing the current step id and functions to interact with the wizard\n *\n * @example\n * const { currentStepId, set, reset, back, next, history } = useWizard([\n *  { id: 'step1', nodes: ['step2', 'step3'] },\n *  { id: 'step2', nodes: ['step3'] },\n *  { id: 'step3', nodes: [] },\n * ])\n */\nexport const useWizard = <WizardStepId extends string>(\n  map: WizardItem<WizardStepId>[],\n  initialStepId?: WizardStepId\n) => {\n  const initialId = initialStepId ?? map[0].id;\n  const wizardMap = new Map(map.map((wizardItem) => [wizardItem.id, wizardItem]));\n  const [currentStepId, setCurrentStepId] = useState(initialId);\n  const [history, setHistory] = useState<WizardStepId[]>([initialId]);\n\n  const set = (id: WizardStepId) => {\n    if (!wizardMap.get(currentStepId)?.nodes?.includes(id))\n      throw new Error(`Can't go to ${id} from ${currentStepId}`);\n\n    setHistory([...history, id]);\n    setCurrentStepId(id);\n  };\n\n  const back = () => {\n    if (history.length === 1) return;\n\n    const previousStepId = history[history.length - 2];\n    if (!wizardMap.get(currentStepId)?.nodes?.includes(previousStepId))\n      throw new Error(`Can't go to ${previousStepId} from ${currentStepId}`);\n\n    setHistory(history.slice(0, -1));\n    setCurrentStepId(history[history.length - 2]);\n  };\n\n  const reset = () => {\n    setCurrentStepId(initialId);\n    setHistory([initialId]);\n  };\n\n  return { currentStepId, set, reset, back, history };\n};\n", "import { useEffect, useRef, useState } from 'react';\n\n/** The use interval options */\nexport interface UseIntervalOptions {\n  /** Start the interval immediately */\n  immediately?: boolean;\n}\n\n/** The use interval return type */\nexport interface UseIntervalReturn {\n  /** Is the interval active */\n  active: boolean;\n  /** Pause the interval */\n  pause: () => void;\n  /** Resume the interval */\n  resume: () => void;\n  /** Toggle the interval */\n  toggle: () => void;\n}\n\ninterface UseInterval {\n  (callback: () => void, interval?: number, options?: UseIntervalOptions): UseIntervalReturn;\n\n  (callback: () => void, options?: UseIntervalOptions & { interval?: number }): UseIntervalReturn;\n}\n\n/**\n * @name useInterval\n * @description - Hook that makes and interval and returns controlling functions\n * @category Time\n *\n * @overload\n * @param {() => void} callback Any callback function\n * @param {number} [interval=1000] Time in milliseconds\n * @param {boolean} [options.immediately=true] Start the interval immediately\n * @returns {UseIntervalReturn}\n *\n * @example\n * const { active, pause, resume, toggle } = useInterval(() => console.log('inside interval'), 2500);\n *\n * @overload\n * @param {() => void} callback Any callback function\n * @param {number} [options.interval=1000] Time in milliseconds\n * @param {boolean} [options.immediately=true] Start the interval immediately\n *\n * @example\n * const { active, pause, resume, toggle } = useInterval(() => console.log('inside interval'), { interval: 2500 });\n */\nexport const useInterval = ((...params: any[]): UseIntervalReturn => {\n  const callback = params[0] as () => void;\n  const interval =\n    ((typeof params[1] === 'number'\n      ? params[1]\n      : (params[1] as UseIntervalOptions & { interval?: number }).interval) as number) ?? 1000;\n  const options =\n    typeof params[1] === 'object'\n      ? (params[1] as (UseIntervalOptions & { interval?: number }) | undefined)\n      : (params[2] as UseIntervalOptions | undefined);\n  const immediately = options?.immediately ?? true;\n\n  const [active, setActive] = useState<boolean>(immediately ?? true);\n\n  const intervalIdRef = useRef<ReturnType<typeof setInterval>>(undefined);\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n\n  useEffect(() => {\n    if (!active) return;\n\n    intervalIdRef.current = setInterval(() => internalCallbackRef.current(), interval);\n    return () => {\n      clearInterval(intervalIdRef.current);\n    };\n  }, [active, interval]);\n\n  const pause = () => setActive(false);\n\n  const resume = () => {\n    if (interval <= 0) return;\n    setActive(true);\n  };\n\n  const toggle = () => setActive(!active);\n\n  return {\n    active,\n    pause,\n    resume,\n    toggle\n  };\n}) as UseInterval;\n", "import { useEffect, useState } from 'react';\n\nconst getStopwatchTime = (time: number) => {\n  if (!time)\n    return {\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      count: 0\n    };\n\n  const days = Math.floor(time / 86400);\n  const hours = Math.floor((time % 86400) / 3600);\n  const minutes = Math.floor((time % 3600) / 60);\n  const seconds = Math.floor(time % 60);\n\n  return { days, hours, minutes, seconds, count: time };\n};\n\n/** The use stopwatch return type */\nexport interface UseStopwatchReturn {\n  /** The total count of the stopwatch */\n  count: number;\n  /** The day count of the stopwatch */\n  days: number;\n  /** The hour count of the stopwatch */\n  hours: number;\n  /** The minute count of the stopwatch */\n  minutes: number;\n  /** The over state of the stopwatch */\n  over: boolean;\n  /** The paused state of the stopwatch */\n  paused: boolean;\n  /** The second count of the stopwatch */\n  seconds: number;\n  /** The function to pause the stopwatch */\n  pause: () => void;\n  /** The function to reset the stopwatch */\n  reset: () => void;\n  /** The function to start the stopwatch */\n  start: () => void;\n  /** The function to toggle the stopwatch */\n  toggle: () => void;\n}\n\n/** The use stopwatch options */\nexport interface UseStopwatchOptions {\n  /** The immediately state of the timer */\n  immediately?: boolean;\n}\n\ninterface UseStopwatch {\n  (initialTime?: number, options?: UseStopwatchOptions): UseStopwatchReturn;\n  (options?: UseStopwatchOptions & { initialTime?: number }): UseStopwatchReturn;\n}\n/**\n * @name useStopwatch\n * @description - Hook that creates a stopwatch functionality\n * @category Time\n *\n * @overload\n * @param {number} [initialTime=0] The initial time of the timer\n * @param {boolean} [options.enabled=true] The enabled state of the timer\n * @returns {UseStopwatchReturn} An object containing the current time and functions to interact with the timer\n *\n * @example\n * const { seconds, minutes, start, pause, reset } = useStopwatch(1000, { enabled: false });\n *\n * @overload\n * @param {number} [options.initialTime=0] -The initial time of the timer\n * @param {boolean} [options.enabled=true] The enabled state of the timer\n * @returns {UseStopwatchReturn} An object containing the current time and functions to interact with the timer\n *\n * @example\n * const { seconds, minutes, start, pause, reset } = useStopwatch({ initialTime: 1000, enabled: false });\n */\nexport const useStopwatch = ((...params: any[]) => {\n  const initialTime =\n    (typeof params[0] === 'number'\n      ? (params[0] as number | undefined)\n      : (params[0] as UseStopwatchOptions & { initialTime?: number })?.initialTime) ?? 0;\n\n  const options =\n    typeof params[0] === 'number'\n      ? (params[1] as UseStopwatchOptions | undefined)\n      : (params[0] as (UseStopwatchOptions & { initialTime?: number }) | undefined);\n\n  const immediately = options?.immediately ?? false;\n\n  const [time, setTime] = useState(getStopwatchTime(initialTime));\n  const [paused, setPaused] = useState(!immediately && !initialTime);\n\n  useEffect(() => {\n    if (paused) return;\n    const onInterval = () => {\n      setTime((prevTime) => {\n        const updatedCount = prevTime.count + 1;\n\n        if (updatedCount % 60 === 0) {\n          return {\n            ...prevTime,\n            minutes: prevTime.minutes + 1,\n            seconds: 0,\n            count: updatedCount\n          };\n        }\n\n        if (updatedCount % (60 * 60) === 0) {\n          return {\n            ...prevTime,\n            hours: prevTime.hours + 1,\n            minutes: 0,\n            seconds: 0,\n            count: updatedCount\n          };\n        }\n\n        if (updatedCount % (60 * 60 * 24) === 0) {\n          return {\n            ...prevTime,\n            days: prevTime.days + 1,\n            hours: 0,\n            minutes: 0,\n            seconds: 0,\n            count: updatedCount\n          };\n        }\n\n        return {\n          ...prevTime,\n          seconds: prevTime.seconds + 1,\n          count: updatedCount\n        };\n      });\n    };\n\n    const interval = setInterval(() => onInterval(), 1000);\n    return () => clearInterval(interval);\n  }, [paused]);\n\n  return {\n    ...time,\n    paused,\n    pause: () => setPaused(true),\n    start: () => setPaused(false),\n    reset: () => setTime(getStopwatchTime(initialTime)),\n    toggle: () => setPaused((prevPause) => !prevPause)\n  };\n}) as UseStopwatch;\n", "export const getDate = (now: Date = new Date()) => {\n  const seconds = now.getSeconds();\n  const minutes = now.getMinutes();\n  const hours = now.getHours();\n  const meridiemHours = hours % 12 === 0 ? 12 : hours % 12;\n  const meridiemType = hours >= 12 ? 'pm' : 'am';\n  const day = now.getDate();\n  const month = now.getMonth() + 1;\n  const year = now.getFullYear();\n  const timestamp = now.getTime();\n\n  return {\n    seconds,\n    minutes,\n    hours,\n    meridiemHours: { value: meridiemHours, type: meridiemType },\n    day,\n    month,\n    year,\n    timestamp\n  };\n};\n", "import { useEffect, useState } from 'react';\n\nimport { getDate } from '@/utils/helpers';\n\nexport interface UseTimeReturn {\n  /** The current day of the month (1-31) */\n  day: number;\n  /** The current hour in 24-hour format (0-23) */\n  hours: number;\n  /** The current hour in 12-hour format with meridiem type (AM/PM) */\n  meridiemHours: { value: number; type: string };\n  /** The current minute (0-59) */\n  minutes: number;\n  /** The current month (1-12) */\n  month: number;\n  /** The current second (0-59) */\n  seconds: number;\n  /** The current Unix timestamp in milliseconds */\n  timestamp: number;\n  /** The current year */\n  year: number;\n}\n\n/**\n * @name useTime\n * @description - Hook that gives you current time in different values\n * @category Time\n *\n * @returns {UseTimeReturn} An object containing the current time\n *\n * @example\n * const { seconds, minutes, hours, meridiemHours, day, month, year, timestamp } = useTime();\n */\nexport const useTime = (): UseTimeReturn => {\n  const [time, setTime] = useState(getDate());\n\n  useEffect(() => {\n    const timerId = setInterval(() => setTime(getDate()), 1000);\n\n    return () => {\n      clearInterval(timerId);\n    };\n  }, []);\n\n  return time;\n};\n", "import { useEffect, useRef, useState } from 'react';\n\nimport { useEvent } from '../useEvent/useEvent';\n\n/** The use timeout return type */\ninterface UseTimeoutReturn {\n  /**  Timeout is ready state value */\n  ready: boolean;\n  /** Function to clear timeout */\n  clear: () => void;\n}\n\n/**\n * @name useTimeout\n * @description - Hook that executes a callback function after a specified delay\n * @category Time\n *\n * @param {() => void} callback The function to be executed after the timeout\n * @param {number} delay The delay in milliseconds before the timeout executes the callback function\n * @returns {UseTimeoutReturn} An object with a `ready` boolean state value and a `clear` function to clear timeout\n *\n * @example\n * const { clear, ready } = useTimeout(() => {}, 5000);\n */\nexport function useTimeout(callback: () => void, delay: number): UseTimeoutReturn {\n  const [ready, setReady] = useState(false);\n\n  const timeoutIdRef = useRef<ReturnType<typeof setTimeout>>(undefined);\n  const internalCallback = useEvent(callback);\n\n  useEffect(() => {\n    timeoutIdRef.current = setTimeout(() => {\n      internalCallback();\n      setReady(true);\n    }, delay);\n\n    return () => {\n      clearTimeout(timeoutIdRef.current);\n    };\n  }, [delay]);\n\n  const clear = () => {\n    clearTimeout(timeoutIdRef.current);\n    setReady(true);\n  };\n\n  return { ready, clear };\n}\n", "import { useEffect, useRef, useState } from 'react';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\n\nexport type PositiveInteger<Value extends number> = `${Value}` extends `-${any}` | `${any}.${any}`\n  ? never\n  : Value;\n\nexport const getTimeFromSeconds = (timestamp: number) => {\n  const roundedTimestamp = Math.ceil(timestamp);\n  const days = Math.floor(roundedTimestamp / (60 * 60 * 24));\n  const hours = Math.floor((roundedTimestamp % (60 * 60 * 24)) / (60 * 60));\n  const minutes = Math.floor((roundedTimestamp % (60 * 60)) / 60);\n  const seconds = Math.floor(roundedTimestamp % 60);\n\n  return {\n    seconds,\n    minutes,\n    hours,\n    days\n  };\n};\n\n/** The use timer options type */\nexport interface UseTimerOptions {\n  /** Whether the timer should start automatically */\n  immediately?: boolean;\n  /** The function to be executed when the timer is expired */\n  onExpire?: () => void;\n  /** The function to be executed when the timer is started */\n  onStart?: () => void;\n  /** Callback function to be executed on each tick of the timer */\n  onTick?: (seconds: number) => void;\n}\n\n/** The use timer return type */\nexport interface UseTimerReturn {\n  /** flag to indicate if timer is active or not */\n  active: boolean;\n  /** The total count of the timer */\n  count: number;\n  /** The day count of the timer */\n  days: number;\n  /** The hour count of the timer */\n  hours: number;\n  /** The minute count of the timer */\n  minutes: number;\n  /** The second count of the timer */\n  seconds: number;\n  /** The function to clear the timer */\n  clear: () => void;\n  /** The function to decrease the timer */\n  decrease: (seconds: PositiveInteger<number>) => void;\n  /** The function to increase the timer */\n  increase: (seconds: PositiveInteger<number>) => void;\n  /** The function to pause the timer */\n  pause: () => void;\n  /** The function to restart the timer */\n  restart: (time: PositiveInteger<number>, immediately?: boolean) => void;\n  /** The function to resume the timer */\n  resume: () => void;\n  /** The function to start the timer */\n  start: () => void;\n  /** The function to toggle the timer */\n  toggle: () => void;\n}\n\nexport interface UseTimer {\n  (): UseTimerReturn;\n\n  (seconds: PositiveInteger<number>, callback: () => void): UseTimerReturn;\n\n  (seconds: PositiveInteger<number>, options?: UseTimerOptions): UseTimerReturn;\n}\n\n/**\n * @name useTimer\n * @description - Hook that creates a timer functionality\n * @category Time\n *\n * @overload\n * @returns {UseTimerReturn} An object containing the timer properties and functions\n *\n * @example\n * const { days, hours, minutes, seconds, toggle, pause, start, restart, resume, active, decrease, increase } = useTimer();\n *\n * @overload\n * @param {number} seconds The seconds value that define for how long the timer will be running\n * @param {() => void} callback The function to be executed once countdown timer is expired\n * @returns {UseTimerReturn} An object containing the timer properties and functions\n *\n * @example\n * const { days, hours, minutes, seconds, toggle, pause, start, restart, resume, active, decrease, increase } = useTimer(1000, () => console.log('ready'));\n *\n * @overload\n * @param {number} seconds The seconds value that define for how long the timer will be running\n * @param {boolean} [options.immediately=true] The flag to decide if timer should start automatically\n * @param {() => void} [options.onExpire] The function to be executed when the timer is expired\n * @param {(timestamp: number) => void} [options.onTick] The function to be executed on each tick of the timer\n * @returns {UseTimerReturn} An object containing the timer properties and functions\n *\n * @example\n * const { days, hours, minutes, seconds, toggle, pause, start, restart, resume, active, decrease, increase } = useTimer(1000);\n */\nexport const useTimer = ((...params: any[]) => {\n  const initialSeconds = Math.max((params[0] ?? 0) as PositiveInteger<number>, 0);\n  const options = (typeof params[1] === 'object' ? params[1] : { onExpire: params[1] }) as\n    | UseTimerOptions\n    | undefined;\n\n  const [active, setActive] = useState(initialSeconds > 0 && (options?.immediately ?? true));\n  const [seconds, setSeconds] = useState(initialSeconds);\n\n  const intervalIdRef = useRef<ReturnType<typeof setInterval>>(undefined);\n  const optionsRef = useRef<UseTimerOptions>(options);\n  optionsRef.current = options ?? {};\n\n  useDidUpdate(() => {\n    if (initialSeconds <= 0) {\n      setActive(false);\n      setSeconds(0);\n      return;\n    }\n\n    setActive(true);\n    setSeconds(initialSeconds);\n  }, [initialSeconds]);\n\n  useEffect(() => {\n    if (!active) return;\n\n    optionsRef.current?.onStart?.();\n    const onInterval = () => {\n      setSeconds((prevSeconds) => {\n        optionsRef.current?.onTick?.(prevSeconds);\n        const updatedSeconds = prevSeconds - 1;\n        if (updatedSeconds === 0) {\n          setActive(false);\n          optionsRef.current?.onExpire?.();\n        }\n        return updatedSeconds;\n      });\n    };\n\n    intervalIdRef.current = setInterval(onInterval, 1000);\n    return () => {\n      clearInterval(intervalIdRef.current);\n    };\n  }, [active]);\n\n  const pause = () => setActive(false);\n  const resume = () => {\n    if (seconds <= 0) return;\n    setActive(true);\n  };\n\n  const toggle = () => {\n    if (seconds <= 0) return;\n    setActive(!active);\n  };\n\n  const restart = (seconds: PositiveInteger<number>, immediately = true) => {\n    setSeconds(seconds);\n    if (immediately) setActive(true);\n  };\n\n  const start = () => {\n    if (initialSeconds <= 0) return;\n\n    setActive(true);\n    setSeconds(initialSeconds);\n  };\n\n  const clear = () => {\n    setActive(false);\n    setSeconds(0);\n  };\n\n  const increase = (seconds: PositiveInteger<number>) =>\n    setSeconds((prevSeconds) => prevSeconds + seconds);\n  const decrease = (seconds: PositiveInteger<number>) => {\n    setSeconds((prevSeconds) => {\n      const updatedSeconds = prevSeconds - seconds;\n      if (updatedSeconds <= 0) {\n        setActive(false);\n        return 0;\n      } else {\n        return updatedSeconds;\n      }\n    });\n  };\n\n  return {\n    ...getTimeFromSeconds(seconds),\n    count: seconds,\n    pause,\n    active,\n    resume,\n    toggle,\n    start,\n    restart,\n    clear,\n    increase,\n    decrease\n  };\n}) as UseTimer;\n", "import { useSyncExternalStore } from 'react';\n\nconst getSnapshot = () => navigator.language;\nconst getServerSnapshot = () => 'undetermined';\nconst subscribe = (callback: () => void) => {\n  window.addEventListener('languagechange', callback);\n  return () => window.removeEventListener('languagechange', callback);\n};\n\n/**\n * @name useBrowserLanguage\n * @description - Hook that returns the current browser language\n * @category User\n *\n * @browserapi navigator.language https://developer.mozilla.org/en-US/docs/Web/API/Navigator/language\n *\n * @returns {string} The current browser language\n *\n * @example\n * const browserLanguage = useBrowserLanguage();\n */\nexport const useBrowserLanguage = () =>\n  useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n", "import { useState } from 'react';\n\n/** The operating system type */\nexport type OperatingSystem = 'android' | 'ios' | 'linux' | 'macos' | 'undetermined' | 'windows';\n\nexport const getOperatingSystem = (): OperatingSystem => {\n  if (typeof window === 'undefined') return 'undetermined';\n\n  const { userAgent } = window.navigator;\n\n  if (/Macintosh|MacIntel|MacPPC|Mac68K/i.test(userAgent)) return 'macos';\n  if (/iPhone|iPad|iPod/i.test(userAgent)) return 'ios';\n  if (/Win32|Win64|Windows|WinCE/i.test(userAgent)) return 'windows';\n  if (/Android/i.test(userAgent)) return 'android';\n  if (/Linux/i.test(userAgent)) return 'linux';\n\n  return 'undetermined';\n};\n\n/**\n * @name useOperatingSystem\n * @description - Hook that returns the operating system of the current browser\n * @category User\n *\n * @returns {OperatingSystem} The operating system\n *\n * @example\n * const operatingSystem = useOperatingSystem();\n */\nexport const useOperatingSystem = () => {\n  const [osOperatingSystem] = useState<OperatingSystem>(getOperatingSystem());\n  return osOperatingSystem;\n};\n", "import { useMediaQuery } from '../useMediaQuery/useMediaQuery';\n\n/** The use preferred color scheme return type */\nexport type UsePreferredColorSchemeReturn = 'dark' | 'light' | 'no-preference';\n\n/**\n * @name usePreferredColorScheme\n * @description - Hook that returns user preferred color scheme\n * @category User\n *\n * @returns {UsePreferredColorSchemeReturn} String of preferred color scheme\n *\n * @example\n * const colorScheme = usePreferredColorScheme();\n */\nexport const usePreferredColorScheme = (): UsePreferredColorSchemeReturn => {\n  const isLight = useMediaQuery('(prefers-color-scheme: light)');\n  const isDark = useMediaQuery('(prefers-color-scheme: dark)');\n\n  if (isLight) return 'light';\n  if (isDark) return 'dark';\n  return 'no-preference';\n};\n", "import { useMediaQuery } from '../useMediaQuery/useMediaQuery';\n\n/** The use preferred contrast return type */\nexport type UsePreferredContrastReturn = 'custom' | 'less' | 'more' | 'no-preference';\n\n/**\n * @name usePreferredContrast\n * @description - Hook that returns the contrast preference\n * @category User\n *\n * @returns {UsePreferredContrastReturn} The contrast preference\n *\n * @example\n * const contrast = usePreferredContrast();\n */\nexport const usePreferredContrast = (): UsePreferredContrastReturn => {\n  const more = useMediaQuery('(prefers-contrast: more)');\n  const less = useMediaQuery('(prefers-contrast: less)');\n  const custom = useMediaQuery('(prefers-contrast: custom)');\n  return more ? 'more' : less ? 'less' : custom ? 'custom' : 'no-preference';\n};\n", "import { useMediaQuery } from '../useMediaQuery/useMediaQuery';\n\n/**\n * @name usePreferredDark\n * @description - Hook that returns if the user prefers dark mode\n * @category User\n *\n * @example\n * const isDark = usePreferredDark();\n */\nexport const usePreferredDark = () => useMediaQuery('(prefers-color-scheme: dark)');\n", "import { useSyncExternalStore } from 'react';\n\nconst getSnapshot = () => window.navigator.languages;\nconst getServerSnapshot = () => [] as const;\nconst subscribe = (callback: () => void) => {\n  window.addEventListener('languagechange', callback);\n  return () => {\n    window.removeEventListener('languagechange', callback);\n  };\n};\n\n/**\n * @name usePreferredLanguages\n * @description Hook that returns a browser preferred languages from navigator\n * @category User\n *\n * @browserapi navigator.languages https://developer.mozilla.org/en-US/docs/Web/API/Navigator/languages\n *\n * @returns {readonly string[]} An array of strings representing the user's preferred languages\n *\n * @example\n * const languages = usePreferredLanguages();\n */\nexport const usePreferredLanguages = () =>\n  useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n", "import { useMediaQuery } from '../useMediaQuery/useMediaQuery';\n\n/** The use preferred reduced motion return type */\nexport type UsePreferredReducedMotionReturn = 'no-preference' | 'reduce';\n\n/**\n * @name usePreferredReducedMotion\n * @description - Hook that returns the reduced motion preference\n * @category User\n *\n * @returns {UsePreferredReducedMotionReturn} The reduced motion preference\n *\n * @example\n * const reduced = usePreferredReducedMotion();\n */\nexport const usePreferredReducedMotion = (): UsePreferredReducedMotionReturn => {\n  const reduced = useMediaQuery('(prefers-reduced-motion: reduce)');\n  return reduced ? 'reduce' : 'no-preference';\n};\n", "import { useRef } from 'react';\n\n/**\n * @name useConst\n * @description - Hook that returns the constant value\n * @category Utilities\n *\n * @template Value The type of the value\n * @param {(() => Value) | Value} initialValue The initial value of the constant\n * @returns {Value} The constant value\n *\n * @example\n * const value = useConst('value');\n */\nexport const useConst = <Value>(initialValue: (() => Value) | Value) =>\n  useRef<Value>(typeof initialValue === 'function' ? (initialValue as () => Value)() : initialValue)\n    .current;\n", "import { useMemo, useRef } from 'react';\n\nexport type DebouncedCallback<Params extends unknown[]> = ((...args: Params) => void) & {\n  cancel: () => void;\n};\n\n/**\n * @name useDebounceCallback\n * @description - Hook that creates a debounced callback\n * @category Utilities\n *\n * @template Params The type of the params\n * @template Return The type of the return\n * @param {(...args: Params) => Return} callback The callback function\n * @param {number} delay The delay in milliseconds\n * @returns {(...args: Params) => Return} The callback with debounce\n *\n * @example\n * const debouncedCallback = useDebounceCallback(() => console.log('callback'), 500);\n */\nexport const useDebounceCallback = <Params extends unknown[], Return>(\n  callback: (...args: Params) => Return,\n  delay: number\n): DebouncedCallback<Params> => {\n  const internalCallbackRef = useRef(callback);\n  const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const delayRef = useRef(delay);\n\n  internalCallbackRef.current = callback;\n  delayRef.current = delay;\n\n  const debounced = useMemo(() => {\n    const cancel = () => {\n      if (!timerRef.current) return;\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    };\n\n    const debouncedCallback = function (this: any, ...args: Params) {\n      cancel();\n      timerRef.current = setTimeout(() => {\n        internalCallbackRef.current.apply(this, args);\n      }, delayRef.current);\n    };\n\n    debouncedCallback.cancel = cancel;\n\n    return debouncedCallback;\n  }, []);\n\n  return debounced;\n};\n", "import { useEffect, useRef, useState } from 'react';\n\nimport { useDebounceCallback } from '../useDebounceCallback/useDebounceCallback';\n\n/**\n * @name useDebounceValue\n * @description - Hook that creates a debounced value\n * @category Utilities\n *\n * @template Value The type of the value\n * @param {Value} value The value to be debounced\n * @param {number} delay The delay in milliseconds\n * @returns {Value} The debounced value\n *\n * @example\n * const debouncedValue = useDebounceValue(value, 500);\n */\nexport const useDebounceValue = <Value>(value: Value, delay: number) => {\n  const previousValueRef = useRef(value);\n  const [debouncedValue, setDebounceValue] = useState(value);\n\n  const debouncedSetState = useDebounceCallback(setDebounceValue, delay);\n\n  useEffect(() => {\n    if (previousValueRef.current === value) return;\n    debouncedSetState(value);\n    previousValueRef.current = value;\n  }, [value]);\n\n  return debouncedValue;\n};\n", "import { useState } from 'react';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\n\n/** The use last changed options type  */\nexport interface UseLastChangedOptions {\n  initialValue?: number;\n}\n\n/**\n * @name useLastChanged\n * @description - Hook for records the timestamp of the last change\n * @category Utilities\n *\n * @param {any} source  The source of the last change\n * @param {number | null} [options.initialValue=null] The initial value\n * @returns {number | null} Return timestamp of the last change\n *\n * @example\n * const lastChanged = useLastChanged(source);\n */\nexport const useLastChanged = (source: any, options?: UseLastChangedOptions): number | null => {\n  const [lastChanged, setLastChanged] = useState(options?.initialValue ?? null);\n\n  useDidUpdate(() => setLastChanged(Date.now()), [source]);\n\n  return lastChanged;\n};\n", "import type { RefObject } from 'react';\n\nimport { useMemo, useRef } from 'react';\n\nexport interface UseLatestReturn<Value> {\n  ref: RefObject<Value>;\n  value: Value;\n}\n\n/**\n * @name useLatest\n * @description - Hook that returns the stable reference of the value\n * @category Utilities\n *\n * @template Value The type of the value\n * @param {Value} value The value to get the previous value\n * @returns {UseLatestReturn<Value>} The previous value\n *\n * @example\n * const { value, ref } = useLatest(value);\n */\nexport const useLatest = <Value>(value: Value): UseLatestReturn<Value> => {\n  const valueRef = useRef<Value>(value);\n  valueRef.current = value;\n  return useMemo(\n    () => ({\n      get value() {\n        return valueRef.current;\n      },\n      ref: valueRef\n    }),\n    []\n  );\n};\n", "import { useRef } from 'react';\n\nexport interface UsePreviousOptions<Value> {\n  equality: (a: Value, b: Value) => boolean;\n}\n\n/**\n * @name usePrevious\n * @description - Hook that returns the previous value\n * @category Utilities\n *\n * @template Value The type of the value\n * @param {Value} value The value to get the previous value\n * @param {(a: Value, b: Value) => boolean} [options.equality] The custom equality function to determine if the value has changed\n * @returns {Value | undefined} The previous value\n *\n * @example\n * const prevValue = usePrevious(value);\n */\nexport const usePrevious = <Value>(value: Value, options?: UsePreviousOptions<Value>) => {\n  const currentRef = useRef<Value>(value);\n  const previousRef = useRef<Value>(undefined);\n\n  const equality = options?.equality ?? Object.is;\n\n  if (!equality(value, currentRef.current)) {\n    previousRef.current = currentRef.current;\n    currentRef.current = value;\n  }\n\n  return previousRef.current;\n};\n", "import { useMemo, useRef } from 'react';\n\nexport type ThrottledCallback<Params extends unknown[]> = ((...args: Params) => void) & {\n  cancel: () => void;\n};\n\n/**\n * @name useThrottleCallback\n * @description - Hook that creates a throttled callback\n * @category Utilities\n *\n * @template Params The type of the params\n * @template Return The type of the return\n * @param {(...args: Params) => Return} callback The callback function\n * @param {number} delay The delay in milliseconds\n * @returns {(...args: Params) => Return} The callback with throttle\n *\n * @example\n * const throttled = useThrottleCallback(() => console.log('callback'), 500);\n */\nexport const useThrottleCallback = <Params extends unknown[], Return>(\n  callback: (...args: Params) => Return,\n  delay: number\n): ThrottledCallback<Params> => {\n  const internalCallbackRef = useRef(callback);\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const isCalledRef = useRef(false);\n  const delayRef = useRef(delay);\n  const lastArgsRef = useRef<Params | null>(null);\n\n  internalCallbackRef.current = callback;\n  delayRef.current = delay;\n\n  const throttled = useMemo(() => {\n    const timer = () => {\n      isCalledRef.current = false;\n\n      if (!lastArgsRef.current) return;\n      internalCallbackRef.current.apply(this, lastArgsRef.current);\n      lastArgsRef.current = null;\n      setTimeout(timer, delayRef.current);\n    };\n\n    const cancel = () => {\n      if (!timeoutRef.current) return;\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n      isCalledRef.current = false;\n    };\n\n    const throttledCallback = function (this: any, ...args: Params) {\n      lastArgsRef.current = args;\n      if (isCalledRef.current) return;\n\n      internalCallbackRef.current.apply(this, args);\n      isCalledRef.current = true;\n      timeoutRef.current = setTimeout(timer, delayRef.current);\n    };\n\n    throttledCallback.cancel = cancel;\n\n    cancel();\n    return throttledCallback;\n  }, [delay]);\n\n  return throttled;\n};\n", "import { useEffect, useRef, useState } from 'react';\n\nimport { useThrottleCallback } from '../useThrottleCallback/useThrottleCallback';\n\n/**\n * @name useThrottleValue\n * @description - Hook that creates a throttled value\n * @category Utilities\n *\n * @template Value The type of the value\n * @param {Value} value The value to be throttled\n * @param {number} delay The delay in milliseconds\n * @returns {Value} The throttled value\n *\n * @example\n * const throttledValue = useThrottleValue(value, 500);\n */\nexport const useThrottleValue = <Value>(value: Value, delay: number) => {\n  const previousValueRef = useRef(value);\n  const [throttledValue, setThrottleValue] = useState(value);\n\n  const throttledSetState = useThrottleCallback(setThrottleValue, delay);\n\n  useEffect(() => {\n    if (previousValueRef.current === value) return;\n    throttledSetState(value);\n    previousValueRef.current = value;\n  }, [value]);\n\n  return throttledValue;\n};\n", "type DebouncedCallback<Params extends unknown[]> = ((...args: Params) => void) & {\n  cancel: () => void;\n};\n\nexport const debounce = <Params extends unknown[]>(\n  callback: (...args: Params) => void,\n  delay: number\n): DebouncedCallback<Params> => {\n  let timer: ReturnType<typeof setTimeout>;\n\n  const cancel = () => clearTimeout(timer);\n\n  const debounced = function (this: any, ...args: Params) {\n    cancel();\n    timer = setTimeout(() => callback.apply(this, args), delay);\n  };\n\n  debounced.cancel = cancel;\n\n  return debounced;\n};\n"],
  "mappings": "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",
  "names": ["createContext", "defaultValue", "options", "Context", "createReactContext", "useSelect", "selector", "context", "useContext", "children", "initialValue", "profile", "setProfile", "useState", "value", "useMemo", "jsx", "createEventEmitter", "listeners", "push", "event", "data", "listener", "unsubscribe", "eventKey", "eventListeners", "subscribe", "r", "setData", "useState", "listenerRef", "useRef", "useEffect", "useIsomorphicLayoutEffect", "useLayoutEffect", "useEffect", "useEvent", "callback", "internalCallbackRef", "useRef", "useCallback", "args", "fn", "createProvider", "originalProvider", "props", "valueRef", "useRef", "contextValue", "useMemo", "useIsomorphicLayoutEffect", "startTransition", "listener", "createElement", "createReactiveContextSelector", "Context", "selector", "options", "context", "useContext", "value", "setValue", "useState", "dispatch", "useEvent", "newValue", "prevValue", "newSelected", "createReactiveContext", "defaultValue", "createContext", "Provider", "useSelector", "state", "createStore", "createState", "state", "listeners", "setState", "action", "nextState", "prevState", "listener", "getState", "getInitialState", "subscribe", "selector", "useSyncExternalStore", "useAsync", "callback", "deps", "isLoading", "setIsLoading", "useState", "isError", "setIsError", "error", "setError", "data", "setData", "useEffect", "response", "useLockCallback", "callback", "lockRef", "useRef", "internalCallbackRef", "args", "useMutation", "callback", "options", "isLoading", "setIsLoading", "useState", "isError", "setIsError", "isSuccess", "setIsSuccess", "error", "setError", "data", "setData", "request", "body", "requestOptions", "attempt", "response", "retry", "retryDelay", "mutateOptions", "useDidUpdate", "effect", "deps", "mounted", "useRef", "useIsomorphicLayoutEffect", "useOptimistic", "externalState", "update", "state", "setState", "useState", "internalUpdateRef", "useRef", "promised", "setPromised", "useDidUpdate", "optimisticValue", "promise", "currentState", "useMount", "effect", "useEffect", "getRetry", "retry", "useQuery", "callback", "options", "enabled", "retryCountRef", "useRef", "getRetry", "alreadyRequested", "isFetching", "setIsFetching", "useState", "isLoading", "setIsLoading", "isError", "setIsError", "isRefetching", "setIsRefetching", "isSuccess", "setIsSuccess", "error", "setError", "data", "setData", "abortControllerRef", "intervalIdRef", "keys", "abort", "request", "action", "response", "retryDelay", "interval", "useMount", "useDidUpdate", "useEffect", "useAudio", "src", "options", "playing", "setPlaying", "useState", "volume", "setCurrentVolume", "playbackRate", "setPlaybackRate", "audioRef", "useRef", "useEffect", "audio", "onPlay", "onPause", "onEnded", "onTimeUpdate", "onVolumeChange", "onRateChange", "stop", "spriteName", "start", "end", "checkTime", "value", "newVolume", "newRate", "useBattery", "supported", "value", "setValue", "useState", "useEffect", "battery", "onChange", "batteryManager", "useBluetooth", "options", "supported", "acceptAllDevices", "filters", "optionalServices", "connected", "setIsConnected", "useState", "device", "setDevice", "server", "setServer", "requestDevice", "selectedDevice", "useEffect", "connectToBluetoothGATTServer", "gattServer", "reset", "useBroadcastChannel", "name", "callback", "supported", "closed", "setClosed", "useState", "data", "setData", "error", "setError", "channelRef", "useRef", "useEffect", "onMessage", "event", "onMessageError", "onClose", "post", "close", "legacyCopyToClipboard", "value", "tempTextArea", "copy", "useClipboard", "params", "value", "setValue", "useState", "enabled", "set", "useEffect", "copy", "useCopy", "delay", "value", "setValue", "useState", "copied", "setCopied", "text", "copy", "createRefState", "initialValue", "setState", "temp", "ref", "value", "useRefState", "state", "useState", "targetSymbol", "target", "getElement", "isTarget", "target", "targetSymbol", "useCssVar", "params", "target", "isTarget", "key", "initialValue", "value", "setValue", "useState", "internalRef", "useRefState", "elementRef", "useRef", "set", "element", "remove", "useEffect", "getElement", "onChange", "observer", "useDisplayMedia", "params", "supported", "target", "isTarget", "options", "immediately", "sharing", "setSharing", "useState", "elementRef", "useRef", "streamRef", "internalRef", "useRefState", "stop", "track", "start", "displayMedia", "useEffect", "element", "getElement", "useDocumentTitle", "initialValue", "options", "prevValueRef", "useRef", "value", "setValue", "useState", "set", "updatedValue", "useEffect", "observer", "prevValue", "useEventSource", "url", "events", "options", "isConnecting", "setIsConnecting", "useState", "isOpen", "setIsOpen", "isError", "setIsError", "retryCountRef", "useRef", "getRetry", "error", "setError", "data", "setData", "eventSourceRef", "immediately", "close", "open", "eventSource", "event", "retryDelay", "eventName", "useEffect", "useEyeDropper", "initialValue", "supported", "value", "setValue", "useState", "colorSelectionOptions", "result", "useFavicon", "initialHref", "href", "setHref", "useState", "injectFavicon", "favicon", "link", "set", "useMount", "useDidUpdate", "useFps", "fps", "setFps", "useState", "useEffect", "frameCount", "startTime", "rafId", "onRequestAnimationFrame", "currentTime", "elapsedTime", "calculatedFps", "useFullscreen", "params", "target", "isTarget", "options", "value", "setValue", "useState", "internalRef", "useRefState", "onChange", "screenfull", "enter", "element", "getElement", "error", "exit", "toggle", "useEffect", "useRaf", "callback", "options", "rafIdRef", "useRef", "previousFrameTimestampRef", "active", "setActive", "useState", "enabled", "internalCallbackRef", "loop", "timestamp", "delta", "resume", "pause", "useEffect", "useGamepad", "supported", "gamepads", "setGamepads", "useState", "createGamepad", "gamepad", "hapticActuators", "vibrationActuator", "updateGamepadState", "s", "active", "useRaf", "useEffect", "acc", "onConnected", "event", "onDisconnected", "updatedGamepads", "mapGamepadToXbox360Controller", "useGeolocation", "params", "value", "setValue", "useState", "useEffect", "onEvent", "coords", "timestamp", "onEventError", "error", "watchId", "timeRangeToArray", "timeRanges", "ranges", "i", "useMediaControls", "params", "target", "isTarget", "options", "internalRef", "useRefState", "elementRef", "useRef", "playing", "setPlaying", "useState", "duration", "setDuration", "currentTime", "setCurrentTime", "seeking", "setSeeking", "waiting", "setWaiting", "buffered", "setBuffered", "stalled", "setStalled", "ended", "setEnded", "playbackRate", "setPlaybackRateState", "muted", "setMutedState", "volume", "setVolumeState", "useEffect", "element", "getElement", "onPlaying", "onPause", "onWaiting", "onStalled", "onSeeking", "onSeeked", "onEnded", "onDurationChange", "onTimeUpdate", "onVolumechange", "onRatechange", "onProgress", "play", "pause", "time", "value", "useMemory", "supported", "value", "setValue", "useState", "useEffect", "intervalId", "getConnection", "useNetwork", "value", "setValue", "useState", "online", "connection", "useEffect", "callback", "getSnapshot", "getServerSnapshot", "subscribe", "callback", "useOnline", "useSyncExternalStore", "useOtpCredential", "params", "onSuccess", "onError", "supported", "aborted", "setAborted", "useState", "abortControllerRef", "useRef", "credential", "error", "usePermission", "permissionDescriptorName", "options", "supported", "state", "setState", "useState", "enabled", "permissionDescriptor", "query", "useEvent", "permissionStatus", "useEffect", "usePictureInPicture", "params", "target", "isTarget", "options", "open", "setOpen", "useState", "internalRef", "useRefState", "elementRef", "useRef", "onOptionsRef", "supported", "enter", "exit", "useEffect", "element", "getElement", "onEnterPictureInPicture", "onLeavePictureInPicture", "value", "usePointerLock", "supported", "element", "setElement", "useState", "useEffect", "handlePointerLockChange", "currentElement", "handlePointerLockError", "action", "event", "usePostMessage", "origin", "callback", "internalCallbackRef", "useRef", "useEffect", "onMessage", "event", "message", "useShare", "params", "supported", "shareParams", "data", "getSpeechRecognition", "useSpeechRecognition", "options", "supported", "continuous", "interimResults", "language", "grammars", "maxAlternatives", "onStart", "onEnd", "onError", "onResult", "listening", "setListening", "useState", "transcript", "setTranscript", "final", "setFinal", "error", "setError", "recognition", "SpeechRecognition", "speechRecognition", "event", "currentResult", "useEffect", "start", "stop", "value", "useSpeechSynthesis", "options", "supported", "text", "lang", "pitch", "rate", "voice", "volume", "playing", "setPlaying", "useState", "status", "setStatus", "error", "setError", "speechSynthesisUtteranceRef", "useRef", "bindSpeechSynthesisUtterance", "speechSynthesisUtterance", "event", "useEffect", "speak", "stop", "toggle", "value", "resume", "pause", "useVibrate", "pattern", "interval", "supported", "intervalIdRef", "useRef", "active", "setActive", "useState", "trigger", "internalPattern", "stop", "pause", "resume", "intervalInterval", "useEffect", "useWakeLock", "options", "supported", "active", "setActive", "useState", "sentinel", "useRef", "immediately", "type", "request", "release", "useEffect", "onVisibilityChange", "useWebSocket", "url", "options", "webSocketRef", "useRef", "retryCountRef", "getRetry", "explicityCloseRef", "status", "setStatus", "useState", "send", "data", "close", "init", "useEvent", "webSocket", "event", "useEffect", "open", "useLogger", "name", "params", "useEffect", "useDidUpdate", "useRenderCount", "renderCountRef", "useRef", "useEffect", "useRenderInfo", "name", "log", "renderInfoRef", "useRef", "now", "useRerender", "useReducer", "useActiveElement", "params", "target", "isTarget", "value", "setValue", "useState", "internalRef", "useRefState", "useEffect", "element", "getElement", "observer", "mutations", "mutation", "node", "prevActiveElement", "onActiveElementChange", "useAutoScroll", "params", "target", "isTarget", "options", "enabled", "internalRef", "useRefState", "internalOptionsRef", "useRef", "useEffect", "element", "getElement", "shouldAutoScroll", "touchStartY", "lastScrollTop", "onCheckScrollPosition", "scrollHeight", "clientHeight", "scrollTop", "maxScrollHeight", "scrollThreshold", "onWheel", "event", "onTouchStart", "onTouchMove", "touchEndY", "onMutation", "observer", "useClickOutside", "params", "target", "isTarget", "callback", "internalRef", "useRefState", "internalCallbackRef", "useRef", "useEffect", "onClick", "event", "element", "getElement", "DEFAULT_THRESHOLD_TIME", "useDoubleClick", "params", "target", "isTarget", "callback", "options", "timeoutIdRef", "useRef", "clickCountRef", "internalRef", "useRefState", "internalCallbackRef", "internalOptionsRef", "useEffect", "element", "getElement", "onClick", "event", "useDropZone", "params", "target", "isTarget", "options", "internalRef", "useRefState", "counterRef", "useRef", "files", "setFiles", "useState", "overed", "setOvered", "dataTypes", "getFiles", "event", "list", "checkDataTypes", "types", "type", "dataType", "checkValidity", "items", "item", "dataTypesValid", "multipleFilesValid", "useEffect", "element", "getElement", "onEvent", "currentFiles", "onDrop", "onDragOver", "onDragEnter", "onDragLeave", "DEFAULT_OPTIONS", "useFileDialog", "params", "callback", "options", "value", "setValue", "useState", "inputRef", "useRef", "internalCallbackRef", "reset", "open", "openParams", "capture", "useEffect", "init", "input", "event", "files", "useFocus", "params", "target", "isTarget", "options", "initialValue", "focused", "setFocused", "useState", "internalRef", "useRefState", "internalOptionsRef", "useRef", "elementRef", "focus", "blur", "useEffect", "element", "getElement", "onFocus", "event", "a", "onBlur", "useHover", "params", "target", "isTarget", "options", "hovering", "setHovering", "useState", "internalRef", "useRefState", "internalOptionsRef", "useRef", "useEffect", "element", "getElement", "onMouseEnter", "event", "onMouseLeave", "loadImage", "src", "options", "resolve", "reject", "img", "srcset", "sizes", "className", "loading", "crossorigin", "referrerPolicy", "useImage", "useQueryOptions", "useQuery", "DEFAULT_THRESHOLD_TIME", "useLongPress", "params", "target", "isTarget", "callback", "options", "pressed", "setPressed", "useState", "timeoutIdRef", "useRef", "isPressedRef", "internalRef", "useRefState", "internalCallbackRef", "internalOptionsRef", "useEffect", "element", "getElement", "onStart", "event", "onCancel", "prevPressed", "DEFAULT_BRUSH_RADIUS", "Pointer", "x", "y", "point", "diff", "angle", "distance", "angleRotated", "Paint", "radius", "smooth", "usePaint", "params", "target", "isTarget", "options", "color", "opacity", "paintRef", "useRef", "drawing", "setIsDrawing", "useState", "internalRef", "useRefState", "contextRef", "draw", "points", "p1", "p2", "i", "midPoint", "clearCanvas", "onMouseMove", "useEvent", "event", "onMouseDown", "onMouseUp", "clear", "undo", "useEffect", "element", "getElement", "SCRIPT_STATUS_ATTRIBUTE_NAME", "useScript", "src", "options", "status", "setStatus", "useState", "script", "scriptStatus", "removeOnUnmount", "async", "useEffect", "existedScript", "key", "value", "onLoad", "onError", "useSticky", "params", "target", "isTarget", "options", "axis", "internalRef", "useRefState", "stuck", "setStuck", "useState", "useEffect", "element", "getElement", "root", "elementOffsetTop", "elementOffsetLeft", "onSticky", "scrollTop", "scrollLeft", "useTextDirection", "params", "target", "isTarget", "initialValue", "internalRef", "useRefState", "elementRef", "useRef", "getDirection", "getElement", "value", "setValue", "useState", "remove", "set", "useEffect", "element", "direction", "observer", "useFul", "value", "useEffect", "useLess", "value", "useEffect", "useOnce", "effect", "cleanupRef", "useRef", "hasRunRef", "hasRenderedAfterRun", "useEffect", "useIsFirstRender", "renderRef", "useRef", "deepEqual", "a", "b", "value", "index", "keysA", "keysB", "key", "useShallowEffect", "effect", "deps", "depsRef", "useRef", "useEffect", "useUnmount", "callback", "internalCallbackRef", "useRef", "useEffect", "match", "query", "useBreakpoints", "breakpoints", "strategy", "rerender", "useRerender", "getValue", "breakpoint", "delta", "useEffect", "onResize", "greaterOrEqual", "smallerOrEqual", "current", "value", "active", "greater", "smaller", "between", "a", "b", "breakpointsKeys", "acc", "BREAKPOINTS_MATERIAL_UI", "BREAKPOINTS_MANTINE", "BREAKPOINTS_TAILWIND", "BREAKPOINTS_BOOTSTRAP_V5", "BREAKPOINTS_ANT_DESIGN", "BREAKPOINTS_QUASAR_V2", "BREAKPOINTS_SEMANTIC", "BREAKPOINTS_MASTER_CSS", "BREAKPOINTS_PRIME_FLEX", "throttle", "callback", "delay", "isCalled", "lastArgs", "timer", "args", "useDeviceMotion", "params", "enabled", "delay", "value", "setValue", "useState", "internalCallbackRef", "useRef", "useEffect", "onDeviceMotion", "throttle", "event", "useDeviceOrientation", "supported", "value", "setValue", "useState", "useEffect", "onDeviceOrientation", "event", "useDevicePixelRatio", "supported", "ratio", "setRatio", "useState", "useEffect", "onChange", "media", "useEventListener", "params", "target", "isTarget", "event", "listener", "options", "internalRef", "useRefState", "internalListener", "useEvent", "useEffect", "element", "getElement", "callback", "useDocumentEvent", "event", "listener", "options", "useEventListener", "target", "getSnapshot", "getServerSnapshot", "subscribe", "callback", "useDocumentVisibility", "useSyncExternalStore", "useElementSize", "params", "target", "size", "setSize", "useState", "internalRef", "useRefState", "useIsomorphicLayoutEffect", "element", "getElement", "width", "height", "observer", "isHotkeyMatch", "hotkey", "keys", "key", "updatedKey", "useHotkeys", "params", "target", "isTarget", "hotkeys", "callback", "options", "internalRef", "useRefState", "keysRef", "useRef", "enabled", "onKeyDown", "useEvent", "event", "code", "alias", "updatedKeys", "h", "onKeyUp", "useEffect", "element", "getElement", "IDLE_EVENTS", "ONE_MINUTE", "useIdle", "milliseconds", "initialValue", "events", "idle", "setIdle", "useState", "lastActive", "setLastActive", "useEffect", "timeoutId", "onTimeout", "onEvent", "throttle", "onVisibilitychange", "event", "useInfiniteScroll", "params", "target", "isTarget", "callback", "options", "direction", "distance", "loading", "setIsLoading", "useState", "internalRef", "useRefState", "internalCallbackRef", "useRef", "internalLoadingRef", "useEffect", "element", "getElement", "onLoadMore", "event", "clientHeight", "scrollHeight", "scrollTop", "clientWidth", "scrollWidth", "scrollLeft", "scrollBottom", "scrollRight", "useIntersectionObserver", "params", "target", "isTarget", "options", "callback", "enabled", "entry", "setEntry", "useState", "internalRef", "useRefState", "internalCallbackRef", "useRef", "useEffect", "element", "getElement", "observer", "useKeyboard", "params", "target", "isTarget", "options", "internalRef", "useRefState", "internalOptionsRef", "useRef", "useEffect", "element", "getElement", "onKeyDown", "event", "onKeyUp", "useKeyPress", "params", "target", "isTarget", "key", "callback", "pressed", "setPressed", "useState", "internalRef", "useRefState", "keyRef", "useRef", "internalCallbackRef", "useEffect", "element", "getElement", "onKeyDown", "event", "keyboardEvent", "onKeyUp", "useKeyPressEvent", "params", "target", "isTarget", "key", "listener", "options", "internalRef", "useRefState", "keyRef", "useRef", "listenerRef", "useEffect", "element", "getElement", "onKeyDown", "event", "keyboardEvent", "useKeysPressed", "params", "target", "isTarget", "enabled", "value", "setValue", "useState", "internalRef", "useRefState", "useEffect", "element", "getElement", "onKeyDown", "event", "keyboardEvent", "prevValue", "code", "onKeyUp", "useLockScroll", "params", "target", "isTarget", "enabled", "locked", "setLocked", "useState", "internalRef", "useRefState", "elementRef", "useRef", "useIsomorphicLayoutEffect", "element", "getElement", "originalStyle", "lock", "unlock", "toggle", "useMeasure", "params", "target", "isTarget", "internalRef", "useRefState", "rect", "setRect", "useState", "useEffect", "element", "getElement", "resizeObserver", "entries", "entry", "x", "y", "width", "height", "top", "left", "bottom", "right", "getServerSnapshot", "useMediaQuery", "query", "subscribe", "useCallback", "callback", "matchMedia", "useSyncExternalStore", "useMouse", "params", "target", "isTarget", "value", "setValue", "useState", "internalRef", "useRefState", "useEffect", "onMouseMove", "event", "element", "getElement", "updatedValue", "left", "top", "elementPositionX", "elementPositionY", "elementX", "elementY", "prevValue", "onScroll", "useMutationObserver", "params", "target", "isTarget", "callback", "options", "observer", "setObserver", "useState", "enabled", "internalRef", "useRefState", "internalCallbackRef", "useRef", "internalOptionsRef", "useEffect", "element", "getElement", "stop", "useOrientation", "supported", "orientation", "value", "setValue", "useState", "useEffect", "onOrientationChange", "type", "n", "usePageLeave", "callback", "isLeft", "setIsLeft", "useState", "onMouse", "useEvent", "useEffect", "useParallax", "params", "target", "isTarget", "options", "internalRef", "useRefState", "screenOrientation", "useOrientation", "deviceOrientation", "useDeviceOrientation", "deviceOrientationRollAdjust", "value", "deviceOrientationTiltAdjust", "mouseRollAdjust", "mouseTiltAdjust", "setValue", "useState", "useEffect", "element", "getElement", "onMouseMove", "event", "left", "top", "elementPositionX", "elementPositionY", "getSource", "getRoll", "y", "height", "getTilt", "x", "width", "source", "roll", "tilt", "usePerformanceObserver", "options", "callback", "supported", "entries", "setEntries", "useState", "observerRef", "useRef", "internalCallback", "start", "observer", "entryList", "stop", "useEffect", "useResizeObserver", "params", "target", "isTarget", "options", "enabled", "entries", "setEntries", "useState", "internalRef", "useRefState", "internalOnChangeRef", "useRef", "useEffect", "element", "getElement", "observer", "ARRIVED_STATE_THRESHOLD_PIXELS", "useScroll", "params", "target", "isTarget", "options", "internalRef", "useRefState", "internalOptionsRef", "useRef", "scrolling", "setScrolling", "useState", "scrollPositionRef", "useEffect", "element", "getElement", "onScrollEnd", "event", "onScroll", "display", "flexDirection", "direction", "directionMultiplier", "scrollLeft", "scrollTop", "offset", "left", "right", "top", "bottom", "isColumnReverse", "isRowReverse", "useScrollIntoView", "params", "target", "isTarget", "options", "internalRef", "useRefState", "behavior", "block", "inline", "enabled", "useEffect", "element", "getElement", "trigger", "useScrollTo", "params", "target", "isTarget", "options", "x", "y", "behavior", "enabled", "internalRef", "useRefState", "useLayoutEffect", "element", "getElement", "trigger", "getRangesSelection", "selection", "rangeCount", "_", "i", "useTextSelection", "rerender", "useRerender", "setSelection", "useState", "useEffect", "onSelectionChange", "text", "ranges", "rects", "range", "useWindowEvent", "event", "listener", "options", "useEventListener", "target", "useWindowFocus", "focused", "setFocused", "useState", "useEffect", "onFocus", "onBlur", "scrollTo", "x", "y", "behavior", "scrollOptions", "useWindowScroll", "value", "setValue", "useState", "useEffect", "onChange", "useWindowSize", "params", "includeScrollbar", "size", "setSize", "useState", "useEffect", "onResize", "useBoolean", "initialValue", "value", "setValue", "useState", "prevValue", "getCookies", "cookie", "key", "value", "decodedValue", "removeCookie", "options", "setCookie", "o", "COOKIE_EVENT", "dispatchCookieEvent", "setCookieItem", "removeCookieItem", "getCookie", "useCookie", "params", "initialValue", "serializer", "deserializer", "setValue", "useState", "cookieValue", "useEffect", "onChange", "clearCookies", "cookie", "name", "removeCookie", "clearCookieItems", "dispatchCookieEvent", "useCookies", "options", "serializer", "value", "deserializer", "getParsedCookies", "key", "decodedValue", "entry", "setValue", "useState", "useEffect", "onChange", "COOKIE_EVENT", "setCookieItem", "removeCookieItem", "useCounter", "params", "initialValue", "max", "min", "value", "setValue", "useState", "prevValue", "useDefault", "initialValue", "defaultValue", "value", "setValue", "useState", "useDisclosure", "initialValue", "options", "opened", "setOpened", "useState", "open", "close", "useField", "params", "initialValue", "inputRef", "useRef", "watchingRef", "rerender", "useRerender", "dirty", "setDirty", "useState", "touched", "setTouched", "error", "setError", "getValue", "setValue", "value", "reset", "focus", "validate", "registerParams", "node", "getHash", "useHash", "initialValue", "mode", "hash", "setHash", "useState", "set", "value", "useEffect", "onHashChange", "useList", "initialList", "list", "setList", "useState", "item", "prevList", "removeAtIndex", "insertAtIndex", "l", "updateAtIndex", "element", "index", "STORAGE_EVENT", "dispatchStorageEvent", "params", "setStorageItem", "storage", "key", "value", "oldValue", "removeStorageItem", "getStorageItem", "useStorage", "options", "initialValue", "serializer", "set", "remove", "deserializer", "setValue", "useState", "storageValue", "useEffect", "onChange", "useLocalStorage", "key", "initialValue", "options", "useStorage", "useMap", "values", "map", "setMap", "useState", "set", "key", "value", "prevMap", "remove", "newMap", "clear", "reset", "has", "useOffsetPagination", "total", "pageSize", "initialPage", "onPageChange", "onPageCountChange", "onPageSizeChange", "page", "setPage", "useState", "onPageChangeRef", "useRef", "onPageCountChangeRef", "onPageSizeChangeRef", "pageCount", "isFirstPage", "isLastPage", "next", "prevPage", "prev", "set", "useEffect", "useQueue", "initialValue", "queue", "setQueue", "useState", "element", "removed", "flushSync", "first", "rest", "useRafState", "initialValue", "rafIdRef", "useRef", "value", "setValue", "useState", "set", "useUnmount", "useSessionStorage", "key", "initialValue", "options", "useStorage", "useSet", "values", "set", "setSet", "useState", "add", "value", "prevSet", "remove", "newSet", "clear", "reset", "toggle", "union", "other", "difference", "symmetricDifference", "intersection", "has", "stateHistoryReducer", "state", "action", "value", "capacity", "newHistory", "newUndoStack", "steps", "initialValue", "useStateHistory", "dispatch", "useReducer", "canUndo", "canRedo", "set", "undo", "redo", "back", "forward", "reset", "FIRST_STEP_VALUE", "useStep", "params", "max", "initial", "initialStep", "useRef", "currentStep", "setCurrentStep", "useState", "isFirst", "isLast", "prevStep", "value", "useToggle", "values", "option", "toggle", "useReducer", "state", "action", "value", "index", "URL_SEARCH_PARAMS_EVENT", "getUrlSearchParams", "mode", "search", "hash", "path", "index", "createQueryString", "searchParams", "searchParamsString", "base", "dispatchUrlSearchParamsEvent", "useUrlSearchParam", "key", "params", "options", "initialValue", "writeMode", "serializer", "value", "deserializer", "setUrlSearchParam", "write", "serializedValue", "query", "setValue", "useState", "currentValue", "set", "remove", "useEffect", "onParamsChange", "newValue", "useUrlSearchParams", "params", "options", "initialValue", "mode", "writeMode", "serializer", "value", "deserializer", "setUrlSearchParams", "write", "urlSearchParams", "key", "param", "query", "createQueryString", "getParsedUrlSearchParams", "searchParams", "acc", "setValue", "useState", "getUrlSearchParams", "set", "dispatchUrlSearchParamsEvent", "useEffect", "onParamsChange", "URL_SEARCH_PARAMS_EVENT", "useWizard", "map", "initialStepId", "initialId", "wizardMap", "wizardItem", "currentStepId", "setCurrentStepId", "useState", "history", "setHistory", "id", "previousStepId", "useInterval", "params", "callback", "interval", "immediately", "active", "setActive", "useState", "intervalIdRef", "useRef", "internalCallbackRef", "useEffect", "getStopwatchTime", "time", "days", "hours", "minutes", "seconds", "useStopwatch", "params", "initialTime", "immediately", "setTime", "useState", "paused", "setPaused", "useEffect", "onInterval", "prevTime", "updatedCount", "interval", "prevPause", "getDate", "now", "seconds", "minutes", "hours", "meridiemHours", "meridiemType", "day", "month", "year", "timestamp", "useTime", "time", "setTime", "useState", "getDate", "useEffect", "timerId", "useTimeout", "callback", "delay", "ready", "setReady", "useState", "timeoutIdRef", "useRef", "internalCallback", "useEvent", "useEffect", "getTimeFromSeconds", "timestamp", "roundedTimestamp", "days", "hours", "minutes", "useTimer", "params", "initialSeconds", "options", "active", "setActive", "useState", "seconds", "setSeconds", "intervalIdRef", "useRef", "optionsRef", "useDidUpdate", "useEffect", "onInterval", "prevSeconds", "updatedSeconds", "pause", "resume", "toggle", "restart", "immediately", "start", "clear", "increase", "decrease", "getSnapshot", "getServerSnapshot", "subscribe", "callback", "useBrowserLanguage", "useSyncExternalStore", "getOperatingSystem", "userAgent", "useOperatingSystem", "osOperatingSystem", "useState", "usePreferredColorScheme", "isLight", "useMediaQuery", "isDark", "usePreferredContrast", "more", "useMediaQuery", "less", "custom", "usePreferredDark", "useMediaQuery", "getSnapshot", "getServerSnapshot", "subscribe", "callback", "usePreferredLanguages", "useSyncExternalStore", "usePreferredReducedMotion", "useMediaQuery", "useConst", "initialValue", "useRef", "useDebounceCallback", "callback", "delay", "internalCallbackRef", "useRef", "timerRef", "delayRef", "useMemo", "cancel", "debouncedCallback", "args", "useDebounceValue", "value", "delay", "previousValueRef", "useRef", "debouncedValue", "setDebounceValue", "useState", "debouncedSetState", "useDebounceCallback", "useEffect", "useLastChanged", "source", "options", "lastChanged", "setLastChanged", "useState", "useDidUpdate", "useLatest", "value", "valueRef", "useRef", "useMemo", "usePrevious", "value", "options", "currentRef", "useRef", "previousRef", "useThrottleCallback", "callback", "delay", "internalCallbackRef", "useRef", "timeoutRef", "isCalledRef", "delayRef", "lastArgsRef", "useMemo", "timer", "cancel", "throttledCallback", "args", "useThrottleValue", "value", "delay", "previousValueRef", "useRef", "throttledValue", "setThrottleValue", "useState", "throttledSetState", "useThrottleCallback", "useEffect", "debounce", "callback", "delay", "timer", "cancel", "debounced", "args"]
}
