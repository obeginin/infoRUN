import { useRef as s, useState as d } from "react";
import { useRerender as L } from "../useRerender/useRerender.mjs";
const B = (n) => {
  const c = n?.initialValue ?? "", t = s(null), i = s(!1), l = L(), [v, o] = d(!1), [y, h] = d(n?.initialTouched ?? !1), [x, r] = d(void 0), a = () => t.current?.type === "radio" || t.current?.type === "checkbox" ? t.current.checked : t.current?.value ?? c, g = (e) => {
    if (t.current?.type === "radio" || t.current?.type === "checkbox")
      return t.current.checked = e, i.current ? l() : void 0;
    if (t.current.value = e, i.current) return l();
  }, k = () => {
    g(c), o(!1), h(!1), r(void 0);
  }, V = () => t.current.focus(), f = (e) => {
    if (e.required && !t.current.value)
      return r(e.required);
    if (e.minLength && t.current.value.length < e.minLength.value)
      return r(e.minLength.message);
    if (e.maxLength && t.current.value.length > e.maxLength.value)
      return r(e.maxLength.message);
    if (e.min && Number(t.current.value) < e.min.value)
      return r(e.min.message);
    if (e.max && Number(t.current.value) > e.max.value)
      return r(e.max.message);
    if (e.pattern && !e.pattern.value.test(t.current.value))
      return r(e.pattern.message);
    if (e.validate) {
      const u = e.validate(t.current.value);
      if (typeof u == "string") return r(u);
    }
    r(void 0);
  };
  return {
    register: (e) => ({
      ref: (u) => {
        if (!t.current && u) {
          if (n?.autoFocus && u.focus(), t.current = u, t.current.type === "radio") {
            t.current.defaultChecked = n?.initialValue === u.value;
            return;
          }
          if (t.current.type === "checkbox") {
            t.current.defaultChecked = !!n?.initialValue;
            return;
          }
          t.current.defaultValue = String(c), e && n?.validateOnMount && f(e);
        }
      },
      onChange: async () => {
        if (i.current) return l();
        t.current.value !== c && o(!0), v && t.current.value === c && o(!1), e && n?.validateOnChange && await f(e), e && n?.validateOnBlur && r(void 0);
      },
      onBlur: async () => {
        e && n?.validateOnBlur && await f(e), h(!0);
      }
    }),
    dirty: v,
    touched: y,
    error: x,
    setError: r,
    clearError: () => r(void 0),
    getValue: a,
    setValue: g,
    reset: k,
    watch: () => (i.current = !0, a()),
    focus: V
  };
};
export {
  B as useField
};
//# sourceMappingURL=useField.mjs.map
