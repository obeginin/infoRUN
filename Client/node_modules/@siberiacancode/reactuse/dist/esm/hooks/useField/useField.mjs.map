{"version":3,"file":"useField.mjs","sources":["../../../../src/hooks/useField/useField.ts"],"sourcesContent":["import { useRef, useState } from 'react';\n\nimport { useRerender } from '../useRerender/useRerender';\n\n/** The use field params type */\nexport interface UseFieldParams<Value> {\n  /** The auto focus */\n  autoFocus?: boolean;\n  /** The initial touched */\n  initialTouched?: boolean;\n  /** The initial value */\n  initialValue?: Value;\n  /** The validate on blur */\n  validateOnBlur?: boolean;\n  /** The validate on mount */\n  validateOnChange?: boolean;\n  /** The validate on mount */\n  validateOnMount?: boolean;\n}\n\n/** The use field register params type */\nexport interface UseFieldRegisterParams {\n  /** The required validation */\n  required?: string;\n  /** The custom validation */\n  validate?: (value: string) => Promise<string | true>;\n  /** The min value validation */\n  max?: {\n    value: number;\n    message: string;\n  };\n  /** The max length validation */\n  maxLength?: {\n    value: number;\n    message: string;\n  };\n  /** The max value validation */\n  min?: {\n    value: number;\n    message: string;\n  };\n  /** The min length validation */\n  minLength?: {\n    value: number;\n    message: string;\n  };\n  /** The pattern validation */\n  pattern?: {\n    value: RegExp;\n    message: string;\n  };\n}\n\n/** The use field return type */\nexport interface UseFieldReturn<Value> {\n  /** The dirty state */\n  dirty: boolean;\n  /** The error state */\n  error?: string;\n  /** The set error function */\n  touched: boolean;\n  /** The set error function */\n  clearError: () => void;\n  /** The focus function */\n  focus: () => void;\n  /** The get value function */\n  getValue: () => Value;\n  /** The register function */\n  register: (params?: UseFieldRegisterParams) => {\n    onBlur: () => void;\n    onChange: () => void;\n    ref: (\n      node: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | null | undefined\n    ) => void;\n  };\n  /** The reset function */\n  reset: () => void;\n  /** The set error function */\n  setError: (error: string) => void;\n  /** The  set value function */\n  setValue: (value: Value) => void;\n  /** The watch function */\n  watch: () => Value;\n}\n\n/**\n * @name useField\n * @description - Hook to manage a form field\n * @category State\n *\n * @template Value The input value\n * @template Type The input value type\n * @param {Value} [params.initialValue] Initial value\n * @param {boolean} [params.initialTouched=false] Initial touched state\n * @param {boolean} [params.autoFocus=false] Auto focus\n * @param {boolean} [params.validateOnChange=false] Validate on change\n * @param {boolean} [params.validateOnBlur=false] Validate on blur\n * @param {boolean} [params.validateOnMount=false] Validate on mount\n * @returns {UseFieldReturn<Value>} An object containing input information\n *\n * @example\n * const { register, getValue, setValue, reset, dirty, error, setError, clearError, touched, focus, watch } = useField();\n */\nexport const useField = <\n  Value extends boolean | number | string = string,\n  Type = Value extends string ? string : Value extends boolean ? boolean : number\n>(\n  params?: UseFieldParams<Value>\n): UseFieldReturn<Type> => {\n  const initialValue = (params?.initialValue ?? '') as Value;\n\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const watchingRef = useRef(false);\n  const rerender = useRerender();\n\n  const [dirty, setDirty] = useState(false);\n  const [touched, setTouched] = useState(params?.initialTouched ?? false);\n  const [error, setError] = useState<string | undefined>(undefined);\n\n  const getValue = () => {\n    if (inputRef.current?.type === 'radio' || inputRef.current?.type === 'checkbox')\n      return inputRef.current.checked as Type;\n    return (inputRef.current?.value ?? initialValue) as Type;\n  };\n\n  const setValue = (value: Type) => {\n    if (inputRef.current?.type === 'radio' || inputRef.current?.type === 'checkbox') {\n      inputRef.current.checked = value as boolean;\n      if (watchingRef.current) return rerender();\n      return;\n    }\n\n    inputRef.current!.value = value as string;\n    if (watchingRef.current) return rerender();\n  };\n\n  const reset = () => {\n    setValue(initialValue as unknown as Type);\n    setDirty(false);\n    setTouched(false);\n    setError(undefined);\n  };\n\n  const focus = () => inputRef.current!.focus();\n\n  const validate = (params: UseFieldRegisterParams) => {\n    if (params.required && !inputRef.current!.value) {\n      return setError(params.required);\n    }\n\n    if (params.minLength && inputRef.current!.value.length < params.minLength.value) {\n      return setError(params.minLength.message);\n    }\n\n    if (params.maxLength && inputRef.current!.value.length > params.maxLength.value) {\n      return setError(params.maxLength.message);\n    }\n\n    if (params.min && Number(inputRef.current!.value) < params.min.value) {\n      return setError(params.min.message);\n    }\n\n    if (params.max && Number(inputRef.current!.value) > params.max.value) {\n      return setError(params.max.message);\n    }\n\n    if (params.pattern && !params.pattern.value.test(inputRef.current!.value)) {\n      return setError(params.pattern.message);\n    }\n\n    if (params.validate) {\n      const error = params.validate(inputRef.current!.value);\n      if (typeof error === 'string') return setError(error);\n    }\n\n    setError(undefined);\n  };\n\n  const register = (registerParams?: UseFieldRegisterParams) => ({\n    ref: (node: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | null | undefined) => {\n      if (!inputRef.current && node) {\n        if (params?.autoFocus) node.focus();\n        inputRef.current = node as HTMLInputElement;\n        if (inputRef.current.type === 'radio') {\n          inputRef.current.defaultChecked = params?.initialValue === node.value;\n          return;\n        }\n        if (inputRef.current.type === 'checkbox') {\n          inputRef.current.defaultChecked = !!params?.initialValue;\n          return;\n        }\n        inputRef.current.defaultValue = String(initialValue);\n\n        if (registerParams && params?.validateOnMount) validate(registerParams);\n      }\n    },\n    onChange: async () => {\n      if (watchingRef.current) return rerender();\n      if (inputRef.current!.value !== initialValue) setDirty(true);\n      if (dirty && inputRef.current!.value === initialValue) setDirty(false);\n      if (registerParams && params?.validateOnChange) await validate(registerParams);\n      if (registerParams && params?.validateOnBlur) setError(undefined);\n    },\n    onBlur: async () => {\n      if (registerParams && params?.validateOnBlur) await validate(registerParams);\n      setTouched(true);\n    }\n  });\n\n  const watch = () => {\n    watchingRef.current = true;\n    return getValue();\n  };\n\n  const clearError = () => setError(undefined);\n\n  return {\n    register,\n    dirty,\n    touched,\n    error,\n    setError,\n    clearError,\n    getValue,\n    setValue,\n    reset,\n    watch,\n    focus\n  };\n};\n"],"names":["useField","params","initialValue","inputRef","useRef","watchingRef","rerender","useRerender","dirty","setDirty","useState","touched","setTouched","error","setError","getValue","setValue","value","reset","focus","validate","registerParams","node"],"mappings":"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"}