import { useReducer as p } from "react";
const k = (n, c) => {
  switch (c.type) {
    case "SET": {
      const { value: r, capacity: o } = c.payload, e = [...n.history.slice(0, n.currentIndex + 1), r];
      e.length > o && e.shift();
      const t = [n.history, ...n.undoStack];
      return t.length > o && t.pop(), {
        history: e,
        currentIndex: e.length - 1,
        undoStack: t,
        redoStack: []
      };
    }
    case "UNDO":
      return n.undoStack.length === 0 ? n : {
        history: n.undoStack[0],
        currentIndex: n.undoStack[0].length - 1,
        undoStack: n.undoStack.slice(1),
        redoStack: [n.history, ...n.redoStack]
      };
    case "REDO":
      return n.redoStack.length === 0 ? n : {
        history: n.redoStack[0],
        currentIndex: n.redoStack[0].length - 1,
        undoStack: [n.history, ...n.undoStack],
        redoStack: n.redoStack.slice(1)
      };
    case "BACK": {
      const { steps: r } = c.payload;
      return {
        ...n,
        currentIndex: Math.max(0, n.currentIndex - r)
      };
    }
    case "FORWARD": {
      const { steps: r } = c.payload;
      return {
        ...n,
        currentIndex: Math.min(n.currentIndex + r, n.history.length - 1)
      };
    }
    case "RESET": {
      const { initialValue: r, capacity: o } = c.payload;
      if (n.history.length === 1) return n;
      const e = [n.history, ...n.undoStack];
      return e.length > o && e.pop(), {
        history: [r],
        currentIndex: 0,
        undoStack: e,
        redoStack: []
      };
    }
    default:
      throw new Error("Unsupported action type");
  }
}, x = (n, c = 10) => {
  const [r, o] = p(k, {
    history: [n],
    currentIndex: 0,
    undoStack: [],
    redoStack: []
  }), e = r.history[r.currentIndex], t = r.undoStack.length > 0, u = r.redoStack.length > 0, a = (d) => o({
    type: "SET",
    payload: { value: d, capacity: c }
  }), y = () => o({ type: "UNDO" }), s = () => o({ type: "REDO" }), h = (d = 1) => o({ type: "BACK", payload: { steps: d } }), i = (d = 1) => o({ type: "FORWARD", payload: { steps: d } }), S = () => o({ type: "RESET", payload: { initialValue: n, capacity: c } });
  return {
    history: r.history,
    value: e,
    set: a,
    index: r.currentIndex,
    back: h,
    forward: i,
    reset: S,
    undo: y,
    redo: s,
    canUndo: t,
    canRedo: u
  };
};
export {
  k as stateHistoryReducer,
  x as useStateHistory
};
//# sourceMappingURL=useStateHistory.mjs.map
