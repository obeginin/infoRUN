import { useState as e, useEffect as T } from "react";
const f = () => window?.SpeechRecognition ?? window?.webkitSpeechRecognition, q = (d = {}) => {
  const i = typeof window < "u" && !!f(), {
    continuous: m = !1,
    interimResults: R = !1,
    language: c = "en-US",
    grammars: l,
    maxAlternatives: w = 1,
    onStart: S,
    onEnd: h,
    onError: x,
    onResult: E
  } = d, [a, o] = e(!1), [A, b] = e(""), [k, y] = e(!1), [F, u] = e(null), [s] = e(() => {
    if (!i) return {};
    const r = f(), n = new r();
    return n.continuous = m, l && (n.grammars = l), n.interimResults = R, n.lang = c, n.maxAlternatives = w, n.onstart = () => {
      o(!0), y(!1), S?.();
    }, n.onend = () => {
      o(!1), h?.();
    }, n.onerror = (t) => {
      u(t), o(!1), x?.(t);
    }, n.onresult = (t) => {
      console.log("onresult", t);
      const I = t.results[t.resultIndex], { transcript: L } = I[0];
      b(L), u(null), E?.(t);
    }, n.onend = () => {
      o(!1), n.lang = c;
    }, n;
  });
  T(() => () => s.stop(), []);
  const g = () => s.start(), p = () => s.stop();
  return {
    supported: i,
    transcript: A,
    recognition: s,
    final: k,
    listening: a,
    error: F,
    start: g,
    stop: p,
    toggle: (r = !a) => {
      if (r) return g();
      p();
    }
  };
};
export {
  f as getSpeechRecognition,
  q as useSpeechRecognition
};
//# sourceMappingURL=useSpeechRecognition.mjs.map
