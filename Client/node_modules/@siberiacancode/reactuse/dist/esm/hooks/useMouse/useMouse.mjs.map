{"version":3,"file":"useMouse.mjs","sources":["../../../../src/hooks/useMouse/useMouse.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use mouse return type */\nexport interface UseMouseReturn {\n  /** The current mouse client x position */\n  clientX: number;\n  /** The current mouse client y position */\n  clientY: number;\n  /** The current element position x */\n  elementPositionX: number;\n  /** The current element position y */\n  elementPositionY: number;\n  /** The current element x position */\n  elementX: number;\n  /** The current element y position */\n  elementY: number;\n  /** The current mouse x position */\n  x: number;\n  /** The current mouse y position */\n  y: number;\n}\n\nexport interface UseMouse {\n  (target: HookTarget): UseMouseReturn;\n\n  <Target extends Element>(\n    target?: never\n  ): UseMouseReturn & {\n    ref: StateRef<Target>;\n  };\n\n  (target?: Window): UseMouseReturn;\n}\n\n/**\n * @name useMouse\n * @description - Hook that manages a mouse position\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} [target=window] The target element to manage the mouse position for\n * @returns {UseMouseReturn} An object with the current mouse position\n *\n * @example\n * const { x, y, clientX, clientY, elementX, elementY, elementPositionX, elementPositionY } = useMouse(ref);\n *\n * @overload\n * @template Target The target element\n * @returns {UseMouseReturn & { ref: StateRef<Target> }} An object with the current mouse position and a ref\n *\n * @example\n * const { ref, x, y, clientX, clientY, elementX, elementY, elementPositionX, elementPositionY } = useMouse();\n */\nexport const useMouse = ((...params: any[]) => {\n  const target = isTarget(params[0]) ? params[0] : undefined;\n\n  const [value, setValue] = useState<UseMouseReturn>({\n    x: 0,\n    y: 0,\n    elementX: 0,\n    elementY: 0,\n    elementPositionX: 0,\n    elementPositionY: 0,\n    clientX: 0,\n    clientY: 0\n  });\n\n  const internalRef = useRefState<Element>();\n\n  useEffect(() => {\n    const onMouseMove = (event: MouseEvent) => {\n      const element = (target ? getElement(target) : internalRef.current) as Element | undefined;\n\n      const updatedValue = {\n        x: event.pageX,\n        y: event.pageY,\n        clientX: event.clientX,\n        clientY: event.clientY\n      } as typeof value;\n\n      if (element) {\n        const { left, top } = element.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        updatedValue.elementX = elementX;\n        updatedValue.elementY = elementY;\n        updatedValue.elementPositionX = elementPositionX;\n        updatedValue.elementPositionY = elementPositionY;\n\n        setValue((prevValue) => ({\n          ...prevValue,\n          ...updatedValue\n        }));\n      } else {\n        updatedValue.elementX = event.pageX;\n        updatedValue.elementY = event.pageY;\n        updatedValue.elementPositionX = 0;\n        updatedValue.elementPositionY = 0;\n\n        setValue((prevValue) => ({\n          ...prevValue,\n          ...updatedValue\n        }));\n      }\n    };\n\n    const onScroll = () => {\n      setValue((prevValue) => ({\n        ...prevValue,\n        x: prevValue.x + window.scrollX - prevValue.elementPositionX,\n        y: prevValue.y + window.scrollY - prevValue.elementPositionY,\n        elementPositionX: window.scrollX,\n        elementPositionY: window.scrollY\n      }));\n    };\n\n    document.addEventListener('scroll', onScroll, { passive: true });\n    document.addEventListener('mousemove', onMouseMove);\n    return () => {\n      document.removeEventListener('scroll', onScroll);\n      document.removeEventListener('mousemove', onMouseMove);\n    };\n  }, [internalRef.state, target]);\n\n  if (target) return value;\n  return {\n    ref: internalRef,\n    ...value\n  };\n}) as UseMouse;\n"],"names":["useMouse","params","target","isTarget","value","setValue","useState","internalRef","useRefState","useEffect","onMouseMove","event","element","getElement","updatedValue","left","top","elementPositionX","elementPositionY","elementX","elementY","prevValue","onScroll"],"mappings":";;;;AA6DO,MAAMA,IAAY,IAAIC,MAAkB;AAC7C,QAAMC,IAASC,EAASF,EAAO,CAAC,CAAC,IAAIA,EAAO,CAAC,IAAI,QAE3C,CAACG,GAAOC,CAAQ,IAAIC,EAAyB;AAAA,IACjD,GAAG;AAAA,IACH,GAAG;AAAA,IACH,UAAU;AAAA,IACV,UAAU;AAAA,IACV,kBAAkB;AAAA,IAClB,kBAAkB;AAAA,IAClB,SAAS;AAAA,IACT,SAAS;AAAA,EAAA,CACV,GAEKC,IAAcC,EAAA;AA4DpB,SA1DAC,EAAU,MAAM;AACd,UAAMC,IAAc,CAACC,MAAsB;AACzC,YAAMC,IAAWV,IAASW,EAAWX,CAAM,IAAIK,EAAY,SAErDO,IAAe;AAAA,QACnB,GAAGH,EAAM;AAAA,QACT,GAAGA,EAAM;AAAA,QACT,SAASA,EAAM;AAAA,QACf,SAASA,EAAM;AAAA,MAAA;AAGjB,UAAIC,GAAS;AACX,cAAM,EAAE,MAAAG,GAAM,KAAAC,MAAQJ,EAAQ,sBAAA,GACxBK,IAAmBF,IAAO,OAAO,SACjCG,IAAmBF,IAAM,OAAO,SAChCG,IAAWR,EAAM,QAAQM,GACzBG,IAAWT,EAAM,QAAQO;AAE/B,QAAAJ,EAAa,WAAWK,GACxBL,EAAa,WAAWM,GACxBN,EAAa,mBAAmBG,GAChCH,EAAa,mBAAmBI,GAEhCb,EAAS,CAACgB,OAAe;AAAA,UACvB,GAAGA;AAAA,UACH,GAAGP;AAAA,QAAA,EACH;AAAA,MAAA;AAEF,QAAAA,EAAa,WAAWH,EAAM,OAC9BG,EAAa,WAAWH,EAAM,OAC9BG,EAAa,mBAAmB,GAChCA,EAAa,mBAAmB,GAEhCT,EAAS,CAACgB,OAAe;AAAA,UACvB,GAAGA;AAAA,UACH,GAAGP;AAAA,QAAA,EACH;AAAA,IACJ,GAGIQ,IAAW,MAAM;AACrB,MAAAjB,EAAS,CAACgB,OAAe;AAAA,QACvB,GAAGA;AAAA,QACH,GAAGA,EAAU,IAAI,OAAO,UAAUA,EAAU;AAAA,QAC5C,GAAGA,EAAU,IAAI,OAAO,UAAUA,EAAU;AAAA,QAC5C,kBAAkB,OAAO;AAAA,QACzB,kBAAkB,OAAO;AAAA,MAAA,EACzB;AAAA,IAAA;AAGJ,oBAAS,iBAAiB,UAAUC,GAAU,EAAE,SAAS,IAAM,GAC/D,SAAS,iBAAiB,aAAaZ,CAAW,GAC3C,MAAM;AACX,eAAS,oBAAoB,UAAUY,CAAQ,GAC/C,SAAS,oBAAoB,aAAaZ,CAAW;AAAA,IAAA;AAAA,EACvD,GACC,CAACH,EAAY,OAAOL,CAAM,CAAC,GAE1BA,IAAeE,IACZ;AAAA,IACL,KAAKG;AAAA,IACL,GAAGH;AAAA,EAAA;AAEP;"}