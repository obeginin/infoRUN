{"version":3,"file":"useHover.mjs","sources":["../../../../src/hooks/useHover/useHover.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use hover options type */\nexport interface UseHoverOptions {\n  /** The on entry callback */\n  onEntry?: (event: Event) => void;\n  /** The on leave callback */\n  onLeave?: (event: Event) => void;\n}\n\nexport interface UseHoverReturn {\n  value: boolean;\n}\n\nexport interface UseHover {\n  (target: HookTarget, callback?: (event: Event) => void): boolean;\n\n  (target: HookTarget, options?: UseHoverOptions): boolean;\n\n  <Target extends Element>(\n    callback?: (event: Event) => void,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n  } & UseHoverReturn;\n\n  <Target extends Element>(\n    options?: UseHoverOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n  } & UseHoverReturn;\n}\n\n/**\n * @name useHover\n * @description - Hook that defines the logic when hovering an element\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to be hovered\n * @param {(event: Event) => void} [callback] The callback function to be invoked on mouse enter\n * @returns {boolean} The state of the hover\n *\n * @example\n * const hovering = useHover(ref, () => console.log('callback'));\n *\n * @overload\n * @param {HookTarget} target The target element to be hovered\n * @param {(event: Event) => void} [options.onEntry] The callback function to be invoked on mouse enter\n * @param {(event: Event) => void} [options.onLeave] The callback function to be invoked on mouse leave\n * @returns {boolean} The state of the hover\n *\n * @example\n * const hovering = useHover(ref, options);\n *\n * @overload\n * @template Target The target element\n * @param {(event: Event) => void} [callback] The callback function to be invoked on mouse enter\n * @returns {{ ref: StateRef<Target> } & UseHoverReturn} The state of the hover\n *\n * @example\n * const [ref, hovering] = useHover(() => console.log('callback'));\n *\n * @overload\n * @template Target The target element\n * @param {(event: Event) => void} [options.onEntry] The callback function to be invoked on mouse enter\n * @param {(event: Event) => void} [options.onLeave] The callback function to be invoked on mouse leave\n * @returns {{ ref: StateRef<Target> } & UseHoverReturn} The state of the hover\n *\n * @example\n * const [ref, hovering] = useHover(options);\n */\nexport const useHover = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { onEntry: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { onEntry: params[0] }\n  ) as UseHoverOptions | undefined;\n\n  const [hovering, setHovering] = useState(false);\n  const internalRef = useRefState<Element>();\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n\n    if (!element) return;\n\n    const onMouseEnter = (event: Event) => {\n      internalOptionsRef.current?.onEntry?.(event);\n      setHovering(true);\n    };\n\n    const onMouseLeave = (event: Event) => {\n      internalOptionsRef.current?.onLeave?.(event);\n      setHovering(false);\n    };\n\n    element.addEventListener('mouseenter', onMouseEnter);\n    element.addEventListener('mouseleave', onMouseLeave);\n\n    return () => {\n      element.removeEventListener('mouseenter', onMouseEnter);\n      element.removeEventListener('mouseleave', onMouseLeave);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return hovering;\n  return {\n    ref: internalRef,\n    value: hovering\n  } as const;\n}) as UseHover;\n"],"names":["useHover","params","target","isTarget","options","hovering","setHovering","useState","internalRef","useRefState","internalOptionsRef","useRef","useEffect","element","getElement","onMouseEnter","event","onMouseLeave"],"mappings":";;;;AAiFO,MAAMA,IAAY,IAAIC,MAAkB;AAC7C,QAAMC,IAAUC,EAASF,EAAO,CAAC,CAAC,IAAIA,EAAO,CAAC,IAAI,QAE5CG,IACJF,IACI,OAAOD,EAAO,CAAC,KAAM,WACnBA,EAAO,CAAC,IACR,EAAE,SAASA,EAAO,CAAC,EAAA,IACrB,OAAOA,EAAO,CAAC,KAAM,WACnBA,EAAO,CAAC,IACR,EAAE,SAASA,EAAO,CAAC,EAAA,GAGrB,CAACI,GAAUC,CAAW,IAAIC,EAAS,EAAK,GACxCC,IAAcC,EAAA,GACdC,IAAqBC,EAAOP,CAAO;AA4BzC,SA3BAM,EAAmB,UAAUN,GAE7BQ,EAAU,MAAM;AACd,QAAI,CAACV,KAAU,CAACM,EAAY,MAAO;AACnC,UAAMK,IAAWX,IAASY,EAAWZ,CAAM,IAAIM,EAAY;AAE3D,QAAI,CAACK,EAAS;AAEd,UAAME,IAAe,CAACC,MAAiB;AACrC,MAAAN,EAAmB,SAAS,UAAUM,CAAK,GAC3CV,EAAY,EAAI;AAAA,IAAA,GAGZW,IAAe,CAACD,MAAiB;AACrC,MAAAN,EAAmB,SAAS,UAAUM,CAAK,GAC3CV,EAAY,EAAK;AAAA,IAAA;AAGnB,WAAAO,EAAQ,iBAAiB,cAAcE,CAAY,GACnDF,EAAQ,iBAAiB,cAAcI,CAAY,GAE5C,MAAM;AACX,MAAAJ,EAAQ,oBAAoB,cAAcE,CAAY,GACtDF,EAAQ,oBAAoB,cAAcI,CAAY;AAAA,IAAA;AAAA,EACxD,GACC,CAACf,GAAQM,EAAY,KAAK,CAAC,GAE1BN,IAAeG,IACZ;AAAA,IACL,KAAKG;AAAA,IACL,OAAOH;AAAA,EAAA;AAEX;"}