import { useRef as C, useState as U, useEffect as A } from "react";
import { useEvent as M } from "../useEvent/useEvent.mjs";
import { useRefState as B } from "../useRefState/useRefState.mjs";
import { isTarget as S } from "../../utils/helpers/isTarget.mjs";
import { getElement as q } from "../../utils/helpers/getElement.mjs";
const P = 10;
class x {
  x;
  y;
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  update(t) {
    this.x = t.x, this.y = t.y;
  }
  getDifferenceTo(t) {
    return new x(this.x - t.x, this.y - t.y);
  }
  getDistanceTo(t) {
    const e = this.getDifferenceTo(t);
    return Math.sqrt(e.x ** 2 + e.y ** 2);
  }
  getAngleTo(t) {
    const e = this.getDifferenceTo(t);
    return Math.atan2(e.y, e.x);
  }
  equalsTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  moveByAngle(t, e) {
    const o = t + Math.PI / 2;
    return this.x += Math.sin(o) * e, this.y -= Math.cos(o) * e, this;
  }
}
class I {
  pointer;
  brush;
  radius;
  smooth = !1;
  points = [];
  lines = [];
  constructor({ x: t, y: e, radius: o, smooth: h }) {
    this.smooth = h, this.pointer = new x(t, e), this.brush = new x(t, e), this.radius = o, this.points = [], this.lines = [];
  }
  getBrushCoordinates() {
    return {
      x: this.brush.x,
      y: this.brush.y
    };
  }
  getPointerCoordinates() {
    return {
      x: this.pointer.x,
      y: this.pointer.y
    };
  }
  update(t) {
    if (this.pointer.equalsTo(t)) return !1;
    if (this.pointer.update(t), !this.smooth)
      return this.brush.update(t), this.points.push(this.getBrushCoordinates()), !0;
    const e = this.pointer.getDistanceTo(this.brush), o = this.pointer.getAngleTo(this.brush);
    if (Math.round((e - this.radius) * 10) / 10 > 0) {
      const f = o + Math.PI / 2;
      return this.brush.update({
        x: this.brush.x + Math.sin(f) * (e - this.radius),
        y: this.brush.y - Math.cos(f) * (e - this.radius)
      }), this.points.push(this.getBrushCoordinates()), !0;
    }
    return !1;
  }
}
const H = (...p) => {
  const t = S(p[0]) ? p[0] : void 0, e = (t ? p[1] : p[0]) ?? {}, o = e?.color ?? "black", h = e?.opacity ?? 1, f = e?.radius ?? P, s = C(
    new I({
      x: 0,
      y: 0,
      radius: e?.radius ?? P,
      smooth: e?.smooth ?? !1
    })
  ), [m, b] = U(!1), g = B(), n = C(null), c = (r, u, l, a) => {
    if (!n.current) return;
    n.current.globalAlpha = l, n.current.strokeStyle = u, n.current.lineWidth = a * 2, n.current.lineCap = "round", n.current.lineJoin = "round";
    let i = r[0], y = r[1];
    n.current.beginPath();
    for (let d = 1; d < r.length; d += 1) {
      const L = {
        x: i.x + (y.x - i.x) / 2,
        y: i.y + (y.y - i.y) / 2
      };
      n.current.quadraticCurveTo(i.x, i.y, L.x, L.y), i = r[d], y = r[d + 1];
    }
    n.current.lineTo(i.x, i.y), n.current.stroke();
  }, v = () => {
    n.current && n.current.clearRect(
      0,
      0,
      n.current.canvas.width,
      n.current.canvas.height
    );
  }, w = M((r) => {
    if (!m) return;
    e?.onMouseMove?.(r, s.current);
    const u = { x: r.offsetX, y: r.offsetY };
    s.current.update(u) && n.current && (v(), n.current.clearRect(
      0,
      0,
      n.current.canvas.width,
      n.current.canvas.height
    ), s.current.lines.forEach(
      ({ points: a, color: i, opacity: y, radius: d }) => c(a, i, y, d)
    ), c(s.current.points, o, h, f));
  }), E = M((r) => {
    if (!n.current) return;
    const u = { x: r.offsetX, y: r.offsetY };
    s.current.brush.update(u), s.current.points.push(u), c(s.current.points, o, h, f), e?.onMouseDown?.(r, s.current), b(!0);
  }), T = M((r) => {
    n.current && (s.current.points.length && (s.current.lines.push({
      points: s.current.points,
      color: o,
      opacity: h,
      radius: f
    }), s.current.points = []), e?.onMouseUp?.(r, s.current), b(!1));
  }), R = () => {
    n.current && (v(), s.current.lines = [], s.current.points = []);
  }, D = () => {
    n.current && (v(), s.current.lines.pop(), s.current.lines.forEach(
      ({ points: r, color: u, opacity: l, radius: a }) => c(r, u, l, a)
    ));
  };
  return A(() => {
    if (!t && !g.state) return;
    const r = t ? q(t) : g.current;
    if (r)
      return n.current = r.getContext("2d"), e?.initialLines && (s.current.lines = e.initialLines, e.initialLines.forEach(
        ({ points: u, color: l, opacity: a, radius: i }) => c(u, l, a, i)
      )), r.addEventListener("mousedown", E), r.addEventListener("mousemove", w), r.addEventListener("mouseup", T), () => {
        r && (r.removeEventListener("mousedown", E), r.removeEventListener("mousemove", w), r.removeEventListener("mouseup", T));
      };
  }, [t, g.state]), t ? { drawing: m, clear: R, undo: D, draw: c, lines: s.current.lines } : {
    ref: g,
    drawing: m,
    clear: R,
    undo: D,
    draw: c,
    lines: s.current.lines
  };
};
export {
  I as Paint,
  x as Pointer,
  H as usePaint
};
//# sourceMappingURL=usePaint.mjs.map
