{"version":3,"file":"usePaint.mjs","sources":["../../../../src/hooks/usePaint/usePaint.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useEvent } from '../useEvent/useEvent';\nimport { useRefState } from '../useRefState/useRefState';\n\nconst DEFAULT_BRUSH_RADIUS = 10;\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\nexport class Pointer implements Point {\n  x: number;\n\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  update(point: Point) {\n    this.x = point.x;\n    this.y = point.y;\n  }\n\n  getDifferenceTo(point: Point) {\n    return new Pointer(this.x - point.x, this.y - point.y);\n  }\n\n  getDistanceTo(point: Point) {\n    const diff = this.getDifferenceTo(point);\n    return Math.sqrt(diff.x ** 2 + diff.y ** 2);\n  }\n\n  getAngleTo(point: Point) {\n    const diff = this.getDifferenceTo(point);\n    return Math.atan2(diff.y, diff.x);\n  }\n\n  equalsTo(point: Point) {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  moveByAngle(\n    // The angle in radians\n    angle: number,\n    // How much the point should be moved\n    distance: number\n  ) {\n    // Rotate the angle based on the browser coordinate system ([0,0] in the top left)\n    const angleRotated = angle + Math.PI / 2;\n\n    this.x += Math.sin(angleRotated) * distance;\n    this.y -= Math.cos(angleRotated) * distance;\n\n    return this;\n  }\n}\n\nexport class Paint {\n  pointer: Pointer;\n\n  brush: Pointer;\n\n  radius: number;\n\n  smooth: boolean = false;\n\n  points: Point[] = [];\n\n  lines: { points: Point[]; color: string; radius: number; opacity: number }[] = [];\n\n  constructor({ x, y, radius, smooth }: { x: number; y: number; radius: number; smooth: boolean }) {\n    this.smooth = smooth;\n    this.pointer = new Pointer(x, y);\n    this.brush = new Pointer(x, y);\n    this.radius = radius;\n    this.points = [];\n    this.lines = [];\n  }\n\n  getBrushCoordinates() {\n    return {\n      x: this.brush.x,\n      y: this.brush.y\n    };\n  }\n\n  getPointerCoordinates() {\n    return {\n      x: this.pointer.x,\n      y: this.pointer.y\n    };\n  }\n\n  update(point: Point) {\n    if (this.pointer.equalsTo(point)) return false;\n    this.pointer.update(point);\n\n    if (!this.smooth) {\n      this.brush.update(point);\n      this.points.push(this.getBrushCoordinates());\n      return true;\n    }\n\n    const distance = this.pointer.getDistanceTo(this.brush);\n    const angle = this.pointer.getAngleTo(this.brush);\n    const isOutside = Math.round((distance - this.radius) * 10) / 10 > 0;\n\n    if (isOutside) {\n      const angleRotated = angle + Math.PI / 2;\n      this.brush.update({\n        x: this.brush.x + Math.sin(angleRotated) * (distance - this.radius),\n        y: this.brush.y - Math.cos(angleRotated) * (distance - this.radius)\n      });\n      this.points.push(this.getBrushCoordinates());\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport interface UsePaintOptions {\n  /** Brush color */\n  color?: string;\n  /** Initial lines */\n  initialLines?: Paint['lines'];\n  /** Brush opacity */\n  opacity?: number;\n  /** Brush radius */\n  radius?: number;\n  /** Smooth brush movement */\n  smooth?: boolean;\n  /** Callback when the mouse is down */\n  onMouseDown?: (event: MouseEvent, paint: Paint) => void;\n  /** Callback when the mouse is moved */\n  onMouseMove?: (event: MouseEvent, paint: Paint) => void;\n  /** Callback when the mouse is up */\n  onMouseUp?: (event: MouseEvent, paint: Paint) => void;\n}\n\nexport interface UsePaintReturn {\n  drawing: boolean;\n  lines: Paint['lines'];\n  clear: () => void;\n  draw: (points: Point[], color: string, opacity: number, radius: number) => void;\n  undo: () => void;\n}\n\nexport interface UsePaint {\n  (target: HookTarget, options?: UsePaintOptions): UsePaintReturn;\n\n  <Target extends HTMLCanvasElement>(\n    options?: UsePaintOptions,\n    target?: never\n  ): UsePaintReturn & { ref: StateRef<Target> };\n}\n\n/**\n * @name usePaint\n * @description - Hook that allows you to draw in a specific area\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to be painted\n * @param {UsePaintOptions} [options] The options to be used\n * @returns {UsePaintReturn} An object containing the current pencil options and functions to interact with the paint\n *\n * @example\n * const drawing = usePaint(canvasRef);\n *\n * @overload\n * @param {UsePaintOptions} [options] The options to be used\n * @returns {UsePaintReturn & { ref: StateRef<HTMLCanvasElement> }} An object containing the current pencil options and functions to interact with the paint\n *\n * @example\n * const { ref, drawing } = usePaint();\n */\nexport const usePaint = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = ((target ? params[1] : params[0]) as UsePaintOptions) ?? {};\n\n  const color = options?.color ?? 'black';\n  const opacity = options?.opacity ?? 1;\n  const radius = options?.radius ?? DEFAULT_BRUSH_RADIUS;\n\n  const paintRef = useRef<Paint>(\n    new Paint({\n      x: 0,\n      y: 0,\n      radius: options?.radius ?? DEFAULT_BRUSH_RADIUS,\n      smooth: options?.smooth ?? false\n    })\n  );\n  const [drawing, setIsDrawing] = useState(false);\n  const internalRef = useRefState<HTMLCanvasElement>();\n  const contextRef = useRef<CanvasRenderingContext2D | null>(null);\n\n  const draw = (points: Point[], color: string, opacity: number, radius: number) => {\n    if (!contextRef.current) return;\n\n    contextRef.current.globalAlpha = opacity;\n    contextRef.current.strokeStyle = color;\n    contextRef.current.lineWidth = radius * 2;\n    contextRef.current.lineCap = 'round';\n    contextRef.current.lineJoin = 'round';\n\n    let p1 = points[0];\n    let p2 = points[1];\n\n    contextRef.current.beginPath();\n\n    for (let i = 1; i < points.length; i += 1) {\n      const midPoint = {\n        x: p1.x + (p2.x - p1.x) / 2,\n        y: p1.y + (p2.y - p1.y) / 2\n      };\n      contextRef.current.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n      p1 = points[i];\n      p2 = points[i + 1];\n    }\n    contextRef.current.lineTo(p1.x, p1.y);\n    contextRef.current.stroke();\n  };\n\n  const clearCanvas = () => {\n    if (!contextRef.current) return;\n    contextRef.current.clearRect(\n      0,\n      0,\n      contextRef.current.canvas.width,\n      contextRef.current.canvas.height\n    );\n  };\n\n  const onMouseMove = useEvent((event: MouseEvent) => {\n    if (!drawing) return;\n    options?.onMouseMove?.(event, paintRef.current);\n\n    const point = { x: event.offsetX, y: event.offsetY };\n\n    const isUpdated = paintRef.current.update(point);\n\n    if (!isUpdated) return;\n    if (!contextRef.current) return;\n    clearCanvas();\n    contextRef.current.clearRect(\n      0,\n      0,\n      contextRef.current.canvas.width,\n      contextRef.current.canvas.height\n    );\n\n    // const brush = paintRef.current.getBrushCoordinates();\n    // // Draw brush point\n    // contextRef.current.beginPath();\n    // contextRef.current.fillStyle = 'red';\n    // contextRef.current.arc(brush.x, brush.y, radius, 0, Math.PI * 2, true);\n    // contextRef.current.fill();\n\n    // // Draw the lazy radius.\n    // contextRef.current.beginPath();\n    // contextRef.current.strokeStyle = '#ccc';\n    // contextRef.current.arc(brush.x, brush.y, radius * 2, 0, Math.PI * 2, true);\n    // contextRef.current.stroke();\n\n    paintRef.current.lines.forEach(({ points, color, opacity, radius }) =>\n      draw(points, color, opacity, radius)\n    );\n    draw(paintRef.current.points, color, opacity, radius);\n  });\n\n  const onMouseDown = useEvent((event: MouseEvent) => {\n    if (!contextRef.current) return;\n\n    const point = { x: event.offsetX, y: event.offsetY };\n    paintRef.current.brush.update(point);\n    paintRef.current.points.push(point);\n    draw(paintRef.current.points, color, opacity, radius);\n\n    options?.onMouseDown?.(event, paintRef.current);\n    setIsDrawing(true);\n  });\n\n  const onMouseUp = useEvent((event: MouseEvent) => {\n    if (!contextRef.current) return;\n\n    if (paintRef.current.points.length) {\n      paintRef.current.lines.push({\n        points: paintRef.current.points,\n        color,\n        opacity,\n        radius\n      });\n      paintRef.current.points = [];\n    }\n\n    options?.onMouseUp?.(event, paintRef.current);\n    setIsDrawing(false);\n  });\n\n  const clear = () => {\n    if (!contextRef.current) return;\n    clearCanvas();\n    paintRef.current.lines = [];\n    paintRef.current.points = [];\n  };\n\n  const undo = () => {\n    if (!contextRef.current) return;\n    clearCanvas();\n\n    paintRef.current.lines.pop();\n    paintRef.current.lines.forEach(({ points, color, opacity, radius }) =>\n      draw(points, color, opacity, radius)\n    );\n  };\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as HTMLCanvasElement;\n    if (!element) return;\n    contextRef.current = element.getContext('2d');\n\n    if (options?.initialLines) {\n      paintRef.current.lines = options.initialLines;\n      options.initialLines.forEach(({ points, color, opacity, radius }) =>\n        draw(points, color, opacity, radius)\n      );\n    }\n\n    element.addEventListener('mousedown', onMouseDown);\n    element.addEventListener('mousemove', onMouseMove);\n    element.addEventListener('mouseup', onMouseUp);\n\n    return () => {\n      if (!element) return;\n      element.removeEventListener('mousedown', onMouseDown);\n      element.removeEventListener('mousemove', onMouseMove);\n      element.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return { drawing, clear, undo, draw, lines: paintRef.current.lines };\n  return {\n    ref: internalRef,\n    drawing,\n    clear,\n    undo,\n    draw,\n    lines: paintRef.current.lines\n  };\n}) as UsePaint;\n"],"names":["DEFAULT_BRUSH_RADIUS","Pointer","x","y","point","diff","angle","distance","angleRotated","Paint","radius","smooth","usePaint","params","target","isTarget","options","color","opacity","paintRef","useRef","drawing","setIsDrawing","useState","internalRef","useRefState","contextRef","draw","points","p1","p2","i","midPoint","clearCanvas","onMouseMove","useEvent","event","onMouseDown","onMouseUp","clear","undo","useEffect","element","getElement"],"mappings":"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"}