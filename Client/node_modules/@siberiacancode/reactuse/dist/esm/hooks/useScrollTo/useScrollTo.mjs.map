{"version":3,"file":"useScrollTo.mjs","sources":["../../../../src/hooks/useScrollTo/useScrollTo.ts"],"sourcesContent":["import { useLayoutEffect } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use scroll to options type */\nexport interface UseScrollToOptions {\n  /** The scrolling behavior */\n  behavior?: ScrollBehavior;\n  /** Whether to enable the scroll to */\n  enabled?: boolean;\n  /** The horizontal position to scroll to */\n  x: number;\n  /** The vertical position to scroll to */\n  y: number;\n}\n\n/** The use scroll to return type */\nexport interface UseScrollToReturn {\n  /** The state of scrolling */\n  trigger: (params?: { x: number; y: number; behavior?: ScrollBehavior }) => void;\n}\n\nexport interface UseScrollTo {\n  <Target extends Element>(\n    options?: UseScrollToOptions,\n    target?: never\n  ): UseScrollToReturn & { ref: StateRef<Target> };\n\n  (target: HookTarget, options?: UseScrollToOptions): UseScrollToReturn;\n}\n\n/**\n * @name useScrollTo\n * @description - Hook for scrolling to a specific element\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} target The target element for scrolling to\n * @param {UseScrollToOptions} [options] The scroll options\n * @returns {UseScrollToReturn} The scroll trigger function\n *\n * @example\n * const trigger = useScrollTo(ref, options);\n *\n * @overload\n * @template Target The target element\n * @param {UseScrollToOptions} [options] The scroll options\n * @returns {UseScrollToReturn & { ref: StateRef<Target> }} The scroll trigger function and ref\n *\n * @example\n * const { ref, trigger } = useScrollTo(options);\n */\nexport const useScrollTo = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (target ? params[1] : params[0]) as UseScrollToOptions | undefined;\n  const { x, y, behavior = 'auto', enabled = true } = options ?? {};\n  const internalRef = useRefState<Element>();\n\n  useLayoutEffect(() => {\n    if (!enabled) return;\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    element.scrollTo({ top: y, left: x, behavior });\n  }, [target, internalRef.state]);\n\n  const trigger = (params?: { x: number; y: number; behavior?: ScrollBehavior }) => {\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n    const { x, y, behavior } = params ?? {};\n\n    element.scrollTo({ left: x, top: y, behavior });\n  };\n\n  if (target) return { trigger };\n  return { ref: internalRef, trigger };\n}) as UseScrollTo;\n"],"names":["useScrollTo","params","target","isTarget","options","x","y","behavior","enabled","internalRef","useRefState","useLayoutEffect","element","getElement","trigger"],"mappings":";;;;AA0DO,MAAMA,IAAe,IAAIC,MAAkB;AAChD,QAAMC,IAAUC,EAASF,EAAO,CAAC,CAAC,IAAIA,EAAO,CAAC,IAAI,QAC5CG,IAAWF,IAASD,EAAO,CAAC,IAAIA,EAAO,CAAC,GACxC,EAAE,GAAAI,GAAG,GAAAC,GAAG,UAAAC,IAAW,QAAQ,SAAAC,IAAU,OAASJ,KAAW,CAAA,GACzDK,IAAcC,EAAA;AAEpB,EAAAC,EAAgB,MAAM;AAEpB,QADI,CAACH,KACD,CAACN,KAAU,CAACO,EAAY,MAAO;AAEnC,UAAMG,IAAWV,IAASW,EAAWX,CAAM,IAAIO,EAAY;AAC3D,IAAKG,KAELA,EAAQ,SAAS,EAAE,KAAKN,GAAG,MAAMD,GAAG,UAAAE,GAAU;AAAA,EAAA,GAC7C,CAACL,GAAQO,EAAY,KAAK,CAAC;AAE9B,QAAMK,IAAU,CAACb,MAAiE;AAChF,UAAMW,IAAWV,IAASW,EAAWX,CAAM,IAAIO,EAAY;AAC3D,QAAI,CAACG,EAAS;AACd,UAAM,EAAE,GAAAP,GAAG,GAAAC,GAAG,UAAAC,MAAaN,KAAU,CAAA;AAErC,IAAAW,EAAQ,SAAS,EAAE,MAAMP,GAAG,KAAKC,GAAG,UAAAC,GAAU;AAAA,EAAA;AAGhD,SAAIL,IAAe,EAAE,SAAAY,EAAA,IACd,EAAE,KAAKL,GAAa,SAAAK,EAAA;AAC7B;"}