{"version":3,"file":"useTimer.mjs","sources":["../../../../src/hooks/useTimer/useTimer.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\n\nexport type PositiveInteger<Value extends number> = `${Value}` extends `-${any}` | `${any}.${any}`\n  ? never\n  : Value;\n\nexport const getTimeFromSeconds = (timestamp: number) => {\n  const roundedTimestamp = Math.ceil(timestamp);\n  const days = Math.floor(roundedTimestamp / (60 * 60 * 24));\n  const hours = Math.floor((roundedTimestamp % (60 * 60 * 24)) / (60 * 60));\n  const minutes = Math.floor((roundedTimestamp % (60 * 60)) / 60);\n  const seconds = Math.floor(roundedTimestamp % 60);\n\n  return {\n    seconds,\n    minutes,\n    hours,\n    days\n  };\n};\n\n/** The use timer options type */\nexport interface UseTimerOptions {\n  /** Whether the timer should start automatically */\n  immediately?: boolean;\n  /** The function to be executed when the timer is expired */\n  onExpire?: () => void;\n  /** The function to be executed when the timer is started */\n  onStart?: () => void;\n  /** Callback function to be executed on each tick of the timer */\n  onTick?: (seconds: number) => void;\n}\n\n/** The use timer return type */\nexport interface UseTimerReturn {\n  /** flag to indicate if timer is active or not */\n  active: boolean;\n  /** The total count of the timer */\n  count: number;\n  /** The day count of the timer */\n  days: number;\n  /** The hour count of the timer */\n  hours: number;\n  /** The minute count of the timer */\n  minutes: number;\n  /** The second count of the timer */\n  seconds: number;\n  /** The function to clear the timer */\n  clear: () => void;\n  /** The function to decrease the timer */\n  decrease: (seconds: PositiveInteger<number>) => void;\n  /** The function to increase the timer */\n  increase: (seconds: PositiveInteger<number>) => void;\n  /** The function to pause the timer */\n  pause: () => void;\n  /** The function to restart the timer */\n  restart: (time: PositiveInteger<number>, immediately?: boolean) => void;\n  /** The function to resume the timer */\n  resume: () => void;\n  /** The function to start the timer */\n  start: () => void;\n  /** The function to toggle the timer */\n  toggle: () => void;\n}\n\nexport interface UseTimer {\n  (): UseTimerReturn;\n\n  (seconds: PositiveInteger<number>, callback: () => void): UseTimerReturn;\n\n  (seconds: PositiveInteger<number>, options?: UseTimerOptions): UseTimerReturn;\n}\n\n/**\n * @name useTimer\n * @description - Hook that creates a timer functionality\n * @category Time\n *\n * @overload\n * @returns {UseTimerReturn} An object containing the timer properties and functions\n *\n * @example\n * const { days, hours, minutes, seconds, toggle, pause, start, restart, resume, active, decrease, increase } = useTimer();\n *\n * @overload\n * @param {number} seconds The seconds value that define for how long the timer will be running\n * @param {() => void} callback The function to be executed once countdown timer is expired\n * @returns {UseTimerReturn} An object containing the timer properties and functions\n *\n * @example\n * const { days, hours, minutes, seconds, toggle, pause, start, restart, resume, active, decrease, increase } = useTimer(1000, () => console.log('ready'));\n *\n * @overload\n * @param {number} seconds The seconds value that define for how long the timer will be running\n * @param {boolean} [options.immediately=true] The flag to decide if timer should start automatically\n * @param {() => void} [options.onExpire] The function to be executed when the timer is expired\n * @param {(timestamp: number) => void} [options.onTick] The function to be executed on each tick of the timer\n * @returns {UseTimerReturn} An object containing the timer properties and functions\n *\n * @example\n * const { days, hours, minutes, seconds, toggle, pause, start, restart, resume, active, decrease, increase } = useTimer(1000);\n */\nexport const useTimer = ((...params: any[]) => {\n  const initialSeconds = Math.max((params[0] ?? 0) as PositiveInteger<number>, 0);\n  const options = (typeof params[1] === 'object' ? params[1] : { onExpire: params[1] }) as\n    | UseTimerOptions\n    | undefined;\n\n  const [active, setActive] = useState(initialSeconds > 0 && (options?.immediately ?? true));\n  const [seconds, setSeconds] = useState(initialSeconds);\n\n  const intervalIdRef = useRef<ReturnType<typeof setInterval>>(undefined);\n  const optionsRef = useRef<UseTimerOptions>(options);\n  optionsRef.current = options ?? {};\n\n  useDidUpdate(() => {\n    if (initialSeconds <= 0) {\n      setActive(false);\n      setSeconds(0);\n      return;\n    }\n\n    setActive(true);\n    setSeconds(initialSeconds);\n  }, [initialSeconds]);\n\n  useEffect(() => {\n    if (!active) return;\n\n    optionsRef.current?.onStart?.();\n    const onInterval = () => {\n      setSeconds((prevSeconds) => {\n        optionsRef.current?.onTick?.(prevSeconds);\n        const updatedSeconds = prevSeconds - 1;\n        if (updatedSeconds === 0) {\n          setActive(false);\n          optionsRef.current?.onExpire?.();\n        }\n        return updatedSeconds;\n      });\n    };\n\n    intervalIdRef.current = setInterval(onInterval, 1000);\n    return () => {\n      clearInterval(intervalIdRef.current);\n    };\n  }, [active]);\n\n  const pause = () => setActive(false);\n  const resume = () => {\n    if (seconds <= 0) return;\n    setActive(true);\n  };\n\n  const toggle = () => {\n    if (seconds <= 0) return;\n    setActive(!active);\n  };\n\n  const restart = (seconds: PositiveInteger<number>, immediately = true) => {\n    setSeconds(seconds);\n    if (immediately) setActive(true);\n  };\n\n  const start = () => {\n    if (initialSeconds <= 0) return;\n\n    setActive(true);\n    setSeconds(initialSeconds);\n  };\n\n  const clear = () => {\n    setActive(false);\n    setSeconds(0);\n  };\n\n  const increase = (seconds: PositiveInteger<number>) =>\n    setSeconds((prevSeconds) => prevSeconds + seconds);\n  const decrease = (seconds: PositiveInteger<number>) => {\n    setSeconds((prevSeconds) => {\n      const updatedSeconds = prevSeconds - seconds;\n      if (updatedSeconds <= 0) {\n        setActive(false);\n        return 0;\n      } else {\n        return updatedSeconds;\n      }\n    });\n  };\n\n  return {\n    ...getTimeFromSeconds(seconds),\n    count: seconds,\n    pause,\n    active,\n    resume,\n    toggle,\n    start,\n    restart,\n    clear,\n    increase,\n    decrease\n  };\n}) as UseTimer;\n"],"names":["getTimeFromSeconds","timestamp","roundedTimestamp","days","hours","minutes","useTimer","params","initialSeconds","options","active","setActive","useState","seconds","setSeconds","intervalIdRef","useRef","optionsRef","useDidUpdate","useEffect","onInterval","prevSeconds","updatedSeconds","pause","resume","toggle","restart","immediately","start","clear","increase","decrease"],"mappings":"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"}