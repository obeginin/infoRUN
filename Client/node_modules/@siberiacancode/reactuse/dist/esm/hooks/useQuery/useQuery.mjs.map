{"version":3,"file":"useQuery.mjs","sources":["../../../../src/hooks/useQuery/useQuery.ts"],"sourcesContent":["import type { DependencyList } from 'react';\n\nimport { useEffect, useRef, useState } from 'react';\n\nimport { getRetry } from '@/utils/helpers';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\nimport { useMount } from '../useMount/useMount';\n\n/* The use query return type */\nexport interface UseQueryOptions<QueryData, Data> {\n  /* The enabled state of the query */\n  enabled?: boolean;\n  /* The depends for the hook */\n  keys?: DependencyList;\n  /* The placeholder data for the hook */\n  placeholderData?: (() => Data) | Data;\n  /* The refetch interval */\n  refetchInterval?: number;\n  /* The retry count of requests */\n  retry?: boolean | number;\n  /* The retry delay of requests */\n  retryDelay?: ((retry: number, error: Error) => number) | number;\n  /* The callback function to be invoked on error */\n  onError?: (error: Error) => void;\n  /* The callback function to be invoked on success */\n  onSuccess?: (data: Data) => void;\n  /* The select function to be invoked */\n  select?: (data: QueryData) => Data;\n}\n\ninterface UseQueryCallbackParams {\n  /* The depends for the hook */\n  keys: DependencyList;\n  /* The abort signal */\n  signal: AbortSignal;\n}\n\n/* The use query return type */\nexport interface UseQueryReturn<Data> {\n  /* The abort function */\n  abort: AbortController['abort'];\n  /* The state of the query */\n  data?: Data;\n  /* The success state of the query */\n  error?: Error;\n  /* The error state of the query */\n  isError: boolean;\n  /* The fetching state of the query */\n  isFetching: boolean;\n  /* The loading state of the query */\n  isLoading: boolean;\n  /* The refetching state of the query */\n  isRefetching: boolean;\n  /* The success state of the query */\n  isSuccess: boolean;\n  /* The refetch function */\n  refetch: () => void;\n}\n\n/**\n * @name useQuery\n * @description - Hook that defines the logic when query data\n * @category Async\n *\n * @template Data The type of the data\n * @param {() => Promise<Data>} callback The callback function to be invoked\n * @param {DependencyList} [options.keys] The dependencies for the hook\n * @param {(data: Data) => void} [options.onSuccess] The callback function to be invoked on success\n * @param {(error: Error) => void} [options.onError] The callback function to be invoked on error\n * @param {UseQueryOptionsSelect<Data>} [options.select] The select function to be invoked\n * @param {Data | (() => Data)} [options.initialData] The initial data for the hook\n * @param {Data | (() => Data)} [options.placeholderData] The placeholder data for the hook\n * @param {number} [options.refetchInterval] The refetch interval\n * @param {boolean | number} [options.retry] The retry count of requests\n * @returns {UseQueryReturn<Data>} An object with the state of the query\n *\n * @example\n * const { data, isFetching, isLoading, isError, isSuccess, error, refetch, isRefetching, abort, aborted } = useQuery(() => fetch('url'));\n */\nexport const useQuery = <QueryData, Data = QueryData>(\n  callback: (params: UseQueryCallbackParams) => Promise<QueryData>,\n  options?: UseQueryOptions<QueryData, Data>\n): UseQueryReturn<Data> => {\n  const enabled = options?.enabled ?? true;\n  const retryCountRef = useRef(options?.retry ? getRetry(options.retry) : 0);\n  const alreadyRequested = useRef(false);\n\n  const [isFetching, setIsFetching] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isError, setIsError] = useState(false);\n  const [isRefetching, setIsRefetching] = useState(false);\n  const [isSuccess, setIsSuccess] = useState(!!options?.placeholderData);\n\n  const [error, setError] = useState<Error | undefined>(undefined);\n  const [data, setData] = useState<Data | undefined>(options?.placeholderData);\n\n  const abortControllerRef = useRef<AbortController>(new AbortController());\n  const intervalIdRef = useRef<ReturnType<typeof setInterval>>(undefined);\n\n  const keys = options?.keys ?? [];\n\n  const abort = () => {\n    abortControllerRef.current.abort();\n    abortControllerRef.current = new AbortController();\n  };\n\n  const request = (action: 'init' | 'refetch') => {\n    abort();\n\n    setIsFetching(true);\n    if (action === 'init') {\n      alreadyRequested.current = true;\n      setIsLoading(true);\n    }\n    if (action === 'refetch') setIsRefetching(true);\n    callback({ signal: abortControllerRef.current.signal, keys })\n      .then((response) => {\n        const data = options?.select ? options?.select(response) : response;\n        options?.onSuccess?.(data as Data);\n        setData(data as Data);\n        setIsSuccess(true);\n        setError(undefined);\n        setIsError(false);\n        setIsFetching(false);\n        if (action === 'init') setIsLoading(false);\n        if (action === 'refetch') setIsRefetching(false);\n      })\n      .catch((error: Error) => {\n        if (retryCountRef.current > 0) {\n          retryCountRef.current -= 1;\n          const retryDelay =\n            typeof options?.retryDelay === 'function'\n              ? options?.retryDelay(retryCountRef.current, error)\n              : options?.retryDelay;\n\n          if (retryDelay) {\n            setTimeout(() => request(action), retryDelay);\n            return;\n          }\n\n          return request(action);\n        }\n        options?.onError?.(error);\n        setData(undefined);\n        setIsSuccess(false);\n        setError(error);\n        setIsError(true);\n        setIsFetching(false);\n        if (action === 'init') setIsLoading(false);\n        if (action === 'refetch') setIsRefetching(false);\n        retryCountRef.current = options?.retry ? getRetry(options.retry) : 0;\n      })\n      .finally(() => {\n        if (options?.refetchInterval) {\n          const interval = setInterval(() => {\n            clearInterval(interval);\n            request('refetch');\n          }, options?.refetchInterval);\n          intervalIdRef.current = interval;\n        }\n      });\n  };\n\n  useMount(() => {\n    if (!enabled) return;\n    request('init');\n  });\n\n  useDidUpdate(() => {\n    if (!enabled) return;\n    request(alreadyRequested.current ? 'refetch' : 'init');\n  }, [enabled, ...keys]);\n\n  useEffect(() => {\n    return () => {\n      clearInterval(intervalIdRef.current);\n    };\n  }, [enabled, options?.refetchInterval, options?.retry, ...keys]);\n\n  const refetch = () => request('refetch');\n\n  return {\n    abort,\n    data,\n    error,\n    refetch,\n    isFetching,\n    isLoading,\n    isError,\n    isSuccess,\n    isRefetching\n  };\n};\n"],"names":["useQuery","callback","options","enabled","retryCountRef","useRef","getRetry","alreadyRequested","isFetching","setIsFetching","useState","isLoading","setIsLoading","isError","setIsError","isRefetching","setIsRefetching","isSuccess","setIsSuccess","error","setError","data","setData","abortControllerRef","intervalIdRef","keys","abort","request","action","response","retryDelay","interval","useMount","useDidUpdate","useEffect"],"mappings":"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"}