import { useState as c, useRef as E, useEffect as I } from "react";
import { getRetry as D } from "../../utils/helpers/getRetry.mjs";
const L = (g, v = [], e = {}) => {
  const [C, s] = c(!1), [S, f] = c(!1), [h, y] = c(!1), u = E(e?.retry ? D(e.retry) : 0), [R, d] = c(void 0), [w, i] = c(e?.placeholderData), n = E(void 0), m = e.immediately ?? !0, l = () => {
    n.current && (n.current.close(), n.current = void 0, f(!1), s(!1), y(!1));
  }, o = () => {
    l();
    const a = new EventSource(g, {
      withCredentials: e.withCredentials ?? !1
    });
    n.current = a, s(!0), a.onopen = () => {
      f(!0), s(!1), d(void 0), e?.onOpen?.();
    }, a.onerror = (r) => {
      if (f(!1), s(!1), y(!0), d(r), e?.onError?.(r), u.current > 0) {
        u.current -= 1;
        const t = typeof e?.retryDelay == "function" ? e?.retryDelay(u.current, r) : e?.retryDelay;
        if (t) {
          setTimeout(o, t);
          return;
        }
      }
      u.current = e?.retry ? D(e.retry) : 0;
    }, a.onmessage = (r) => {
      const t = e?.select ? e?.select(r.data) : r.data;
      i(t), e?.onMessage?.(r);
    }, v.forEach((r) => {
      a.addEventListener(r, (t) => {
        i(t.data);
      });
    });
  };
  return I(() => {
    if (m)
      return o(), () => {
        l();
      };
  }, [m]), {
    instance: n.current,
    data: w,
    error: R,
    isConnecting: C,
    isOpen: S,
    isError: h,
    close: l,
    open: o
  };
};
export {
  L as useEventSource
};
//# sourceMappingURL=useEventSource.mjs.map
