import { useState as n } from "react";
const M = (S, c) => {
  const [m, u] = n(!1), [I, f] = n(!1), [g, o] = n(!1), [h, D] = n(null), [A, E] = n(null), y = (t, r) => {
    u(!0);
    const e = r?.attempt ?? 0;
    return S(t).then((a) => (r?.onSuccess?.(a), E(a), o(!0), u(!1), D(null), f(!1), a)).catch((a) => {
      const l = typeof r?.retry == "function" ? r?.retry(e, a) : r?.retry, s = typeof r?.retryDelay == "function" ? r?.retryDelay(e, a) : r?.retryDelay;
      if (typeof l == "boolean" && l) {
        if (s) {
          setTimeout(
            () => y(t, { ...r, attempt: e + 1 }),
            s
          );
          return;
        }
        return y(t, { ...r, attempt: e + 1 });
      }
      if (l && l > e) {
        if (s) {
          setTimeout(
            () => y(t, { ...r, attempt: e + 1 }),
            s
          );
          return;
        }
        return y(t, { ...r, attempt: e + 1 });
      }
      r?.onError?.(a), E(null), o(!1), u(!1), D(a), f(!0);
    });
  };
  return {
    data: A,
    error: h,
    mutate: (t, r) => {
      const e = {
        retry: r?.retry ?? c?.retry,
        retryDelay: r?.retryDelay ?? c?.retryDelay,
        onSuccess: r?.onSuccess ?? c?.onSuccess,
        onError: r?.onError ?? c?.onError
      };
      y(t, e);
    },
    mutateAsync: async (t, r) => {
      const e = {
        retry: r?.retry ?? c?.retry,
        retryDelay: r?.retryDelay ?? c?.retryDelay,
        onSuccess: r?.onSuccess ?? c?.onSuccess,
        onError: r?.onError ?? c?.onError
      };
      return y(t, e);
    },
    isLoading: m,
    isError: I,
    isSuccess: g
  };
};
export {
  M as useMutation
};
//# sourceMappingURL=useMutation.mjs.map
