import { useState as B, useEffect as C } from "react";
import { useDeviceOrientation as D } from "../useDeviceOrientation/useDeviceOrientation.mjs";
import { useOrientation as P } from "../useOrientation/useOrientation.mjs";
import { useRefState as S } from "../useRefState/useRefState.mjs";
import { isTarget as X } from "../../utils/helpers/isTarget.mjs";
import { getElement as Y } from "../../utils/helpers/getElement.mjs";
const G = (...o) => {
  const n = X(o[0]) ? o[0] : void 0, p = o[1] ? o[1] : o[0], i = S(), s = P(), e = D(), {
    deviceOrientationRollAdjust: g = (a) => a,
    deviceOrientationTiltAdjust: f = (a) => a,
    mouseRollAdjust: b = (a) => a,
    mouseTiltAdjust: y = (a) => a
  } = p ?? {}, [l, O] = B({
    roll: 0,
    tilt: 0,
    source: "mouse"
  });
  return C(() => {
    if (!n && !i.state) return;
    const a = n ? Y(n) : i.current;
    if (!a) return;
    const m = (v) => {
      const { left: h, top: k } = a.getBoundingClientRect(), w = h + window.scrollX, R = k + window.scrollY, c = () => e.supported && (e.value.alpha || e.value.gamma) ? "deviceOrientation" : "mouse", T = () => {
        if (c() === "deviceOrientation") {
          let t;
          switch (s.value.orientationType) {
            case "landscape-primary":
              t = e.value.gamma / 90;
              break;
            case "landscape-secondary":
              t = -e.value.gamma / 90;
              break;
            case "portrait-primary":
              t = -e.value.beta / 90;
              break;
            case "portrait-secondary":
              t = e.value.beta / 90;
              break;
            default:
              t = -e.value.beta / 90;
          }
          return g(t);
        } else {
          const t = v.pageY - R, r = a.getBoundingClientRect().height, u = -(t - r / 2) / r;
          return b(u);
        }
      }, j = () => {
        if (c() === "deviceOrientation") {
          let t;
          switch (s.value.orientationType) {
            case "landscape-primary":
              t = e.value.beta / 90;
              break;
            case "landscape-secondary":
              t = -e.value.beta / 90;
              break;
            case "portrait-primary":
              t = e.value.gamma / 90;
              break;
            case "portrait-secondary":
              t = -e.value.gamma / 90;
              break;
            default:
              t = e.value.gamma / 90;
          }
          return f(t);
        } else {
          const t = v.pageX - w, r = a.getBoundingClientRect().width, u = (t - r / 2) / r;
          return y(u);
        }
      }, A = c(), E = T(), x = j();
      O({
        roll: E,
        source: A,
        tilt: x
      });
    };
    return document.addEventListener("mousemove", m), () => {
      document.removeEventListener("mousemove", m);
    };
  }, [
    n,
    i.state,
    s.value.angle,
    s.value.orientationType,
    e.value.gamma,
    e.value.beta,
    e.value.alpha,
    e.value.absolute
  ]), n ? { value: l } : {
    ref: i,
    value: l
  };
};
export {
  G as useParallax
};
//# sourceMappingURL=useParallax.mjs.map
