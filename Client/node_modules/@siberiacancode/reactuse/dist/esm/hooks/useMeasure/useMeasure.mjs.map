{"version":3,"file":"useMeasure.mjs","sources":["../../../../src/hooks/useMeasure/useMeasure.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use measure return type */\nexport type UseMeasureReturn = Pick<\n  DOMRectReadOnly,\n  'bottom' | 'height' | 'left' | 'right' | 'top' | 'width' | 'x' | 'y'\n>;\n\nexport interface UseMeasure {\n  (target: HookTarget): UseMeasureReturn;\n\n  <Target extends Element>(\n    target?: never\n  ): UseMeasureReturn & {\n    ref: StateRef<Target>;\n  };\n}\n\n/**\n * @name useMeasure\n * @description - Hook to measure the size and position of an element\n * @category Browser\n *\n * @overload\n * @param {HookTarget} target The element to measure\n * @returns {UseMeasureReturn} The element's size and position\n *\n * @example\n * const { x, y, width, height, top, left, bottom, right } = useMeasure(ref);\n *\n * @overload\n * @template Target The element to measure\n * @returns {UseMeasureReturn & { ref: StateRef<Target> }} The element's size and position\n *\n * @example\n * const { ref, x, y, width, height, top, left, bottom, right } = useMeasure();\n */\nexport const useMeasure = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n\n  const internalRef = useRefState<Element>();\n  const [rect, setRect] = useState({\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0\n  });\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      const entry = entries[0];\n      if (!entry) return;\n\n      const { x, y, width, height, top, left, bottom, right } = entry.contentRect;\n      setRect({ x, y, width, height, top, left, bottom, right });\n    });\n\n    resizeObserver.observe(element);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return rect;\n  return { ref: internalRef, ...rect };\n}) as UseMeasure;\n"],"names":["useMeasure","params","target","isTarget","internalRef","useRefState","rect","setRect","useState","useEffect","element","getElement","resizeObserver","entries","entry","x","y","width","height","top","left","bottom","right"],"mappings":";;;;AA6CO,MAAMA,IAAc,IAAIC,MAAkB;AAC/C,QAAMC,IAAUC,EAASF,EAAO,CAAC,CAAC,IAAIA,EAAO,CAAC,IAAI,QAE5CG,IAAcC,EAAA,GACd,CAACC,GAAMC,CAAO,IAAIC,EAAS;AAAA,IAC/B,GAAG;AAAA,IACH,GAAG;AAAA,IACH,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,KAAK;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,EAAA,CACR;AAuBD,SArBAC,EAAU,MAAM;AACd,QAAI,CAACP,KAAU,CAACE,EAAY,MAAO;AAEnC,UAAMM,IAAWR,IAASS,EAAWT,CAAM,IAAIE,EAAY;AAC3D,QAAI,CAACM,EAAS;AAEd,UAAME,IAAiB,IAAI,eAAe,CAACC,MAAY;AACrD,YAAMC,IAAQD,EAAQ,CAAC;AACvB,UAAI,CAACC,EAAO;AAEZ,YAAM,EAAE,GAAAC,GAAG,GAAAC,GAAG,OAAAC,GAAO,QAAAC,GAAQ,KAAAC,GAAK,MAAAC,GAAM,QAAAC,GAAQ,OAAAC,EAAA,IAAUR,EAAM;AAChE,MAAAP,EAAQ,EAAE,GAAAQ,GAAG,GAAAC,GAAG,OAAAC,GAAO,QAAAC,GAAQ,KAAAC,GAAK,MAAAC,GAAM,QAAAC,GAAQ,OAAAC,GAAO;AAAA,IAAA,CAC1D;AAED,WAAAV,EAAe,QAAQF,CAAO,GAEvB,MAAM;AACX,MAAAE,EAAe,WAAA;AAAA,IAAW;AAAA,EAC5B,GACC,CAACV,GAAQE,EAAY,KAAK,CAAC,GAE1BF,IAAeI,IACZ,EAAE,KAAKF,GAAa,GAAGE,EAAA;AAChC;"}