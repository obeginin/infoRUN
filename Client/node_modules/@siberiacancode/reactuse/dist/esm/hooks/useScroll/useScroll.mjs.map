{"version":3,"file":"useScroll.mjs","sources":["../../../../src/hooks/useScroll/useScroll.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\n\nexport interface UseScrollOptions {\n  /** The on scroll callback */\n  onScroll?: (params: UseScrollCallbackParams, event: Event) => void;\n\n  /** The on end scroll callback */\n  onStop?: (event: Event) => void;\n\n  /** Offset arrived states by x pixels. */\n  offset?: {\n    left?: number;\n    right?: number;\n    top?: number;\n    bottom?: number;\n  };\n}\n\nexport interface UseScrollCallbackParams {\n  /** The element x position */\n  x: number;\n  /** The element y position */\n  y: number;\n  /** State of scroll arrived */\n  arrived: {\n    left: boolean;\n    right: boolean;\n    top: boolean;\n    bottom: boolean;\n  };\n  /** State of scroll direction */\n  directions: {\n    left: boolean;\n    right: boolean;\n    top: boolean;\n    bottom: boolean;\n  };\n}\n\nexport interface UseScroll {\n  (target: HookTarget, callback?: (params: UseScrollCallbackParams, event: Event) => void): boolean;\n\n  (target: HookTarget, options?: UseScrollOptions): boolean;\n\n  <Target extends Element>(\n    callback?: (params: UseScrollCallbackParams, event: Event) => void,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n    scrolling: boolean;\n  };\n\n  <Target extends Element>(\n    options?: UseScrollOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n    scrolling: boolean;\n  };\n}\n\n/**\n * @name useScroll\n * @description - Hook that allows you to control scroll a element\n * @category Sensors\n *\n * @overload\n * @template Target The target element\n * @param {ScrollBehavior} [options.behavior=auto] The behavior of scrolling\n * @param {number} [options.offset.left=0] The left offset for arrived states\n * @param {number} [options.offset.right=0]  The right offset for arrived states\n * @param {number} [options.offset.top=0] The top offset for arrived states\n * @param {number} [options.offset.bottom=0] The bottom offset for arrived states\n * @param {(params: UseScrollCallbackParams, event: Event) => void} [options.onScroll] The callback function to be invoked on scroll\n * @param {(event: Event) => void} [options.onStop] The callback function to be invoked on scroll end\n * @returns {boolean} The state of scrolling\n *\n * @example\n * const scrolling = useScroll(ref, options);\n *\n * @overload\n * @template Target The target element\n * @param {(params: UseScrollCallbackParams, event: Event) => void} [callback] The callback function to be invoked on scroll\n * @returns {boolean} The state of scrolling\n *\n * @example\n * const scrolling = useScroll(ref, () => console.log('callback'));\n *\n * @overload\n * @template Target The target element\n * @param {Target} target The target element to scroll\n * @param {ScrollBehavior} [options.behavior=auto] The behavior of scrolling\n * @param {number} [options.offset.left=0] The left offset for arrived states\n * @param {number} [options.offset.right=0]  The right offset for arrived states\n * @param {number} [options.offset.top=0] The top offset for arrived states\n * @param {number} [options.offset.bottom=0] The bottom offset for arrived states\n * @param {(params: UseScrollCallbackParams, event: Event) => void} [options.onScroll] The callback function to be invoked on scroll\n * @param {(event: Event) => void} [options.onStop] The callback function to be invoked on scroll end\n * @returns {[StateRef<Target>, boolean]} The state of scrolling\n *\n * @example\n * const { ref, scrolling } = useScroll(options);\n *\n * @overload\n * @template Target The target element\n * @param {Target} target The target element to scroll\n * @param {(params: UseScrollCallbackParams, event: Event) => void} [callback] The callback function to be invoked on scroll\n * @returns {[StateRef<Target>, boolean]} The state of scrolling\n *\n * @example\n * const { ref, scrolling } = useScroll(() => console.log('callback'));\n */\nexport const useScroll = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { onScroll: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { onScroll: params[0] }\n  ) as UseScrollOptions | undefined;\n\n  const internalRef = useRefState<Element>();\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  const [scrolling, setScrolling] = useState(false);\n  const scrollPositionRef = useRef({ x: 0, y: 0 });\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n\n    if (!element) return;\n\n    const onScrollEnd = (event: Event) => {\n      setScrolling(false);\n      options?.onStop?.(event);\n    };\n\n    const onScroll = (event: Event) => {\n      setScrolling(true);\n      const target = (\n        event.target === document ? (event.target as Document).documentElement : event.target\n      ) as HTMLElement;\n\n      const { display, flexDirection, direction } = target.style;\n      const directionMultiplier = direction === 'rtl' ? -1 : 1;\n\n      const scrollLeft = target.scrollLeft;\n      let scrollTop = target.scrollTop;\n      if (target instanceof Document && !scrollTop) scrollTop = window.document.body.scrollTop;\n\n      const offset = internalOptionsRef.current?.offset;\n      const left = scrollLeft * directionMultiplier <= (offset?.left ?? 0);\n      const right =\n        scrollLeft * directionMultiplier + target.clientWidth >=\n        target.scrollWidth - (offset?.right ?? 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n      const top = scrollTop <= (offset?.top ?? 0);\n      const bottom =\n        scrollTop + target.clientHeight >=\n        target.scrollHeight - (offset?.bottom ?? 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n\n      const isColumnReverse = display === 'flex' && flexDirection === 'column-reverse';\n      const isRowReverse = display === 'flex' && flexDirection === 'column-reverse';\n\n      const params = {\n        x: scrollLeft,\n        y: scrollTop,\n        directions: {\n          left: scrollLeft < scrollPositionRef.current.x,\n          right: scrollLeft > scrollPositionRef.current.x,\n          top: scrollTop < scrollPositionRef.current.y,\n          bottom: scrollTop > scrollPositionRef.current.y\n        },\n        arrived: {\n          left: isRowReverse ? right : left,\n          right: isRowReverse ? left : right,\n          top: isColumnReverse ? bottom : top,\n          bottom: isColumnReverse ? top : bottom\n        }\n      };\n\n      scrollPositionRef.current = { x: scrollLeft, y: scrollTop };\n      internalOptionsRef.current?.onScroll?.(params, event);\n    };\n\n    element.addEventListener('scroll', onScroll);\n    element.addEventListener('scrollend', onScrollEnd);\n\n    return () => {\n      element.removeEventListener('scroll', onScroll);\n      element.removeEventListener('scrollend', onScrollEnd);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return scrolling;\n  return {\n    ref: internalRef,\n    scrolling\n  };\n}) as UseScroll;\n"],"names":["ARRIVED_STATE_THRESHOLD_PIXELS","useScroll","params","target","isTarget","options","internalRef","useRefState","internalOptionsRef","useRef","scrolling","setScrolling","useState","scrollPositionRef","useEffect","element","getElement","onScrollEnd","event","onScroll","display","flexDirection","direction","directionMultiplier","scrollLeft","scrollTop","offset","left","right","top","bottom","isColumnReverse","isRowReverse"],"mappings":";;;;AAUA,MAAMA,IAAiC,GAgH1BC,IAAa,IAAIC,MAAkB;AAC9C,QAAMC,IAAUC,EAASF,EAAO,CAAC,CAAC,IAAIA,EAAO,CAAC,IAAI,QAC5CG,IACJF,IACI,OAAOD,EAAO,CAAC,KAAM,WACnBA,EAAO,CAAC,IACR,EAAE,UAAUA,EAAO,CAAC,EAAA,IACtB,OAAOA,EAAO,CAAC,KAAM,WACnBA,EAAO,CAAC,IACR,EAAE,UAAUA,EAAO,CAAC,EAAA,GAGtBI,IAAcC,EAAA,GACdC,IAAqBC,EAAOJ,CAAO;AACzC,EAAAG,EAAmB,UAAUH;AAE7B,QAAM,CAACK,GAAWC,CAAY,IAAIC,EAAS,EAAK,GAC1CC,IAAoBJ,EAAO,EAAE,GAAG,GAAG,GAAG,GAAG;AAqE/C,SAnEAK,EAAU,MAAM;AACd,QAAI,CAACX,KAAU,CAACG,EAAY,MAAO;AACnC,UAAMS,IAAWZ,IAASa,EAAWb,CAAM,IAAIG,EAAY;AAE3D,QAAI,CAACS,EAAS;AAEd,UAAME,IAAc,CAACC,MAAiB;AACpC,MAAAP,EAAa,EAAK,GAClBN,GAAS,SAASa,CAAK;AAAA,IAAA,GAGnBC,IAAW,CAACD,MAAiB;AACjC,MAAAP,EAAa,EAAI;AACjB,YAAMR,IACJe,EAAM,WAAW,WAAYA,EAAM,OAAoB,kBAAkBA,EAAM,QAG3E,EAAE,SAAAE,GAAS,eAAAC,GAAe,WAAAC,EAAA,IAAcnB,EAAO,OAC/CoB,IAAsBD,MAAc,QAAQ,KAAK,GAEjDE,IAAarB,EAAO;AAC1B,UAAIsB,IAAYtB,EAAO;AACvB,MAAIA,aAAkB,YAAY,CAACsB,MAAWA,IAAY,OAAO,SAAS,KAAK;AAE/E,YAAMC,IAASlB,EAAmB,SAAS,QACrCmB,IAAOH,IAAaD,MAAwBG,GAAQ,QAAQ,IAC5DE,IACJJ,IAAaD,IAAsBpB,EAAO,eAC1CA,EAAO,eAAeuB,GAAQ,SAAS,KAAK1B,GACxC6B,IAAMJ,MAAcC,GAAQ,OAAO,IACnCI,IACJL,IAAYtB,EAAO,gBACnBA,EAAO,gBAAgBuB,GAAQ,UAAU,KAAK1B,GAE1C+B,IAAkBX,MAAY,UAAUC,MAAkB,kBAC1DW,IAAeZ,MAAY,UAAUC,MAAkB,kBAEvDnB,IAAS;AAAA,QACb,GAAGsB;AAAA,QACH,GAAGC;AAAA,QACH,YAAY;AAAA,UACV,MAAMD,IAAaX,EAAkB,QAAQ;AAAA,UAC7C,OAAOW,IAAaX,EAAkB,QAAQ;AAAA,UAC9C,KAAKY,IAAYZ,EAAkB,QAAQ;AAAA,UAC3C,QAAQY,IAAYZ,EAAkB,QAAQ;AAAA,QAAA;AAAA,QAEhD,SAAS;AAAA,UACP,MAAMmB,IAAeJ,IAAQD;AAAA,UAC7B,OAAOK,IAAeL,IAAOC;AAAA,UAC7B,KAAKG,IAAkBD,IAASD;AAAA,UAChC,QAAQE,IAAkBF,IAAMC;AAAA,QAAA;AAAA,MAClC;AAGF,MAAAjB,EAAkB,UAAU,EAAE,GAAGW,GAAY,GAAGC,EAAA,GAChDjB,EAAmB,SAAS,WAAWN,GAAQgB,CAAK;AAAA,IAAA;AAGtD,WAAAH,EAAQ,iBAAiB,UAAUI,CAAQ,GAC3CJ,EAAQ,iBAAiB,aAAaE,CAAW,GAE1C,MAAM;AACX,MAAAF,EAAQ,oBAAoB,UAAUI,CAAQ,GAC9CJ,EAAQ,oBAAoB,aAAaE,CAAW;AAAA,IAAA;AAAA,EACtD,GACC,CAACd,GAAQG,EAAY,KAAK,CAAC,GAE1BH,IAAeO,IACZ;AAAA,IACL,KAAKJ;AAAA,IACL,WAAAI;AAAA,EAAA;AAEJ;"}