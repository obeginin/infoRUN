import { useRef as I, useState as r, useEffect as J } from "react";
import { useRefState as K } from "../useRefState/useRefState.mjs";
import { isTarget as N } from "../../utils/helpers/isTarget.mjs";
import { getElement as O } from "../../utils/helpers/getElement.mjs";
const Q = (n) => {
  let a = [];
  for (let s = 0; s < n.length; ++s)
    a = [...a, [n.start(s), n.end(s)]];
  return a;
}, ae = (...n) => {
  const a = N(n[0]) ? n[0] : void 0, s = a ? typeof n[1] == "object" ? n[1] : { src: n[1] } : typeof n[0] == "object" ? n[0] : { src: n[0] }, i = K(), t = I(null), [c, o] = r(!1), [u, d] = r(0), [C, l] = r(0), [j, m] = r(!1), [D, W] = r(!1), [B, U] = r([]), [q, f] = r(!1), [z, v] = r(!1), [F, g] = r(1), [G, E] = r(!1), [H, L] = r(1);
  J(() => {
    const e = a ? O(a) : i.current;
    if (!e) return;
    t.current = e, e.src = s.src, s.type && e.setAttribute("type", s.type), s.media && e.setAttribute("media", s.media), d(e.duration), l(e.currentTime), o(!1), v(e.ended), E(e.muted), L(e.volume), g(e.playbackRate);
    const k = () => {
      o(!0), f(!1);
    }, h = () => o(!1), b = () => W(!0), R = () => f(!0), S = () => m(!0), T = () => m(!1), P = () => {
      o(!1), v(!0);
    }, M = () => d(e.duration), w = () => l(e.currentTime), V = () => {
      E(e.muted), L(e.volume);
    }, x = () => g(e.playbackRate), A = () => U(Q(e.buffered));
    return e.addEventListener("playing", k), e.addEventListener("pause", h), e.addEventListener("waiting", b), e.addEventListener("progress", A), e.addEventListener("stalled", R), e.addEventListener("seeking", S), e.addEventListener("seeked", T), e.addEventListener("ended", P), e.addEventListener("loadedmetadata", M), e.addEventListener("timeupdate", w), e.addEventListener("volumechange", V), e.addEventListener("ratechange", x), () => {
      e.removeEventListener("playing", k), e.removeEventListener("pause", h), e.removeEventListener("waiting", b), e.removeEventListener("progress", A), e.removeEventListener("stalled", R), e.removeEventListener("seeking", S), e.removeEventListener("seeked", T), e.removeEventListener("ended", P), e.removeEventListener("loadedmetadata", M), e.removeEventListener("timeupdate", w), e.removeEventListener("volumechange", V), e.removeEventListener("ratechange", x);
    };
  }, [a, i.state]);
  const p = async () => {
    const e = t.current;
    e && await e.play();
  }, y = () => {
    t.current && t.current.pause();
  };
  return {
    playing: c,
    duration: u,
    currentTime: C,
    seeking: j,
    waiting: D,
    buffered: B,
    stalled: q,
    ended: z,
    playbackRate: F,
    muted: G,
    volume: H,
    play: p,
    pause: y,
    toggle: async () => c ? y() : p(),
    seek: (e) => {
      t.current && (t.current.currentTime = Math.min(Math.max(e, 0), u));
    },
    changeVolume: (e) => {
      t.current && (t.current.volume = Math.min(Math.max(e, 0), 1));
    },
    mute: () => {
      t.current && (t.current.muted = !0);
    },
    unmute: () => {
      t.current && (t.current.muted = !1);
    },
    changePlaybackRate: (e) => {
      t.current && (t.current.playbackRate = e);
    },
    ...!a && { ref: i }
  };
};
export {
  Q as timeRangeToArray,
  ae as useMediaControls
};
//# sourceMappingURL=useMediaControls.mjs.map
