import { createContext as v, useRef as d, useMemo as f, startTransition as m, createElement as x, useContext as h, useState as C } from "react";
import { useIsomorphicLayoutEffect as l } from "../../hooks/useIsomorphicLayoutEffect/useIsomorphicLayoutEffect.mjs";
import { useEvent as P } from "../../hooks/useEvent/useEvent.mjs";
const S = (c) => (e) => {
  const t = d(e.value), n = f(
    () => ({
      value: t,
      listeners: /* @__PURE__ */ new Set()
    }),
    []
  );
  return l(() => {
    Object.is(t.current, e.value) || (t.current = e.value, m(() => {
      n.listeners.forEach((s) => {
        s(t.current);
      });
    }));
  }, [e.value]), x(c, { value: n }, e.children);
}, E = (c, r, e = {}) => {
  const t = h(c);
  if (!t && e.strict)
    throw new Error(`Context hook ${e.name} must be used inside a Provider`);
  const [n, s] = C({
    selected: r(t.value.current),
    value: t.value.current
  }), o = P((i) => {
    s((u) => {
      if (Object.is(u.value, i)) return u;
      const a = r(i);
      return Object.is(u.selected, a) ? u : { value: i, selected: a };
    });
  });
  return l(() => (t.listeners.add(o), () => {
    t.listeners.delete(o);
  }), [t.listeners]), n.selected;
}, w = (c = void 0, r = {}) => {
  const e = v({
    value: { current: c },
    listeners: /* @__PURE__ */ new Set()
  }), t = S(e.Provider);
  e.displayName = r.name;
  function n(s) {
    return E(
      e,
      s ?? ((o) => o),
      r
    );
  }
  return { instance: e, Provider: t, useSelector: n };
};
export {
  w as createReactiveContext
};
//# sourceMappingURL=createReactiveContext.mjs.map
