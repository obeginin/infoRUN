interface UseMutationOptions<Data> {
    retry?: ((failureCount: number, error: Error) => boolean) | boolean | number;
    retryDelay?: ((retry: number, error: Error) => number) | number;
    onError?: (error: Error) => void;
    onSuccess?: (data: Data) => void;
}
interface UseMutationReturn<Body, Data> {
    data: Data | null;
    error: Error | null;
    isError: boolean;
    isLoading: boolean;
    isSuccess: boolean;
    mutate: (body?: Body, options?: UseMutationOptions<Data>) => void;
    mutateAsync: (body?: Body, options?: UseMutationOptions<Data>) => Promise<Data>;
}
export interface RequestOptions<Data> extends UseMutationOptions<Data> {
    attempt?: number;
}
/**
 * @name useMutation
 * @description - Hook that defines the logic when mutate data
 * @category Async
 *
 * @template Body The type of the body
 * @template Data The type of the data
 * @param {(body: Body) => Promise<Data>} callback The callback function to be invoked
 * @param {boolean | number} [options.retry] The retry count of requests
 * @param {(data: Data) => void} [options.onSuccess] The callback function to be invoked on success
 * @param {(error: Error) => void} [options.onError] The callback function to be invoked on error
 * @returns {UseMutationReturn<Data>} An object with the state of the mutation
 *
 * @example
 * const { mutate, mutateAsync, isLoading, isError, isSuccess, error, data } = useMutation((name) => Promise.resolve(name));
 */
export declare const useMutation: <Body, Data>(callback: (body: Body) => Promise<Data>, options?: UseMutationOptions<Data>) => UseMutationReturn<Body, Data>;
export {};
