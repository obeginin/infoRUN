import { HookTarget } from '../../utils/helpers';
import { StateRef } from '../useRefState/useRefState';
/** The mutation observer target element type */
export type UseMutationObserverTarget = HookTarget;
/** The mutation observer return type */
export interface UseMutationObserverReturn {
    /** The mutation observer instance */
    observer: MutationObserver;
    /** The mutation observer entries */
    stop: () => void;
}
/** The mutation observer options type */
export interface UseMutationObserverOptions extends MutationObserverInit {
    /** The enabled state of the mutation observer */
    enabled?: boolean;
}
export interface UseMutationObserver {
    (target: HookTarget, callback: MutationCallback, options?: UseMutationObserverOptions): UseMutationObserverReturn;
    <Target extends Element>(callback: MutationCallback, options?: UseMutationObserverOptions, target?: never): UseMutationObserverReturn & {
        ref: StateRef<Target>;
    };
}
/**
 * @name useMutationObserver
 * @description - Hook that gives you mutation observer state
 * @category Sensors
 *
 * @overload
 * @template Target The target element
 * @param {MutationCallback} callback The callback to execute when mutation is detected
 * @param {boolean} [options.enabled=true] The enabled state of the mutation observer
 * @param {boolean} [options.attributes] Set to true if mutations to target's attributes are to be observed
 * @param {boolean} [options.characterData] Set to true if mutations to target's data are to be observed
 * @param {boolean} [options.childList] Set to true if mutations to target's children are to be observed
 * @param {boolean} [options.subtree]  Set to true if mutations to not just target, but also target's descendants are to be observed
 * @param {boolean} [options.characterDataOldValue] Set to true if characterData is set to true or omitted and target's data before the mutation needs to be recorded
 * @param {boolean} [options.attributeOldValue]  Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted
 * @param {string[]} [options.attributeFilter] Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted
 * @returns {UseMutationObserverReturn & { ref: StateRef<Target> }} An object containing the mutation observer state
 *
 * @example
 * const { ref, observer, stop } = useMutationObserver(() => console.log('callback'))
 *
 * @overload
 * @param {HookTarget} target The target element to observe
 * @param {MutationCallback} callback The callback to execute when mutation is detected
 * @param {boolean} [options.enabled=true] The enabled state of the mutation observer
 * @param {boolean} [options.attributes] Set to true if mutations to target's attributes are to be observed
 * @param {boolean} [options.characterData] Set to true if mutations to target's data are to be observed
 * @param {boolean} [options.childList] Set to true if mutations to target's children are to be observed
 * @param {boolean} [options.subtree]  Set to true if mutations to not just target, but also target's descendants are to be observed
 * @param {boolean} [options.characterDataOldValue] Set to true if characterData is set to true or omitted and target's data before the mutation needs to be recorded
 * @param {boolean} [options.attributeOldValue]  Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted
 * @param {string[]} [options.attributeFilter] Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted
 * @returns {UseMutationObserverReturn} An object containing the mutation observer state
 *
 * @example
 * const { observer, stop } = useMutationObserver(ref, () => console.log('callback'))
 */
export declare const useMutationObserver: UseMutationObserver;
