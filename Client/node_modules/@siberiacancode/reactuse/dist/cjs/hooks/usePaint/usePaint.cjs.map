{"version":3,"file":"usePaint.cjs","sources":["../../../../src/hooks/usePaint/usePaint.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useEvent } from '../useEvent/useEvent';\nimport { useRefState } from '../useRefState/useRefState';\n\nconst DEFAULT_BRUSH_RADIUS = 10;\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\nexport class Pointer implements Point {\n  x: number;\n\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  update(point: Point) {\n    this.x = point.x;\n    this.y = point.y;\n  }\n\n  getDifferenceTo(point: Point) {\n    return new Pointer(this.x - point.x, this.y - point.y);\n  }\n\n  getDistanceTo(point: Point) {\n    const diff = this.getDifferenceTo(point);\n    return Math.sqrt(diff.x ** 2 + diff.y ** 2);\n  }\n\n  getAngleTo(point: Point) {\n    const diff = this.getDifferenceTo(point);\n    return Math.atan2(diff.y, diff.x);\n  }\n\n  equalsTo(point: Point) {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  moveByAngle(\n    // The angle in radians\n    angle: number,\n    // How much the point should be moved\n    distance: number\n  ) {\n    // Rotate the angle based on the browser coordinate system ([0,0] in the top left)\n    const angleRotated = angle + Math.PI / 2;\n\n    this.x += Math.sin(angleRotated) * distance;\n    this.y -= Math.cos(angleRotated) * distance;\n\n    return this;\n  }\n}\n\nexport class Paint {\n  pointer: Pointer;\n\n  brush: Pointer;\n\n  radius: number;\n\n  smooth: boolean = false;\n\n  points: Point[] = [];\n\n  lines: { points: Point[]; color: string; radius: number; opacity: number }[] = [];\n\n  constructor({ x, y, radius, smooth }: { x: number; y: number; radius: number; smooth: boolean }) {\n    this.smooth = smooth;\n    this.pointer = new Pointer(x, y);\n    this.brush = new Pointer(x, y);\n    this.radius = radius;\n    this.points = [];\n    this.lines = [];\n  }\n\n  getBrushCoordinates() {\n    return {\n      x: this.brush.x,\n      y: this.brush.y\n    };\n  }\n\n  getPointerCoordinates() {\n    return {\n      x: this.pointer.x,\n      y: this.pointer.y\n    };\n  }\n\n  update(point: Point) {\n    if (this.pointer.equalsTo(point)) return false;\n    this.pointer.update(point);\n\n    if (!this.smooth) {\n      this.brush.update(point);\n      this.points.push(this.getBrushCoordinates());\n      return true;\n    }\n\n    const distance = this.pointer.getDistanceTo(this.brush);\n    const angle = this.pointer.getAngleTo(this.brush);\n    const isOutside = Math.round((distance - this.radius) * 10) / 10 > 0;\n\n    if (isOutside) {\n      const angleRotated = angle + Math.PI / 2;\n      this.brush.update({\n        x: this.brush.x + Math.sin(angleRotated) * (distance - this.radius),\n        y: this.brush.y - Math.cos(angleRotated) * (distance - this.radius)\n      });\n      this.points.push(this.getBrushCoordinates());\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport interface UsePaintOptions {\n  /** Brush color */\n  color?: string;\n  /** Initial lines */\n  initialLines?: Paint['lines'];\n  /** Brush opacity */\n  opacity?: number;\n  /** Brush radius */\n  radius?: number;\n  /** Smooth brush movement */\n  smooth?: boolean;\n  /** Callback when the mouse is down */\n  onMouseDown?: (event: MouseEvent, paint: Paint) => void;\n  /** Callback when the mouse is moved */\n  onMouseMove?: (event: MouseEvent, paint: Paint) => void;\n  /** Callback when the mouse is up */\n  onMouseUp?: (event: MouseEvent, paint: Paint) => void;\n}\n\nexport interface UsePaintReturn {\n  drawing: boolean;\n  lines: Paint['lines'];\n  clear: () => void;\n  draw: (points: Point[], color: string, opacity: number, radius: number) => void;\n  undo: () => void;\n}\n\nexport interface UsePaint {\n  (target: HookTarget, options?: UsePaintOptions): UsePaintReturn;\n\n  <Target extends HTMLCanvasElement>(\n    options?: UsePaintOptions,\n    target?: never\n  ): UsePaintReturn & { ref: StateRef<Target> };\n}\n\n/**\n * @name usePaint\n * @description - Hook that allows you to draw in a specific area\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to be painted\n * @param {UsePaintOptions} [options] The options to be used\n * @returns {UsePaintReturn} An object containing the current pencil options and functions to interact with the paint\n *\n * @example\n * const drawing = usePaint(canvasRef);\n *\n * @overload\n * @param {UsePaintOptions} [options] The options to be used\n * @returns {UsePaintReturn & { ref: StateRef<HTMLCanvasElement> }} An object containing the current pencil options and functions to interact with the paint\n *\n * @example\n * const { ref, drawing } = usePaint();\n */\nexport const usePaint = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = ((target ? params[1] : params[0]) as UsePaintOptions) ?? {};\n\n  const color = options?.color ?? 'black';\n  const opacity = options?.opacity ?? 1;\n  const radius = options?.radius ?? DEFAULT_BRUSH_RADIUS;\n\n  const paintRef = useRef<Paint>(\n    new Paint({\n      x: 0,\n      y: 0,\n      radius: options?.radius ?? DEFAULT_BRUSH_RADIUS,\n      smooth: options?.smooth ?? false\n    })\n  );\n  const [drawing, setIsDrawing] = useState(false);\n  const internalRef = useRefState<HTMLCanvasElement>();\n  const contextRef = useRef<CanvasRenderingContext2D | null>(null);\n\n  const draw = (points: Point[], color: string, opacity: number, radius: number) => {\n    if (!contextRef.current) return;\n\n    contextRef.current.globalAlpha = opacity;\n    contextRef.current.strokeStyle = color;\n    contextRef.current.lineWidth = radius * 2;\n    contextRef.current.lineCap = 'round';\n    contextRef.current.lineJoin = 'round';\n\n    let p1 = points[0];\n    let p2 = points[1];\n\n    contextRef.current.beginPath();\n\n    for (let i = 1; i < points.length; i += 1) {\n      const midPoint = {\n        x: p1.x + (p2.x - p1.x) / 2,\n        y: p1.y + (p2.y - p1.y) / 2\n      };\n      contextRef.current.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n      p1 = points[i];\n      p2 = points[i + 1];\n    }\n    contextRef.current.lineTo(p1.x, p1.y);\n    contextRef.current.stroke();\n  };\n\n  const clearCanvas = () => {\n    if (!contextRef.current) return;\n    contextRef.current.clearRect(\n      0,\n      0,\n      contextRef.current.canvas.width,\n      contextRef.current.canvas.height\n    );\n  };\n\n  const onMouseMove = useEvent((event: MouseEvent) => {\n    if (!drawing) return;\n    options?.onMouseMove?.(event, paintRef.current);\n\n    const point = { x: event.offsetX, y: event.offsetY };\n\n    const isUpdated = paintRef.current.update(point);\n\n    if (!isUpdated) return;\n    if (!contextRef.current) return;\n    clearCanvas();\n    contextRef.current.clearRect(\n      0,\n      0,\n      contextRef.current.canvas.width,\n      contextRef.current.canvas.height\n    );\n\n    // const brush = paintRef.current.getBrushCoordinates();\n    // // Draw brush point\n    // contextRef.current.beginPath();\n    // contextRef.current.fillStyle = 'red';\n    // contextRef.current.arc(brush.x, brush.y, radius, 0, Math.PI * 2, true);\n    // contextRef.current.fill();\n\n    // // Draw the lazy radius.\n    // contextRef.current.beginPath();\n    // contextRef.current.strokeStyle = '#ccc';\n    // contextRef.current.arc(brush.x, brush.y, radius * 2, 0, Math.PI * 2, true);\n    // contextRef.current.stroke();\n\n    paintRef.current.lines.forEach(({ points, color, opacity, radius }) =>\n      draw(points, color, opacity, radius)\n    );\n    draw(paintRef.current.points, color, opacity, radius);\n  });\n\n  const onMouseDown = useEvent((event: MouseEvent) => {\n    if (!contextRef.current) return;\n\n    const point = { x: event.offsetX, y: event.offsetY };\n    paintRef.current.brush.update(point);\n    paintRef.current.points.push(point);\n    draw(paintRef.current.points, color, opacity, radius);\n\n    options?.onMouseDown?.(event, paintRef.current);\n    setIsDrawing(true);\n  });\n\n  const onMouseUp = useEvent((event: MouseEvent) => {\n    if (!contextRef.current) return;\n\n    if (paintRef.current.points.length) {\n      paintRef.current.lines.push({\n        points: paintRef.current.points,\n        color,\n        opacity,\n        radius\n      });\n      paintRef.current.points = [];\n    }\n\n    options?.onMouseUp?.(event, paintRef.current);\n    setIsDrawing(false);\n  });\n\n  const clear = () => {\n    if (!contextRef.current) return;\n    clearCanvas();\n    paintRef.current.lines = [];\n    paintRef.current.points = [];\n  };\n\n  const undo = () => {\n    if (!contextRef.current) return;\n    clearCanvas();\n\n    paintRef.current.lines.pop();\n    paintRef.current.lines.forEach(({ points, color, opacity, radius }) =>\n      draw(points, color, opacity, radius)\n    );\n  };\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as HTMLCanvasElement;\n    if (!element) return;\n    contextRef.current = element.getContext('2d');\n\n    if (options?.initialLines) {\n      paintRef.current.lines = options.initialLines;\n      options.initialLines.forEach(({ points, color, opacity, radius }) =>\n        draw(points, color, opacity, radius)\n      );\n    }\n\n    element.addEventListener('mousedown', onMouseDown);\n    element.addEventListener('mousemove', onMouseMove);\n    element.addEventListener('mouseup', onMouseUp);\n\n    return () => {\n      if (!element) return;\n      element.removeEventListener('mousedown', onMouseDown);\n      element.removeEventListener('mousemove', onMouseMove);\n      element.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return { drawing, clear, undo, draw, lines: paintRef.current.lines };\n  return {\n    ref: internalRef,\n    drawing,\n    clear,\n    undo,\n    draw,\n    lines: paintRef.current.lines\n  };\n}) as UsePaint;\n"],"names":["DEFAULT_BRUSH_RADIUS","Pointer","x","y","point","diff","angle","distance","angleRotated","Paint","radius","smooth","usePaint","params","target","isTarget","options","color","opacity","paintRef","useRef","drawing","setIsDrawing","useState","internalRef","useRefState","contextRef","draw","points","p1","p2","i","midPoint","clearCanvas","onMouseMove","useEvent","event","onMouseDown","onMouseUp","clear","undo","useEffect","element","getElement"],"mappings":"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"}