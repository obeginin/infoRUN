"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const v=require("react"),E=require("../useEvent/useEvent.cjs"),S=require("../useRefState/useRefState.cjs"),U=require("../../utils/helpers/isTarget.cjs"),A=require("../../utils/helpers/getElement.cjs"),q=10;class g{x;y;constructor(t,e){this.x=t,this.y=e}update(t){this.x=t.x,this.y=t.y}getDifferenceTo(t){return new g(this.x-t.x,this.y-t.y)}getDistanceTo(t){const e=this.getDifferenceTo(t);return Math.sqrt(e.x**2+e.y**2)}getAngleTo(t){const e=this.getDifferenceTo(t);return Math.atan2(e.y,e.x)}equalsTo(t){return this.x===t.x&&this.y===t.y}moveByAngle(t,e){const o=t+Math.PI/2;return this.x+=Math.sin(o)*e,this.y-=Math.cos(o)*e,this}}class C{pointer;brush;radius;smooth=!1;points=[];lines=[];constructor({x:t,y:e,radius:o,smooth:h}){this.smooth=h,this.pointer=new g(t,e),this.brush=new g(t,e),this.radius=o,this.points=[],this.lines=[]}getBrushCoordinates(){return{x:this.brush.x,y:this.brush.y}}getPointerCoordinates(){return{x:this.pointer.x,y:this.pointer.y}}update(t){if(this.pointer.equalsTo(t))return!1;if(this.pointer.update(t),!this.smooth)return this.brush.update(t),this.points.push(this.getBrushCoordinates()),!0;const e=this.pointer.getDistanceTo(this.brush),o=this.pointer.getAngleTo(this.brush);if(Math.round((e-this.radius)*10)/10>0){const l=o+Math.PI/2;return this.brush.update({x:this.brush.x+Math.sin(l)*(e-this.radius),y:this.brush.y-Math.cos(l)*(e-this.radius)}),this.points.push(this.getBrushCoordinates()),!0}return!1}}const B=(...p)=>{const t=U.isTarget(p[0])?p[0]:void 0,e=(t?p[1]:p[0])??{},o=e?.color??"black",h=e?.opacity??1,l=e?.radius??q,s=v.useRef(new C({x:0,y:0,radius:e?.radius??q,smooth:e?.smooth??!1})),[m,b]=v.useState(!1),x=S.useRefState(),n=v.useRef(null),c=(r,u,f,a)=>{if(!n.current)return;n.current.globalAlpha=f,n.current.strokeStyle=u,n.current.lineWidth=a*2,n.current.lineCap="round",n.current.lineJoin="round";let i=r[0],y=r[1];n.current.beginPath();for(let d=1;d<r.length;d+=1){const L={x:i.x+(y.x-i.x)/2,y:i.y+(y.y-i.y)/2};n.current.quadraticCurveTo(i.x,i.y,L.x,L.y),i=r[d],y=r[d+1]}n.current.lineTo(i.x,i.y),n.current.stroke()},M=()=>{n.current&&n.current.clearRect(0,0,n.current.canvas.width,n.current.canvas.height)},T=E.useEvent(r=>{if(!m)return;e?.onMouseMove?.(r,s.current);const u={x:r.offsetX,y:r.offsetY};s.current.update(u)&&n.current&&(M(),n.current.clearRect(0,0,n.current.canvas.width,n.current.canvas.height),s.current.lines.forEach(({points:a,color:i,opacity:y,radius:d})=>c(a,i,y,d)),c(s.current.points,o,h,l))}),w=E.useEvent(r=>{if(!n.current)return;const u={x:r.offsetX,y:r.offsetY};s.current.brush.update(u),s.current.points.push(u),c(s.current.points,o,h,l),e?.onMouseDown?.(r,s.current),b(!0)}),R=E.useEvent(r=>{n.current&&(s.current.points.length&&(s.current.lines.push({points:s.current.points,color:o,opacity:h,radius:l}),s.current.points=[]),e?.onMouseUp?.(r,s.current),b(!1))}),P=()=>{n.current&&(M(),s.current.lines=[],s.current.points=[])},D=()=>{n.current&&(M(),s.current.lines.pop(),s.current.lines.forEach(({points:r,color:u,opacity:f,radius:a})=>c(r,u,f,a)))};return v.useEffect(()=>{if(!t&&!x.state)return;const r=t?A.getElement(t):x.current;if(r)return n.current=r.getContext("2d"),e?.initialLines&&(s.current.lines=e.initialLines,e.initialLines.forEach(({points:u,color:f,opacity:a,radius:i})=>c(u,f,a,i))),r.addEventListener("mousedown",w),r.addEventListener("mousemove",T),r.addEventListener("mouseup",R),()=>{r&&(r.removeEventListener("mousedown",w),r.removeEventListener("mousemove",T),r.removeEventListener("mouseup",R))}},[t,x.state]),t?{drawing:m,clear:P,undo:D,draw:c,lines:s.current.lines}:{ref:x,drawing:m,clear:P,undo:D,draw:c,lines:s.current.lines}};exports.Paint=C;exports.Pointer=g;exports.usePaint=B;
//# sourceMappingURL=usePaint.cjs.map
