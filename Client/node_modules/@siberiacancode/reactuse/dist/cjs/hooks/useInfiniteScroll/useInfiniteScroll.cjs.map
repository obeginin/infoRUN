{"version":3,"file":"useInfiniteScroll.cjs","sources":["../../../../src/hooks/useInfiniteScroll/useInfiniteScroll.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use infinite scroll options type */\nexport interface UseInfiniteScrollOptions {\n  /** The direction to trigger the callback */\n  direction?: 'bottom' | 'left' | 'right' | 'top';\n  /** The distance in pixels to trigger the callback */\n  distance?: number;\n}\n\nexport interface UseInfiniteScroll {\n  (\n    target: HookTarget,\n    callback: (event: Event) => void,\n    options?: UseInfiniteScrollOptions\n  ): boolean;\n\n  <Target extends Element>(\n    callback: (event: Event) => void,\n    options?: UseInfiniteScrollOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n    loading: boolean;\n  };\n}\n\n/**\n * @name useInfiniteScroll\n * @description - Hook that defines the logic for infinite scroll\n * @category Sensors\n *\n * @overload\n * @template Target The target element\n * @param {(event: Event) => void} callback The callback to execute when a click outside the target is detected\n * @param {number} [options.distance=10] The distance in pixels to trigger the callback\n * @param {string} [options.direction='bottom'] The direction to trigger the callback\n * @returns {{ ref: StateRef<Target>, loading: boolean }} An object containing the ref and loading\n *\n * @example\n * const { ref, loading } = useInfiniteScroll(() => console.log('infinite scroll'));\n *\n * @overload\n * @param {HookTarget} target The target element to detect infinite scroll for\n * @param {(event: Event) => void} callback The callback to execute when a click outside the target is detected\n * @param {number} [options.distance=10] The distance in pixels to trigger the callback\n * @param {string} [options.direction='bottom'] The direction to trigger the callback\n * @returns {boolean} A loading indicator of the infinite scroll\n *\n * @example\n * const loading = useInfiniteScroll(ref, () => console.log('infinite scroll'));\n */\nexport const useInfiniteScroll = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const callback = (target ? params[1] : params[0]) as (event: Event) => void;\n  const options = (target ? params[2] : params[1]) as UseInfiniteScrollOptions | undefined;\n\n  const direction = options?.direction ?? 'bottom';\n  const distance = options?.distance ?? 10;\n\n  const [loading, setIsLoading] = useState(false);\n\n  const internalRef = useRefState<Element>();\n  const internalCallbackRef = useRef(callback);\n  internalCallbackRef.current = callback;\n  const internalLoadingRef = useRef(loading);\n  internalLoadingRef.current = loading;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    const onLoadMore = async (event: Event) => {\n      if (internalLoadingRef.current) return;\n\n      const { clientHeight, scrollHeight, scrollTop, clientWidth, scrollWidth, scrollLeft } =\n        event.target as Element;\n      const scrollBottom = scrollHeight - (scrollTop + clientHeight);\n      const scrollRight = scrollWidth - (scrollLeft + clientWidth);\n\n      const distances = {\n        bottom: scrollBottom,\n        top: scrollTop,\n        right: scrollRight,\n        left: scrollLeft\n      };\n\n      if (distances[direction] <= distance) {\n        setIsLoading(true);\n        await internalCallbackRef.current(event);\n        setIsLoading(false);\n      }\n    };\n\n    element.addEventListener('scroll', onLoadMore);\n\n    return () => {\n      element.removeEventListener('scroll', onLoadMore);\n    };\n  }, [target, internalRef.state, direction, distance]);\n\n  if (target) return loading;\n  return {\n    ref: internalRef,\n    loading\n  };\n}) as UseInfiniteScroll;\n"],"names":["useInfiniteScroll","params","target","isTarget","callback","options","direction","distance","loading","setIsLoading","useState","internalRef","useRefState","internalCallbackRef","useRef","internalLoadingRef","useEffect","element","getElement","onLoadMore","event","clientHeight","scrollHeight","scrollTop","clientWidth","scrollWidth","scrollLeft","scrollBottom","scrollRight"],"mappings":"mPA4DaA,EAAqB,IAAIC,IAAkB,CACtD,MAAMC,EAAUC,EAAAA,SAASF,EAAO,CAAC,CAAC,EAAIA,EAAO,CAAC,EAAI,OAC5CG,EAAYF,EAASD,EAAO,CAAC,EAAIA,EAAO,CAAC,EACzCI,EAAWH,EAASD,EAAO,CAAC,EAAIA,EAAO,CAAC,EAExCK,EAAYD,GAAS,WAAa,SAClCE,EAAWF,GAAS,UAAY,GAEhC,CAACG,EAASC,CAAY,EAAIC,EAAAA,SAAS,EAAK,EAExCC,EAAcC,EAAAA,YAAA,EACdC,EAAsBC,EAAAA,OAAOV,CAAQ,EAC3CS,EAAoB,QAAUT,EAC9B,MAAMW,EAAqBD,EAAAA,OAAON,CAAO,EAqCzC,OApCAO,EAAmB,QAAUP,EAE7BQ,EAAAA,UAAU,IAAM,CACd,GAAI,CAACd,GAAU,CAACS,EAAY,MAAO,OACnC,MAAMM,EAAWf,EAASgB,EAAAA,WAAWhB,CAAM,EAAIS,EAAY,QAC3D,GAAI,CAACM,EAAS,OAEd,MAAME,EAAa,MAAOC,GAAiB,CACzC,GAAIL,EAAmB,QAAS,OAEhC,KAAM,CAAE,aAAAM,EAAc,aAAAC,EAAc,UAAAC,EAAW,YAAAC,EAAa,YAAAC,EAAa,WAAAC,GACvEN,EAAM,OACFO,EAAeL,GAAgBC,EAAYF,GAC3CO,EAAcH,GAAeC,EAAaF,IAE9B,CAChB,OAAQG,EACR,IAAKJ,EACL,MAAOK,EACP,KAAMF,CAAA,GAGMpB,CAAS,GAAKC,IAC1BE,EAAa,EAAI,EACjB,MAAMI,EAAoB,QAAQO,CAAK,EACvCX,EAAa,EAAK,EACpB,EAGF,OAAAQ,EAAQ,iBAAiB,SAAUE,CAAU,EAEtC,IAAM,CACXF,EAAQ,oBAAoB,SAAUE,CAAU,CAAA,CAClD,EACC,CAACjB,EAAQS,EAAY,MAAOL,EAAWC,CAAQ,CAAC,EAE/CL,EAAeM,EACZ,CACL,IAAKG,EACL,QAAAH,CAAA,CAEJ"}