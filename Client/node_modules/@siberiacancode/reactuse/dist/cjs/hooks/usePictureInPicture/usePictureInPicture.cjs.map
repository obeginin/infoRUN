{"version":3,"file":"usePictureInPicture.cjs","sources":["../../../../src/hooks/usePictureInPicture/usePictureInPicture.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use picture in picture options type */\nexport interface UsePictureInPictureOptions {\n  /** The callback when Picture-in-Picture mode is entered */\n  onEnter?: () => void;\n  /** The callback when Picture-in-Picture mode is exited */\n  onExit?: () => void;\n}\n\n/** The use picture in picture return type */\nexport interface UsePictureInPictureReturn {\n  /** Whether Picture-in-Picture mode is currently active */\n  open: boolean;\n  /** Whether Picture-in-Picture mode is supported by the browser */\n  supported: boolean;\n  /** Request to enter Picture-in-Picture mode */\n  enter: () => Promise<void>;\n  /** Request to exit Picture-in-Picture mode */\n  exit: () => Promise<void>;\n  /** Toggle Picture-in-Picture mode */\n  toggle: () => Promise<void>;\n}\n\nexport interface UsePictureInPicture {\n  (target: HookTarget, options?: UsePictureInPictureOptions): UsePictureInPictureReturn;\n\n  (options?: UsePictureInPictureOptions): UsePictureInPictureReturn & {\n    ref: StateRef<HTMLVideoElement>;\n  };\n}\n\n/**\n * @name usePictureInPicture\n * @description - Hook that provides Picture-in-Picture functionality for video elements\n * @category Browser\n *\n * @browserapi window.PictureInPicture https://developer.mozilla.org/en-US/docs/Web/API/Picture-in-Picture_API\n *\n * @overload\n * @param {HookTarget} target The target video element\n * @param {() => void} [options.onEnter] Callback when Picture-in-Picture mode is entered\n * @param {() => void} [options.onExit] Callback when Picture-in-Picture mode is exited\n * @returns {UsePictureInPictureReturn} An object containing Picture-in-Picture state and controls\n *\n * @example\n * const { open, supported, enter, exit, toggle } = usePictureInPicture(videoRef);\n *\n * @overload\n * @param {() => void} [options.onEnter] Callback when Picture-in-Picture mode is entered\n * @param {() => void} [options.onExit] Callback when Picture-in-Picture mode is exited\n * @returns {UsePictureInPictureReturn & { ref: StateRef<HTMLVideoElement> }} An object containing Picture-in-Picture state, controls and ref\n *\n * @example\n * const { ref, open, supported, enter, exit, toggle } = usePictureInPicture();\n */\nexport const usePictureInPicture = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = ((target ? params[1] : params[0]) as UsePictureInPictureOptions) ?? {};\n\n  const [open, setOpen] = useState(false);\n\n  const internalRef = useRefState<HTMLVideoElement>();\n  const elementRef = useRef<HTMLVideoElement>(null);\n  const onOptionsRef = useRef<UsePictureInPictureOptions>(options);\n  onOptionsRef.current = options;\n\n  const supported = typeof document !== 'undefined' && 'pictureInPictureEnabled' in document;\n\n  const enter = async () => {\n    if (!supported) return;\n\n    if (!elementRef.current) return;\n\n    await elementRef.current.requestPictureInPicture();\n    setOpen(true);\n\n    options.onEnter?.();\n  };\n\n  const exit = async () => {\n    if (!supported) return;\n\n    await document.exitPictureInPicture();\n    setOpen(false);\n    options.onExit?.();\n  };\n\n  useEffect(() => {\n    const element = target ? (getElement(target) as HTMLVideoElement) : internalRef.current;\n    if (!element) return;\n\n    elementRef.current = element;\n\n    const onEnterPictureInPicture = () => {\n      setOpen(true);\n      onOptionsRef.current.onEnter?.();\n    };\n\n    const onLeavePictureInPicture = () => {\n      setOpen(false);\n      onOptionsRef.current.onExit?.();\n    };\n\n    element.addEventListener('enterpictureinpicture', onEnterPictureInPicture);\n    element.addEventListener('leavepictureinpicture', onLeavePictureInPicture);\n\n    return () => {\n      element.removeEventListener('enterpictureinpicture', onEnterPictureInPicture);\n      element.removeEventListener('leavepictureinpicture', onLeavePictureInPicture);\n    };\n  }, [target]);\n\n  const toggle = async () => {\n    if (open) await exit();\n    else await enter();\n  };\n\n  const value = {\n    open,\n    supported,\n    enter,\n    exit,\n    toggle\n  };\n\n  if (target) return value;\n  return { ...value, ref: internalRef };\n}) as UsePictureInPicture;\n"],"names":["usePictureInPicture","params","target","isTarget","options","open","setOpen","useState","internalRef","useRefState","elementRef","useRef","onOptionsRef","supported","enter","exit","useEffect","element","getElement","onEnterPictureInPicture","onLeavePictureInPicture","value"],"mappings":"mPAgEaA,EAAuB,IAAIC,IAAkB,CACxD,MAAMC,EAAUC,EAAAA,SAASF,EAAO,CAAC,CAAC,EAAIA,EAAO,CAAC,EAAI,OAC5CG,GAAYF,EAASD,EAAO,CAAC,EAAIA,EAAO,CAAC,IAAqC,CAAA,EAE9E,CAACI,EAAMC,CAAO,EAAIC,EAAAA,SAAS,EAAK,EAEhCC,EAAcC,EAAAA,YAAA,EACdC,EAAaC,EAAAA,OAAyB,IAAI,EAC1CC,EAAeD,EAAAA,OAAmCP,CAAO,EAC/DQ,EAAa,QAAUR,EAEvB,MAAMS,EAAY,OAAO,SAAa,KAAe,4BAA6B,SAE5EC,EAAQ,SAAY,CACnBD,GAEAH,EAAW,UAEhB,MAAMA,EAAW,QAAQ,wBAAA,EACzBJ,EAAQ,EAAI,EAEZF,EAAQ,UAAA,EAAU,EAGdW,EAAO,SAAY,CAClBF,IAEL,MAAM,SAAS,qBAAA,EACfP,EAAQ,EAAK,EACbF,EAAQ,SAAA,EAAS,EAGnBY,EAAAA,UAAU,IAAM,CACd,MAAMC,EAAUf,EAAUgB,EAAAA,WAAWhB,CAAM,EAAyBM,EAAY,QAChF,GAAI,CAACS,EAAS,OAEdP,EAAW,QAAUO,EAErB,MAAME,EAA0B,IAAM,CACpCb,EAAQ,EAAI,EACZM,EAAa,QAAQ,UAAA,CAAU,EAG3BQ,EAA0B,IAAM,CACpCd,EAAQ,EAAK,EACbM,EAAa,QAAQ,SAAA,CAAS,EAGhC,OAAAK,EAAQ,iBAAiB,wBAAyBE,CAAuB,EACzEF,EAAQ,iBAAiB,wBAAyBG,CAAuB,EAElE,IAAM,CACXH,EAAQ,oBAAoB,wBAAyBE,CAAuB,EAC5EF,EAAQ,oBAAoB,wBAAyBG,CAAuB,CAAA,CAC9E,EACC,CAAClB,CAAM,CAAC,EAOX,MAAMmB,EAAQ,CACZ,KAAAhB,EACA,UAAAQ,EACA,MAAAC,EACA,KAAAC,EACA,OAVa,SAAY,CACrBV,QAAYU,EAAA,QACLD,EAAA,CAAM,CAQjB,EAGF,OAAIZ,EAAemB,EACZ,CAAE,GAAGA,EAAO,IAAKb,CAAA,CAC1B"}