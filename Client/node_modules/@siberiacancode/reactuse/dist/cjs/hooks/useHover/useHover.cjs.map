{"version":3,"file":"useHover.cjs","sources":["../../../../src/hooks/useHover/useHover.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use hover options type */\nexport interface UseHoverOptions {\n  /** The on entry callback */\n  onEntry?: (event: Event) => void;\n  /** The on leave callback */\n  onLeave?: (event: Event) => void;\n}\n\nexport interface UseHoverReturn {\n  value: boolean;\n}\n\nexport interface UseHover {\n  (target: HookTarget, callback?: (event: Event) => void): boolean;\n\n  (target: HookTarget, options?: UseHoverOptions): boolean;\n\n  <Target extends Element>(\n    callback?: (event: Event) => void,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n  } & UseHoverReturn;\n\n  <Target extends Element>(\n    options?: UseHoverOptions,\n    target?: never\n  ): {\n    ref: StateRef<Target>;\n  } & UseHoverReturn;\n}\n\n/**\n * @name useHover\n * @description - Hook that defines the logic when hovering an element\n * @category Elements\n *\n * @overload\n * @param {HookTarget} target The target element to be hovered\n * @param {(event: Event) => void} [callback] The callback function to be invoked on mouse enter\n * @returns {boolean} The state of the hover\n *\n * @example\n * const hovering = useHover(ref, () => console.log('callback'));\n *\n * @overload\n * @param {HookTarget} target The target element to be hovered\n * @param {(event: Event) => void} [options.onEntry] The callback function to be invoked on mouse enter\n * @param {(event: Event) => void} [options.onLeave] The callback function to be invoked on mouse leave\n * @returns {boolean} The state of the hover\n *\n * @example\n * const hovering = useHover(ref, options);\n *\n * @overload\n * @template Target The target element\n * @param {(event: Event) => void} [callback] The callback function to be invoked on mouse enter\n * @returns {{ ref: StateRef<Target> } & UseHoverReturn} The state of the hover\n *\n * @example\n * const [ref, hovering] = useHover(() => console.log('callback'));\n *\n * @overload\n * @template Target The target element\n * @param {(event: Event) => void} [options.onEntry] The callback function to be invoked on mouse enter\n * @param {(event: Event) => void} [options.onLeave] The callback function to be invoked on mouse leave\n * @returns {{ ref: StateRef<Target> } & UseHoverReturn} The state of the hover\n *\n * @example\n * const [ref, hovering] = useHover(options);\n */\nexport const useHover = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n\n  const options = (\n    target\n      ? typeof params[1] === 'object'\n        ? params[1]\n        : { onEntry: params[1] }\n      : typeof params[0] === 'object'\n        ? params[0]\n        : { onEntry: params[0] }\n  ) as UseHoverOptions | undefined;\n\n  const [hovering, setHovering] = useState(false);\n  const internalRef = useRefState<Element>();\n  const internalOptionsRef = useRef(options);\n  internalOptionsRef.current = options;\n\n  useEffect(() => {\n    if (!target && !internalRef.state) return;\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n\n    if (!element) return;\n\n    const onMouseEnter = (event: Event) => {\n      internalOptionsRef.current?.onEntry?.(event);\n      setHovering(true);\n    };\n\n    const onMouseLeave = (event: Event) => {\n      internalOptionsRef.current?.onLeave?.(event);\n      setHovering(false);\n    };\n\n    element.addEventListener('mouseenter', onMouseEnter);\n    element.addEventListener('mouseleave', onMouseLeave);\n\n    return () => {\n      element.removeEventListener('mouseenter', onMouseEnter);\n      element.removeEventListener('mouseleave', onMouseLeave);\n    };\n  }, [target, internalRef.state]);\n\n  if (target) return hovering;\n  return {\n    ref: internalRef,\n    value: hovering\n  } as const;\n}) as UseHover;\n"],"names":["useHover","params","target","isTarget","options","hovering","setHovering","useState","internalRef","useRefState","internalOptionsRef","useRef","useEffect","element","getElement","onMouseEnter","event","onMouseLeave"],"mappings":"mPAiFaA,EAAY,IAAIC,IAAkB,CAC7C,MAAMC,EAAUC,EAAAA,SAASF,EAAO,CAAC,CAAC,EAAIA,EAAO,CAAC,EAAI,OAE5CG,EACJF,EACI,OAAOD,EAAO,CAAC,GAAM,SACnBA,EAAO,CAAC,EACR,CAAE,QAASA,EAAO,CAAC,CAAA,EACrB,OAAOA,EAAO,CAAC,GAAM,SACnBA,EAAO,CAAC,EACR,CAAE,QAASA,EAAO,CAAC,CAAA,EAGrB,CAACI,EAAUC,CAAW,EAAIC,EAAAA,SAAS,EAAK,EACxCC,EAAcC,EAAAA,YAAA,EACdC,EAAqBC,EAAAA,OAAOP,CAAO,EA4BzC,OA3BAM,EAAmB,QAAUN,EAE7BQ,EAAAA,UAAU,IAAM,CACd,GAAI,CAACV,GAAU,CAACM,EAAY,MAAO,OACnC,MAAMK,EAAWX,EAASY,EAAAA,WAAWZ,CAAM,EAAIM,EAAY,QAE3D,GAAI,CAACK,EAAS,OAEd,MAAME,EAAgBC,GAAiB,CACrCN,EAAmB,SAAS,UAAUM,CAAK,EAC3CV,EAAY,EAAI,CAAA,EAGZW,EAAgBD,GAAiB,CACrCN,EAAmB,SAAS,UAAUM,CAAK,EAC3CV,EAAY,EAAK,CAAA,EAGnB,OAAAO,EAAQ,iBAAiB,aAAcE,CAAY,EACnDF,EAAQ,iBAAiB,aAAcI,CAAY,EAE5C,IAAM,CACXJ,EAAQ,oBAAoB,aAAcE,CAAY,EACtDF,EAAQ,oBAAoB,aAAcI,CAAY,CAAA,CACxD,EACC,CAACf,EAAQM,EAAY,KAAK,CAAC,EAE1BN,EAAeG,EACZ,CACL,IAAKG,EACL,MAAOH,CAAA,CAEX"}