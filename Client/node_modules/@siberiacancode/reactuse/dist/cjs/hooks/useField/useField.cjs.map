{"version":3,"file":"useField.cjs","sources":["../../../../src/hooks/useField/useField.ts"],"sourcesContent":["import { useRef, useState } from 'react';\n\nimport { useRerender } from '../useRerender/useRerender';\n\n/** The use field params type */\nexport interface UseFieldParams<Value> {\n  /** The auto focus */\n  autoFocus?: boolean;\n  /** The initial touched */\n  initialTouched?: boolean;\n  /** The initial value */\n  initialValue?: Value;\n  /** The validate on blur */\n  validateOnBlur?: boolean;\n  /** The validate on mount */\n  validateOnChange?: boolean;\n  /** The validate on mount */\n  validateOnMount?: boolean;\n}\n\n/** The use field register params type */\nexport interface UseFieldRegisterParams {\n  /** The required validation */\n  required?: string;\n  /** The custom validation */\n  validate?: (value: string) => Promise<string | true>;\n  /** The min value validation */\n  max?: {\n    value: number;\n    message: string;\n  };\n  /** The max length validation */\n  maxLength?: {\n    value: number;\n    message: string;\n  };\n  /** The max value validation */\n  min?: {\n    value: number;\n    message: string;\n  };\n  /** The min length validation */\n  minLength?: {\n    value: number;\n    message: string;\n  };\n  /** The pattern validation */\n  pattern?: {\n    value: RegExp;\n    message: string;\n  };\n}\n\n/** The use field return type */\nexport interface UseFieldReturn<Value> {\n  /** The dirty state */\n  dirty: boolean;\n  /** The error state */\n  error?: string;\n  /** The set error function */\n  touched: boolean;\n  /** The set error function */\n  clearError: () => void;\n  /** The focus function */\n  focus: () => void;\n  /** The get value function */\n  getValue: () => Value;\n  /** The register function */\n  register: (params?: UseFieldRegisterParams) => {\n    onBlur: () => void;\n    onChange: () => void;\n    ref: (\n      node: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | null | undefined\n    ) => void;\n  };\n  /** The reset function */\n  reset: () => void;\n  /** The set error function */\n  setError: (error: string) => void;\n  /** The  set value function */\n  setValue: (value: Value) => void;\n  /** The watch function */\n  watch: () => Value;\n}\n\n/**\n * @name useField\n * @description - Hook to manage a form field\n * @category State\n *\n * @template Value The input value\n * @template Type The input value type\n * @param {Value} [params.initialValue] Initial value\n * @param {boolean} [params.initialTouched=false] Initial touched state\n * @param {boolean} [params.autoFocus=false] Auto focus\n * @param {boolean} [params.validateOnChange=false] Validate on change\n * @param {boolean} [params.validateOnBlur=false] Validate on blur\n * @param {boolean} [params.validateOnMount=false] Validate on mount\n * @returns {UseFieldReturn<Value>} An object containing input information\n *\n * @example\n * const { register, getValue, setValue, reset, dirty, error, setError, clearError, touched, focus, watch } = useField();\n */\nexport const useField = <\n  Value extends boolean | number | string = string,\n  Type = Value extends string ? string : Value extends boolean ? boolean : number\n>(\n  params?: UseFieldParams<Value>\n): UseFieldReturn<Type> => {\n  const initialValue = (params?.initialValue ?? '') as Value;\n\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const watchingRef = useRef(false);\n  const rerender = useRerender();\n\n  const [dirty, setDirty] = useState(false);\n  const [touched, setTouched] = useState(params?.initialTouched ?? false);\n  const [error, setError] = useState<string | undefined>(undefined);\n\n  const getValue = () => {\n    if (inputRef.current?.type === 'radio' || inputRef.current?.type === 'checkbox')\n      return inputRef.current.checked as Type;\n    return (inputRef.current?.value ?? initialValue) as Type;\n  };\n\n  const setValue = (value: Type) => {\n    if (inputRef.current?.type === 'radio' || inputRef.current?.type === 'checkbox') {\n      inputRef.current.checked = value as boolean;\n      if (watchingRef.current) return rerender();\n      return;\n    }\n\n    inputRef.current!.value = value as string;\n    if (watchingRef.current) return rerender();\n  };\n\n  const reset = () => {\n    setValue(initialValue as unknown as Type);\n    setDirty(false);\n    setTouched(false);\n    setError(undefined);\n  };\n\n  const focus = () => inputRef.current!.focus();\n\n  const validate = (params: UseFieldRegisterParams) => {\n    if (params.required && !inputRef.current!.value) {\n      return setError(params.required);\n    }\n\n    if (params.minLength && inputRef.current!.value.length < params.minLength.value) {\n      return setError(params.minLength.message);\n    }\n\n    if (params.maxLength && inputRef.current!.value.length > params.maxLength.value) {\n      return setError(params.maxLength.message);\n    }\n\n    if (params.min && Number(inputRef.current!.value) < params.min.value) {\n      return setError(params.min.message);\n    }\n\n    if (params.max && Number(inputRef.current!.value) > params.max.value) {\n      return setError(params.max.message);\n    }\n\n    if (params.pattern && !params.pattern.value.test(inputRef.current!.value)) {\n      return setError(params.pattern.message);\n    }\n\n    if (params.validate) {\n      const error = params.validate(inputRef.current!.value);\n      if (typeof error === 'string') return setError(error);\n    }\n\n    setError(undefined);\n  };\n\n  const register = (registerParams?: UseFieldRegisterParams) => ({\n    ref: (node: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | null | undefined) => {\n      if (!inputRef.current && node) {\n        if (params?.autoFocus) node.focus();\n        inputRef.current = node as HTMLInputElement;\n        if (inputRef.current.type === 'radio') {\n          inputRef.current.defaultChecked = params?.initialValue === node.value;\n          return;\n        }\n        if (inputRef.current.type === 'checkbox') {\n          inputRef.current.defaultChecked = !!params?.initialValue;\n          return;\n        }\n        inputRef.current.defaultValue = String(initialValue);\n\n        if (registerParams && params?.validateOnMount) validate(registerParams);\n      }\n    },\n    onChange: async () => {\n      if (watchingRef.current) return rerender();\n      if (inputRef.current!.value !== initialValue) setDirty(true);\n      if (dirty && inputRef.current!.value === initialValue) setDirty(false);\n      if (registerParams && params?.validateOnChange) await validate(registerParams);\n      if (registerParams && params?.validateOnBlur) setError(undefined);\n    },\n    onBlur: async () => {\n      if (registerParams && params?.validateOnBlur) await validate(registerParams);\n      setTouched(true);\n    }\n  });\n\n  const watch = () => {\n    watchingRef.current = true;\n    return getValue();\n  };\n\n  const clearError = () => setError(undefined);\n\n  return {\n    register,\n    dirty,\n    touched,\n    error,\n    setError,\n    clearError,\n    getValue,\n    setValue,\n    reset,\n    watch,\n    focus\n  };\n};\n"],"names":["useField","params","initialValue","inputRef","useRef","watchingRef","rerender","useRerender","dirty","setDirty","useState","touched","setTouched","error","setError","getValue","setValue","value","reset","focus","validate","registerParams","node"],"mappings":"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"}