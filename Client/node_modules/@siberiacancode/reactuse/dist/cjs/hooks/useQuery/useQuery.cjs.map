{"version":3,"file":"useQuery.cjs","sources":["../../../../src/hooks/useQuery/useQuery.ts"],"sourcesContent":["import type { DependencyList } from 'react';\n\nimport { useEffect, useRef, useState } from 'react';\n\nimport { getRetry } from '@/utils/helpers';\n\nimport { useDidUpdate } from '../useDidUpdate/useDidUpdate';\nimport { useMount } from '../useMount/useMount';\n\n/* The use query return type */\nexport interface UseQueryOptions<QueryData, Data> {\n  /* The enabled state of the query */\n  enabled?: boolean;\n  /* The depends for the hook */\n  keys?: DependencyList;\n  /* The placeholder data for the hook */\n  placeholderData?: (() => Data) | Data;\n  /* The refetch interval */\n  refetchInterval?: number;\n  /* The retry count of requests */\n  retry?: boolean | number;\n  /* The retry delay of requests */\n  retryDelay?: ((retry: number, error: Error) => number) | number;\n  /* The callback function to be invoked on error */\n  onError?: (error: Error) => void;\n  /* The callback function to be invoked on success */\n  onSuccess?: (data: Data) => void;\n  /* The select function to be invoked */\n  select?: (data: QueryData) => Data;\n}\n\ninterface UseQueryCallbackParams {\n  /* The depends for the hook */\n  keys: DependencyList;\n  /* The abort signal */\n  signal: AbortSignal;\n}\n\n/* The use query return type */\nexport interface UseQueryReturn<Data> {\n  /* The abort function */\n  abort: AbortController['abort'];\n  /* The state of the query */\n  data?: Data;\n  /* The success state of the query */\n  error?: Error;\n  /* The error state of the query */\n  isError: boolean;\n  /* The fetching state of the query */\n  isFetching: boolean;\n  /* The loading state of the query */\n  isLoading: boolean;\n  /* The refetching state of the query */\n  isRefetching: boolean;\n  /* The success state of the query */\n  isSuccess: boolean;\n  /* The refetch function */\n  refetch: () => void;\n}\n\n/**\n * @name useQuery\n * @description - Hook that defines the logic when query data\n * @category Async\n *\n * @template Data The type of the data\n * @param {() => Promise<Data>} callback The callback function to be invoked\n * @param {DependencyList} [options.keys] The dependencies for the hook\n * @param {(data: Data) => void} [options.onSuccess] The callback function to be invoked on success\n * @param {(error: Error) => void} [options.onError] The callback function to be invoked on error\n * @param {UseQueryOptionsSelect<Data>} [options.select] The select function to be invoked\n * @param {Data | (() => Data)} [options.initialData] The initial data for the hook\n * @param {Data | (() => Data)} [options.placeholderData] The placeholder data for the hook\n * @param {number} [options.refetchInterval] The refetch interval\n * @param {boolean | number} [options.retry] The retry count of requests\n * @returns {UseQueryReturn<Data>} An object with the state of the query\n *\n * @example\n * const { data, isFetching, isLoading, isError, isSuccess, error, refetch, isRefetching, abort, aborted } = useQuery(() => fetch('url'));\n */\nexport const useQuery = <QueryData, Data = QueryData>(\n  callback: (params: UseQueryCallbackParams) => Promise<QueryData>,\n  options?: UseQueryOptions<QueryData, Data>\n): UseQueryReturn<Data> => {\n  const enabled = options?.enabled ?? true;\n  const retryCountRef = useRef(options?.retry ? getRetry(options.retry) : 0);\n  const alreadyRequested = useRef(false);\n\n  const [isFetching, setIsFetching] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isError, setIsError] = useState(false);\n  const [isRefetching, setIsRefetching] = useState(false);\n  const [isSuccess, setIsSuccess] = useState(!!options?.placeholderData);\n\n  const [error, setError] = useState<Error | undefined>(undefined);\n  const [data, setData] = useState<Data | undefined>(options?.placeholderData);\n\n  const abortControllerRef = useRef<AbortController>(new AbortController());\n  const intervalIdRef = useRef<ReturnType<typeof setInterval>>(undefined);\n\n  const keys = options?.keys ?? [];\n\n  const abort = () => {\n    abortControllerRef.current.abort();\n    abortControllerRef.current = new AbortController();\n  };\n\n  const request = (action: 'init' | 'refetch') => {\n    abort();\n\n    setIsFetching(true);\n    if (action === 'init') {\n      alreadyRequested.current = true;\n      setIsLoading(true);\n    }\n    if (action === 'refetch') setIsRefetching(true);\n    callback({ signal: abortControllerRef.current.signal, keys })\n      .then((response) => {\n        const data = options?.select ? options?.select(response) : response;\n        options?.onSuccess?.(data as Data);\n        setData(data as Data);\n        setIsSuccess(true);\n        setError(undefined);\n        setIsError(false);\n        setIsFetching(false);\n        if (action === 'init') setIsLoading(false);\n        if (action === 'refetch') setIsRefetching(false);\n      })\n      .catch((error: Error) => {\n        if (retryCountRef.current > 0) {\n          retryCountRef.current -= 1;\n          const retryDelay =\n            typeof options?.retryDelay === 'function'\n              ? options?.retryDelay(retryCountRef.current, error)\n              : options?.retryDelay;\n\n          if (retryDelay) {\n            setTimeout(() => request(action), retryDelay);\n            return;\n          }\n\n          return request(action);\n        }\n        options?.onError?.(error);\n        setData(undefined);\n        setIsSuccess(false);\n        setError(error);\n        setIsError(true);\n        setIsFetching(false);\n        if (action === 'init') setIsLoading(false);\n        if (action === 'refetch') setIsRefetching(false);\n        retryCountRef.current = options?.retry ? getRetry(options.retry) : 0;\n      })\n      .finally(() => {\n        if (options?.refetchInterval) {\n          const interval = setInterval(() => {\n            clearInterval(interval);\n            request('refetch');\n          }, options?.refetchInterval);\n          intervalIdRef.current = interval;\n        }\n      });\n  };\n\n  useMount(() => {\n    if (!enabled) return;\n    request('init');\n  });\n\n  useDidUpdate(() => {\n    if (!enabled) return;\n    request(alreadyRequested.current ? 'refetch' : 'init');\n  }, [enabled, ...keys]);\n\n  useEffect(() => {\n    return () => {\n      clearInterval(intervalIdRef.current);\n    };\n  }, [enabled, options?.refetchInterval, options?.retry, ...keys]);\n\n  const refetch = () => request('refetch');\n\n  return {\n    abort,\n    data,\n    error,\n    refetch,\n    isFetching,\n    isLoading,\n    isError,\n    isSuccess,\n    isRefetching\n  };\n};\n"],"names":["useQuery","callback","options","enabled","retryCountRef","useRef","getRetry","alreadyRequested","isFetching","setIsFetching","useState","isLoading","setIsLoading","isError","setIsError","isRefetching","setIsRefetching","isSuccess","setIsSuccess","error","setError","data","setData","abortControllerRef","intervalIdRef","keys","abort","request","action","response","retryDelay","interval","useMount","useDidUpdate","useEffect"],"mappings":"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"}