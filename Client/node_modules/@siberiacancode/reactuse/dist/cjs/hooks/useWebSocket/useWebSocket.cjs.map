{"version":3,"file":"useWebSocket.cjs","sources":["../../../../src/hooks/useWebSocket/useWebSocket.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nimport { getRetry } from '@/utils/helpers';\n\nimport { useEvent } from '../useEvent/useEvent';\n\nexport type UseWebSocketUrl = (() => string) | string;\n\nexport interface UseWebSocketOptions {\n  protocols?: Array<'soap' | 'wasm'>;\n  retry?: boolean | number;\n  onConnected?: (webSocket: WebSocket) => void;\n  onDisconnected?: (event: CloseEvent, webSocket: WebSocket) => void;\n  onError?: (event: Event, webSocket: WebSocket) => void;\n  onMessage?: (event: MessageEvent, webSocket: WebSocket) => void;\n}\n\nexport type UseWebSocketStatus = 'connected' | 'connecting' | 'disconnected' | 'failed';\n\nexport interface UseWebSocketReturn {\n  client?: WebSocket;\n  close: WebSocket['close'];\n  send: WebSocket['send'];\n  status: UseWebSocketStatus;\n  open: () => void;\n}\n\n/**\n * @name useWebSocket\n * @description - Hook that connects to a WebSocket server and handles incoming and outgoing messages\n * @category Browser\n *\n * @param {UseWebSocketUrl} url The URL of the WebSocket server\n * @param {(webSocket: WebSocket) => void} [options.onConnected] The callback function that is called when the WebSocket connection is established\n * @param {(event: CloseEvent, webSocket: WebSocket) => void} [options.onDisconnected] The callback function that is called when the WebSocket connection is closed\n * @param {(event: Event, webSocket: WebSocket) => void} [options.onError] The callback function that is called when an error occurs\n * @param {(event: MessageEvent, webSocket: WebSocket) => void} [options.onMessage] The callback function that is called when a message is received\n * @param {boolean | number} [options.retry] The number of times to retry the connection\n * @param {Array<'soap' | 'wasm'>} [options.protocols] The list of protocols to use\n * @returns {UseWebSocketReturn} An object with the status, close, send, open, and ws properties\n *\n * @example\n * const { status, close, send, open, client } = useWebSocket('url');\n */\nexport const useWebSocket = (\n  url: UseWebSocketUrl,\n  options?: UseWebSocketOptions\n): UseWebSocketReturn => {\n  const webSocketRef = useRef<WebSocket>(undefined);\n  const retryCountRef = useRef(options?.retry ? getRetry(options.retry) : 0);\n  const explicityCloseRef = useRef(false);\n\n  const [status, setStatus] = useState<UseWebSocketStatus>('connecting');\n\n  const send = (data: string | ArrayBufferLike | ArrayBufferView | Blob) =>\n    webSocketRef.current?.send(data);\n\n  const close = () => {\n    explicityCloseRef.current = true;\n    webSocketRef.current?.close();\n  };\n\n  const init = useEvent(() => {\n    webSocketRef.current = new WebSocket(\n      typeof url === 'function' ? url() : url,\n      options?.protocols\n    );\n    setStatus('connecting');\n\n    const webSocket = webSocketRef.current;\n    if (!webSocket) return;\n\n    webSocket.onopen = () => {\n      setStatus('connected');\n      options?.onConnected?.(webSocket);\n    };\n\n    webSocket.onerror = (event) => {\n      setStatus('failed');\n      options?.onError?.(event, webSocket);\n    };\n\n    webSocket.onmessage = (event) => options?.onMessage?.(event, webSocket);\n\n    webSocket.onclose = (event) => {\n      setStatus('disconnected');\n      options?.onDisconnected?.(event, webSocket);\n      if (explicityCloseRef.current) return;\n\n      if (retryCountRef.current > 0) {\n        retryCountRef.current -= 1;\n        return init();\n      }\n      retryCountRef.current = options?.retry ? getRetry(options.retry) : 0;\n    };\n  });\n\n  useEffect(() => {\n    init();\n\n    return () => {\n      if (!webSocketRef.current) return;\n      webSocketRef.current.close();\n      webSocketRef.current = undefined;\n    };\n  }, [url]);\n\n  const open = () => {\n    explicityCloseRef.current = false;\n    init();\n  };\n\n  return { client: webSocketRef.current, close, open, send, status };\n};\n"],"names":["useWebSocket","url","options","webSocketRef","useRef","retryCountRef","getRetry","explicityCloseRef","status","setStatus","useState","send","data","close","init","useEvent","webSocket","event","useEffect","open"],"mappings":"6LA4CaA,EAAe,CAC1BC,EACAC,IACuB,CACvB,MAAMC,EAAeC,EAAAA,OAAkB,MAAS,EAC1CC,EAAgBD,EAAAA,OAAOF,GAAS,MAAQI,EAAAA,SAASJ,EAAQ,KAAK,EAAI,CAAC,EACnEK,EAAoBH,EAAAA,OAAO,EAAK,EAEhC,CAACI,EAAQC,CAAS,EAAIC,EAAAA,SAA6B,YAAY,EAE/DC,EAAQC,GACZT,EAAa,SAAS,KAAKS,CAAI,EAE3BC,EAAQ,IAAM,CAClBN,EAAkB,QAAU,GAC5BJ,EAAa,SAAS,MAAA,CAAM,EAGxBW,EAAOC,EAAAA,SAAS,IAAM,CAC1BZ,EAAa,QAAU,IAAI,UACzB,OAAOF,GAAQ,WAAaA,EAAA,EAAQA,EACpCC,GAAS,SAAA,EAEXO,EAAU,YAAY,EAEtB,MAAMO,EAAYb,EAAa,QAC1Ba,IAELA,EAAU,OAAS,IAAM,CACvBP,EAAU,WAAW,EACrBP,GAAS,cAAcc,CAAS,CAAA,EAGlCA,EAAU,QAAWC,GAAU,CAC7BR,EAAU,QAAQ,EAClBP,GAAS,UAAUe,EAAOD,CAAS,CAAA,EAGrCA,EAAU,UAAaC,GAAUf,GAAS,YAAYe,EAAOD,CAAS,EAEtEA,EAAU,QAAWC,GAAU,CAG7B,GAFAR,EAAU,cAAc,EACxBP,GAAS,iBAAiBe,EAAOD,CAAS,EACtC,CAAAT,EAAkB,QAEtB,IAAIF,EAAc,QAAU,EAC1B,OAAAA,EAAc,SAAW,EAClBS,EAAA,EAETT,EAAc,QAAUH,GAAS,MAAQI,EAAAA,SAASJ,EAAQ,KAAK,EAAI,EAAA,EACrE,CACD,EAEDgB,EAAAA,UAAU,KACRJ,EAAA,EAEO,IAAM,CACNX,EAAa,UAClBA,EAAa,QAAQ,MAAA,EACrBA,EAAa,QAAU,OAAA,GAExB,CAACF,CAAG,CAAC,EAER,MAAMkB,EAAO,IAAM,CACjBZ,EAAkB,QAAU,GAC5BO,EAAA,CAAK,EAGP,MAAO,CAAE,OAAQX,EAAa,QAAS,MAAAU,EAAO,KAAAM,EAAM,KAAAR,EAAM,OAAAH,CAAA,CAC5D"}