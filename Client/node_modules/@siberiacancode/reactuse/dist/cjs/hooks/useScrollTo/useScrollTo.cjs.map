{"version":3,"file":"useScrollTo.cjs","sources":["../../../../src/hooks/useScrollTo/useScrollTo.ts"],"sourcesContent":["import { useLayoutEffect } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use scroll to options type */\nexport interface UseScrollToOptions {\n  /** The scrolling behavior */\n  behavior?: ScrollBehavior;\n  /** Whether to enable the scroll to */\n  enabled?: boolean;\n  /** The horizontal position to scroll to */\n  x: number;\n  /** The vertical position to scroll to */\n  y: number;\n}\n\n/** The use scroll to return type */\nexport interface UseScrollToReturn {\n  /** The state of scrolling */\n  trigger: (params?: { x: number; y: number; behavior?: ScrollBehavior }) => void;\n}\n\nexport interface UseScrollTo {\n  <Target extends Element>(\n    options?: UseScrollToOptions,\n    target?: never\n  ): UseScrollToReturn & { ref: StateRef<Target> };\n\n  (target: HookTarget, options?: UseScrollToOptions): UseScrollToReturn;\n}\n\n/**\n * @name useScrollTo\n * @description - Hook for scrolling to a specific element\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} target The target element for scrolling to\n * @param {UseScrollToOptions} [options] The scroll options\n * @returns {UseScrollToReturn} The scroll trigger function\n *\n * @example\n * const trigger = useScrollTo(ref, options);\n *\n * @overload\n * @template Target The target element\n * @param {UseScrollToOptions} [options] The scroll options\n * @returns {UseScrollToReturn & { ref: StateRef<Target> }} The scroll trigger function and ref\n *\n * @example\n * const { ref, trigger } = useScrollTo(options);\n */\nexport const useScrollTo = ((...params: any[]) => {\n  const target = (isTarget(params[0]) ? params[0] : undefined) as HookTarget | undefined;\n  const options = (target ? params[1] : params[0]) as UseScrollToOptions | undefined;\n  const { x, y, behavior = 'auto', enabled = true } = options ?? {};\n  const internalRef = useRefState<Element>();\n\n  useLayoutEffect(() => {\n    if (!enabled) return;\n    if (!target && !internalRef.state) return;\n\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n\n    element.scrollTo({ top: y, left: x, behavior });\n  }, [target, internalRef.state]);\n\n  const trigger = (params?: { x: number; y: number; behavior?: ScrollBehavior }) => {\n    const element = (target ? getElement(target) : internalRef.current) as Element;\n    if (!element) return;\n    const { x, y, behavior } = params ?? {};\n\n    element.scrollTo({ left: x, top: y, behavior });\n  };\n\n  if (target) return { trigger };\n  return { ref: internalRef, trigger };\n}) as UseScrollTo;\n"],"names":["useScrollTo","params","target","isTarget","options","x","y","behavior","enabled","internalRef","useRefState","useLayoutEffect","element","getElement","trigger"],"mappings":"mPA0DaA,EAAe,IAAIC,IAAkB,CAChD,MAAMC,EAAUC,EAAAA,SAASF,EAAO,CAAC,CAAC,EAAIA,EAAO,CAAC,EAAI,OAC5CG,EAAWF,EAASD,EAAO,CAAC,EAAIA,EAAO,CAAC,EACxC,CAAE,EAAAI,EAAG,EAAAC,EAAG,SAAAC,EAAW,OAAQ,QAAAC,EAAU,IAASJ,GAAW,CAAA,EACzDK,EAAcC,EAAAA,YAAA,EAEpBC,EAAAA,gBAAgB,IAAM,CAEpB,GADI,CAACH,GACD,CAACN,GAAU,CAACO,EAAY,MAAO,OAEnC,MAAMG,EAAWV,EAASW,EAAAA,WAAWX,CAAM,EAAIO,EAAY,QACtDG,GAELA,EAAQ,SAAS,CAAE,IAAKN,EAAG,KAAMD,EAAG,SAAAE,EAAU,CAAA,EAC7C,CAACL,EAAQO,EAAY,KAAK,CAAC,EAE9B,MAAMK,EAAWb,GAAiE,CAChF,MAAMW,EAAWV,EAASW,EAAAA,WAAWX,CAAM,EAAIO,EAAY,QAC3D,GAAI,CAACG,EAAS,OACd,KAAM,CAAE,EAAAP,EAAG,EAAAC,EAAG,SAAAC,GAAaN,GAAU,CAAA,EAErCW,EAAQ,SAAS,CAAE,KAAMP,EAAG,IAAKC,EAAG,SAAAC,EAAU,CAAA,EAGhD,OAAIL,EAAe,CAAE,QAAAY,CAAA,EACd,CAAE,IAAKL,EAAa,QAAAK,CAAA,CAC7B"}