{"version":3,"file":"useMouse.cjs","sources":["../../../../src/hooks/useMouse/useMouse.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\n\nimport type { HookTarget } from '@/utils/helpers';\n\nimport { getElement, isTarget } from '@/utils/helpers';\n\nimport type { StateRef } from '../useRefState/useRefState';\n\nimport { useRefState } from '../useRefState/useRefState';\n\n/** The use mouse return type */\nexport interface UseMouseReturn {\n  /** The current mouse client x position */\n  clientX: number;\n  /** The current mouse client y position */\n  clientY: number;\n  /** The current element position x */\n  elementPositionX: number;\n  /** The current element position y */\n  elementPositionY: number;\n  /** The current element x position */\n  elementX: number;\n  /** The current element y position */\n  elementY: number;\n  /** The current mouse x position */\n  x: number;\n  /** The current mouse y position */\n  y: number;\n}\n\nexport interface UseMouse {\n  (target: HookTarget): UseMouseReturn;\n\n  <Target extends Element>(\n    target?: never\n  ): UseMouseReturn & {\n    ref: StateRef<Target>;\n  };\n\n  (target?: Window): UseMouseReturn;\n}\n\n/**\n * @name useMouse\n * @description - Hook that manages a mouse position\n * @category Sensors\n *\n * @overload\n * @param {HookTarget} [target=window] The target element to manage the mouse position for\n * @returns {UseMouseReturn} An object with the current mouse position\n *\n * @example\n * const { x, y, clientX, clientY, elementX, elementY, elementPositionX, elementPositionY } = useMouse(ref);\n *\n * @overload\n * @template Target The target element\n * @returns {UseMouseReturn & { ref: StateRef<Target> }} An object with the current mouse position and a ref\n *\n * @example\n * const { ref, x, y, clientX, clientY, elementX, elementY, elementPositionX, elementPositionY } = useMouse();\n */\nexport const useMouse = ((...params: any[]) => {\n  const target = isTarget(params[0]) ? params[0] : undefined;\n\n  const [value, setValue] = useState<UseMouseReturn>({\n    x: 0,\n    y: 0,\n    elementX: 0,\n    elementY: 0,\n    elementPositionX: 0,\n    elementPositionY: 0,\n    clientX: 0,\n    clientY: 0\n  });\n\n  const internalRef = useRefState<Element>();\n\n  useEffect(() => {\n    const onMouseMove = (event: MouseEvent) => {\n      const element = (target ? getElement(target) : internalRef.current) as Element | undefined;\n\n      const updatedValue = {\n        x: event.pageX,\n        y: event.pageY,\n        clientX: event.clientX,\n        clientY: event.clientY\n      } as typeof value;\n\n      if (element) {\n        const { left, top } = element.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        updatedValue.elementX = elementX;\n        updatedValue.elementY = elementY;\n        updatedValue.elementPositionX = elementPositionX;\n        updatedValue.elementPositionY = elementPositionY;\n\n        setValue((prevValue) => ({\n          ...prevValue,\n          ...updatedValue\n        }));\n      } else {\n        updatedValue.elementX = event.pageX;\n        updatedValue.elementY = event.pageY;\n        updatedValue.elementPositionX = 0;\n        updatedValue.elementPositionY = 0;\n\n        setValue((prevValue) => ({\n          ...prevValue,\n          ...updatedValue\n        }));\n      }\n    };\n\n    const onScroll = () => {\n      setValue((prevValue) => ({\n        ...prevValue,\n        x: prevValue.x + window.scrollX - prevValue.elementPositionX,\n        y: prevValue.y + window.scrollY - prevValue.elementPositionY,\n        elementPositionX: window.scrollX,\n        elementPositionY: window.scrollY\n      }));\n    };\n\n    document.addEventListener('scroll', onScroll, { passive: true });\n    document.addEventListener('mousemove', onMouseMove);\n    return () => {\n      document.removeEventListener('scroll', onScroll);\n      document.removeEventListener('mousemove', onMouseMove);\n    };\n  }, [internalRef.state, target]);\n\n  if (target) return value;\n  return {\n    ref: internalRef,\n    ...value\n  };\n}) as UseMouse;\n"],"names":["useMouse","params","target","isTarget","value","setValue","useState","internalRef","useRefState","useEffect","onMouseMove","event","element","getElement","updatedValue","left","top","elementPositionX","elementPositionY","elementX","elementY","prevValue","onScroll"],"mappings":"mPA6DaA,EAAY,IAAIC,IAAkB,CAC7C,MAAMC,EAASC,EAAAA,SAASF,EAAO,CAAC,CAAC,EAAIA,EAAO,CAAC,EAAI,OAE3C,CAACG,EAAOC,CAAQ,EAAIC,WAAyB,CACjD,EAAG,EACH,EAAG,EACH,SAAU,EACV,SAAU,EACV,iBAAkB,EAClB,iBAAkB,EAClB,QAAS,EACT,QAAS,CAAA,CACV,EAEKC,EAAcC,EAAAA,YAAA,EA4DpB,OA1DAC,EAAAA,UAAU,IAAM,CACd,MAAMC,EAAeC,GAAsB,CACzC,MAAMC,EAAWV,EAASW,EAAAA,WAAWX,CAAM,EAAIK,EAAY,QAErDO,EAAe,CACnB,EAAGH,EAAM,MACT,EAAGA,EAAM,MACT,QAASA,EAAM,QACf,QAASA,EAAM,OAAA,EAGjB,GAAIC,EAAS,CACX,KAAM,CAAE,KAAAG,EAAM,IAAAC,GAAQJ,EAAQ,sBAAA,EACxBK,EAAmBF,EAAO,OAAO,QACjCG,EAAmBF,EAAM,OAAO,QAChCG,EAAWR,EAAM,MAAQM,EACzBG,EAAWT,EAAM,MAAQO,EAE/BJ,EAAa,SAAWK,EACxBL,EAAa,SAAWM,EACxBN,EAAa,iBAAmBG,EAChCH,EAAa,iBAAmBI,EAEhCb,EAAUgB,IAAe,CACvB,GAAGA,EACH,GAAGP,CAAA,EACH,CAAA,MAEFA,EAAa,SAAWH,EAAM,MAC9BG,EAAa,SAAWH,EAAM,MAC9BG,EAAa,iBAAmB,EAChCA,EAAa,iBAAmB,EAEhCT,EAAUgB,IAAe,CACvB,GAAGA,EACH,GAAGP,CAAA,EACH,CACJ,EAGIQ,EAAW,IAAM,CACrBjB,EAAUgB,IAAe,CACvB,GAAGA,EACH,EAAGA,EAAU,EAAI,OAAO,QAAUA,EAAU,iBAC5C,EAAGA,EAAU,EAAI,OAAO,QAAUA,EAAU,iBAC5C,iBAAkB,OAAO,QACzB,iBAAkB,OAAO,OAAA,EACzB,CAAA,EAGJ,gBAAS,iBAAiB,SAAUC,EAAU,CAAE,QAAS,GAAM,EAC/D,SAAS,iBAAiB,YAAaZ,CAAW,EAC3C,IAAM,CACX,SAAS,oBAAoB,SAAUY,CAAQ,EAC/C,SAAS,oBAAoB,YAAaZ,CAAW,CAAA,CACvD,EACC,CAACH,EAAY,MAAOL,CAAM,CAAC,EAE1BA,EAAeE,EACZ,CACL,IAAKG,EACL,GAAGH,CAAA,CAEP"}